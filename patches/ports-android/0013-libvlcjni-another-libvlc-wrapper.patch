From 132215ef7da5364cfde59d9598d402e67a2c1ba2 Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Sat, 13 Oct 2012 09:18:44 +0800
Subject: [PATCH 13/13] libvlcjni: another libvlc wrapper

---
 vlc-android/jni/Android.mk                         |   6 +-
 vlc-android/jni/jni_bundle.c                       | 150 ++++++
 vlc-android/jni/jni_bundle.h                       |  61 +++
 vlc-android/jni/jni_libvlc.h                       |  36 ++
 vlc-android/jni/jni_libvlcevent.c                  |  92 ++++
 vlc-android/jni/jni_libvlcevent.h                  |  32 ++
 vlc-android/jni/jni_vsl.c                          | 312 ++++++++++++
 vlc-android/jni/jni_vsl.h                          |  37 ++
 vlc-android/jni/libvlcjni_danmaku.c                | 566 +++++++++++++++++++++
 vlc-android/jni/libvlcjni_danmaku_events.inc.c     |  65 +++
 .../jni/libvlcjni_danmaku_nativeInitEx.inc.c       |  61 +++
 vlc-android/jni/libvlcjni_fflog.inc.c              |  71 +++
 vlc-android/jni/utils.h                            |   2 +
 vlc-android/jni/vout.c                             |   5 +
 vlc-android/src/org/videolan/libvlc/LibVLC.java    | 168 +++++-
 15 files changed, 1656 insertions(+), 8 deletions(-)
 create mode 100644 vlc-android/jni/jni_bundle.c
 create mode 100644 vlc-android/jni/jni_bundle.h
 create mode 100644 vlc-android/jni/jni_libvlc.h
 create mode 100644 vlc-android/jni/jni_libvlcevent.c
 create mode 100644 vlc-android/jni/jni_libvlcevent.h
 create mode 100644 vlc-android/jni/jni_vsl.c
 create mode 100644 vlc-android/jni/jni_vsl.h
 create mode 100644 vlc-android/jni/libvlcjni_danmaku.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_events.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_fflog.inc.c

diff --git a/vlc-android/jni/Android.mk b/vlc-android/jni/Android.mk
index 7f0236c..7cec112 100644
--- a/vlc-android/jni/Android.mk
+++ b/vlc-android/jni/Android.mk
@@ -3,8 +3,10 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE    := libvlcjni
 
-LOCAL_SRC_FILES := libvlcjni.c libvlcjni-util.c libvlcjni-track.c libvlcjni-medialist.c aout.c vout.c libvlcjni-equalizer.c
-LOCAL_SRC_FILES += thumbnailer.c pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c
+LOCAL_SRC_FILES := libvlcjni-util.c aout.c
+LOCAL_SRC_FILES += pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c vout.c
+LOCAL_SRC_FILES += libvlcjni_danmaku.c
+LOCAL_SRC_FILES += jni_bundle.c jni_libvlcevent.c jni_vsl.c
 LOCAL_SRC_FILES += pipe2.c
 LOCAL_SRC_FILES += wchar/wcpcpy.c
 LOCAL_SRC_FILES += wchar/wcpncpy.c
diff --git a/vlc-android/jni/jni_bundle.c b/vlc-android/jni/jni_bundle.c
new file mode 100644
index 0000000..a99751e
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.c
@@ -0,0 +1,150 @@
+/*****************************************************************************
+ * jni_bundle.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdbool.h>
+
+#define LOG_TAG "VLC/JNI/jni_bundle"
+#include "log.h"
+
+#include "jni_bundle.h"
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    p_bundle->clsBundle = (*env)->FindClass(env, "android/os/Bundle");
+    jmethodID clsCtor = (*env)->GetMethodID(env, p_bundle->clsBundle, "<init>",
+            "()V");
+
+    p_bundle->bundle = (*env)->NewObject(env, p_bundle->clsBundle, clsCtor);
+    p_bundle->needReleaseBundle = true;
+    return p_bundle;
+}
+
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    p_bundle->clsBundle = (*env)->FindClass(env, "android/os/Bundle");
+    p_bundle->bundle = jbundle;
+    p_bundle->needReleaseBundle = false;
+    return p_bundle;
+}
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle) {
+    if (p_bundle->needReleaseBundle && p_bundle->bundle != NULL) {
+        (*env)->DeleteLocalRef(env, p_bundle->bundle);
+    }
+
+    memset(p_bundle, 0, sizeof(JavaBundle));
+}
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value) {
+    if (p_bundle->putInt == NULL) {
+        p_bundle->putInt = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putInt", "(Ljava/lang/String;I)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putInt, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value) {
+    if (p_bundle->getInt == NULL) {
+        p_bundle->getInt = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getInt", "(Ljava/lang/String;I)I");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jint ret = (*env)->CallIntMethod(env, p_bundle->bundle, p_bundle->getInt,
+            j_key, default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value) {
+    if (p_bundle->getLong == NULL) {
+        p_bundle->getLong = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getLong", "(Ljava/lang/String;J)J");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jlong ret = (*env)->CallLongMethod(env, p_bundle->bundle, p_bundle->getLong,
+            j_key, (jlong) default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value) {
+    if (p_bundle->putFloat == NULL) {
+        p_bundle->putFloat = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putFloat", "(Ljava/lang/String;F)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putFloat, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value) {
+    if (p_bundle->putString == NULL) {
+        p_bundle->putString = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putString", "(Ljava/lang/String;Ljava/lang/String;)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jstring j_value = (*env)->NewStringUTF(env, value ? value : "");
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putString, j_key,
+            j_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    (*env)->DeleteLocalRef(env, j_value);
+}
+
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key) {
+    if (p_bundle->getString == NULL) {
+        p_bundle->getString = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getString", "(Ljava/lang/String;)Ljava/lang/String;");
+    }
+
+    char *ret = NULL;
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jobject j_value = (*env)->CallObjectMethod(env, p_bundle->bundle,
+            p_bundle->getString, j_key);
+    (*env)->DeleteLocalRef(env, j_key);
+    if (j_value) {
+        char *utf_chars = (char *) (*env)->GetStringUTFChars(env, j_value,
+                NULL);
+        if (utf_chars) {
+            ret = strdup(utf_chars);
+            (*env)->ReleaseStringUTFChars(env, j_value, utf_chars);
+        }
+        (*env)->DeleteLocalRef(env, j_value);
+    }
+
+    return ret;
+}
diff --git a/vlc-android/jni/jni_bundle.h b/vlc-android/jni/jni_bundle.h
new file mode 100644
index 0000000..13c9ee4
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.h
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * jni_bundle.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_BUNDLE_H
+#define JNI_BUNDLE_H
+
+#include "jni_libvlc.h"
+
+typedef struct {
+    jclass clsBundle;
+    jobject bundle;
+    bool needReleaseBundle;
+
+    jmethodID putInt;
+    jmethodID getInt;
+    jmethodID getLong;
+    jmethodID putFloat;
+    jmethodID putString;
+    jmethodID getString;
+} JavaBundle;
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle);
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle);
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle);
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value);
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value);
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value);
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value);
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value);
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key);
+
+#endif//JNI_BUNDLE_H
diff --git a/vlc-android/jni/jni_libvlc.h b/vlc-android/jni/jni_libvlc.h
new file mode 100644
index 0000000..66b3cb8
--- /dev/null
+++ b/vlc-android/jni/jni_libvlc.h
@@ -0,0 +1,36 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_include.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLC_H
+#define JNI_LIBVLC_H
+
+#include <stdint.h>
+#include <string.h>
+#include <jni.h>
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+#endif//JNI_LIBVLC_H
diff --git a/vlc-android/jni/jni_libvlcevent.c b/vlc-android/jni/jni_libvlcevent.c
new file mode 100644
index 0000000..9dc5ecd
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.c
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * jni_libvlcevent.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "jni_libvlcevent.h"
+
+#define BUNDLE_MediaPlayerBuffering_NEW_CACHE "new_cache"
+#define BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE "new_seekable"
+#define BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE "new_pausable"
+#define BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL "new_cache_total"
+
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoder "video_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl "video_decoder_impl"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoder "audio_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl "audio_decoder_impl"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle) {
+    if (NULL == jbundle_init(env, p_bundle))
+        return NULL;
+
+    switch (ev->type) {
+    case libvlc_MediaPlayerBuffering: {
+        float new_cache = ev->u.media_player_buffering.new_cache;
+        jbundle_put_float(env, p_bundle, BUNDLE_MediaPlayerBuffering_NEW_CACHE,
+                new_cache);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int new_seekable = ev->u.media_player_seekable_changed.new_seekable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE, new_seekable);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int new_pausable = ev->u.media_player_pausable_changed.new_pausable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE, new_pausable);
+        break;
+    }
+    case libvlc_MediaPlayerBufferingTotal: {
+        float new_cache_total =
+                ev->u.media_player_buffering_total.new_cache_total;
+        jbundle_put_float(env, p_bundle,
+                BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL,
+                new_cache_total);
+        break;
+    }
+    case libvlc_MediaPlayerModuleChanged: {
+        const char* video_decoder =
+                ev->u.media_player_module_changed.psz_video_decoder;
+        const char* video_decoder_impl =
+                ev->u.media_player_module_changed.psz_video_decoder_impl;
+        const char* audio_decoder =
+                ev->u.media_player_module_changed.psz_audio_decoder;
+        const char* audio_decoder_impl =
+                ev->u.media_player_module_changed.psz_audio_decoder_impl;
+
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoder, video_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl,
+                video_decoder_impl);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoder, audio_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl,
+                audio_decoder_impl);
+        break;
+    }
+    }
+
+    return p_bundle;
+}
diff --git a/vlc-android/jni/jni_libvlcevent.h b/vlc-android/jni/jni_libvlcevent.h
new file mode 100644
index 0000000..92e39f2
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.h
@@ -0,0 +1,32 @@
+/*****************************************************************************
+ * jni_libvlcevent.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLCEVENT_H
+#define JNI_LIBVLCEVENT_H
+
+#include <vlc/vlc.h>
+#include "jni_bundle.h"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle);
+
+#endif//JNI_LIBVLCEVENT_H
diff --git a/vlc-android/jni/jni_vsl.c b/vlc-android/jni/jni_vsl.c
new file mode 100644
index 0000000..5773b64
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.c
@@ -0,0 +1,312 @@
+/*****************************************************************************
+ * jni_vsl.c: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <jni.h>
+
+#include <vlc/vlc.h>
+
+#include "jni_vsl.h"
+#include "jni_bundle.h"
+
+#define LOG_TAG "VLC/JNI/vsl"
+#include "log.h"
+
+/** Unique Java VM instance, as defined in libvlcjni.c */
+extern JavaVM *myVm;
+
+#define BUNDLE_KEY_BUF_SIZE 64
+#define BUNDLE_COUNT "count"
+
+#define BUNDLE_MRL "segment_mrl"
+#define BUNDLE_URL "segment_url"
+#define BUNDLE_DURATION "duration"
+#define BUNDLE_BYTES "bytes"
+
+static jobject do_get_bundle(JNIEnv* env, jobject gui)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return NULL;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslGetBundle",
+            "()Landroid/os/Bundle;");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslGetBundle");
+        return NULL;
+    }
+
+    jobject jbundle = (*env)->CallObjectMethod(env, gui, methodID);
+    return jbundle;
+}
+
+/* */
+static int do_load(JNIEnv* env, jobject gui, bool b_force_reload)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return -1;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslLoad", "(Z)Z");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslLoad");
+        return -1;
+    }
+
+    jboolean jsuccess = (*env)->CallBooleanMethod(env, gui, methodID,
+            b_force_reload);
+    return jsuccess ? 0 : -1;
+}
+
+int jvsl_load(void *p_cb_data, bool b_force_reload)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_load(env, p_cb_data, b_force_reload);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int do_load_segment(JNIEnv* env, jobject gui, bool b_force_reload, int segment)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return -1;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslLoadSegment", "(ZI)Z");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslLoad");
+        return -1;
+    }
+
+    jboolean jsuccess = (*env)->CallBooleanMethod(env, gui, methodID,
+                                                  b_force_reload, segment);
+    return jsuccess ? 0 : -1;
+}
+
+int jvsl_load_segment(void *p_cb_data, bool b_force_reload, int segment)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_load_segment(env, p_cb_data, b_force_reload, segment);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int do_get_count(JNIEnv* env, jobject gui)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    int ret = jbundle_get_int(env, &javaBundle, BUNDLE_COUNT, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_count(void *p_cb_data)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_count(env, p_cb_data);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static char *do_get_mrl(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_MRL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_mrl: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_mrl(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_mrl(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static char *do_get_url(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_URL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_url: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_url(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_url(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int do_get_duratuon(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_DURATION);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_duratuon: %s", szBuf);
+    int ret = jbundle_get_int(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_duration(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_duratuon(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int64_t do_get_bytes(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_BYTES);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_bytes: %s", szBuf);
+    int64_t ret = jbundle_get_long(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int64_t jvsl_get_bytes(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int64_t ret = do_get_bytes(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
diff --git a/vlc-android/jni/jni_vsl.h b/vlc-android/jni/jni_vsl.h
new file mode 100644
index 0000000..527277a
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.h
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * jni_vsl.h: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_VSL_H
+#define JNI_VSL_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+int     jvsl_load(void *p_cb_data, bool b_force_reload);
+int     jvsl_load_segment(void *p_cb_data, bool b_force_reload, int segment);
+int     jvsl_get_count(void *p_cb_data);
+char   *jvsl_get_mrl(void *p_cb_data, int i_order);
+char   *jvsl_get_url(void *p_cb_data, int i_order);
+int     jvsl_get_duration(void *p_cb_data, int i_order);
+int64_t jvsl_get_bytes(void *p_cb_data, int i_order);
+
+#endif // JNI_VSL_H
diff --git a/vlc-android/jni/libvlcjni_danmaku.c b/vlc-android/jni/libvlcjni_danmaku.c
new file mode 100644
index 0000000..ba6e4de
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku.c
@@ -0,0 +1,566 @@
+/*****************************************************************************
+ * libvlcjni.c
+ *****************************************************************************
+ * Copyright © 2010-2013 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <vlc/vlc.h>
+#include <vlc_common.h>
+#include <vlc_url.h>
+
+#include <jni.h>
+
+#include <android/api-level.h>
+
+#include "../../vlc/contrib/android/ffmpeg/libavutil/avstring.h"
+#include "../../vlc/contrib/android/ffmpeg/libavutil/log.h"
+
+#include "libvlcjni.h"
+#include "aout.h"
+#include "vout.h"
+#include "utils.h"
+
+#define VOUT_ANDROID_SURFACE 0
+#define VOUT_OPENGLES2       1
+
+#define HW_ACCELERATION_DISABLED 0
+#define HW_ACCELERATION_DECODING 1
+#define HW_ACCELERATION_FULL     2
+
+#define LOG_TAG "VLC/JNI/main"
+#include "log.h"
+
+#include "jni_libvlc.h"
+#include "jni_bundle.h"
+#include "jni_libvlcevent.h"
+#include "jni_vsl.h"
+#include "libvlcjni_danmaku_events.inc.c"
+
+#define AOUT_AUDIOTRACK_JAVA 0
+#define AOUT_AUDIOTRACK      1
+#define AOUT_OPENSLES        2
+
+#if 0
+libvlc_media_t *new_media(jlong instance, JNIEnv *env, jobject thiz, jstring fileLocation, bool noOmx, bool noVideo)
+{
+    libvlc_instance_t *libvlc = (libvlc_instance_t*)(intptr_t)instance;
+    jboolean isCopy;
+    const char *psz_location = (*env)->GetStringUTFChars(env, fileLocation, &isCopy);
+    libvlc_media_t *p_md = libvlc_media_new_location(libvlc, psz_location);
+    (*env)->ReleaseStringUTFChars(env, fileLocation, psz_location);
+    if (!p_md)
+        return NULL;
+
+    if (!noOmx) {
+        jclass cls = (*env)->GetObjectClass(env, thiz);
+        jmethodID methodId = (*env)->GetMethodID(env, cls, "getHardwareAcceleration", "()I");
+        int hardwareAcceleration = (*env)->CallIntMethod(env, thiz, methodId);
+        if (hardwareAcceleration == HW_ACCELERATION_DECODING || hardwareAcceleration == HW_ACCELERATION_FULL) {
+            /*
+             * Set higher caching values if using iomx decoding, since some omx
+             * decoders have a very high latency, and if the preroll data isn't
+             * enough to make the decoder output a frame, the playback timing gets
+             * started too soon, and every decoded frame appears to be too late.
+             * On Nexus One, the decoder latency seems to be 25 input packets
+             * for 320x170 H.264, a few packets less on higher resolutions.
+             * On Nexus S, the decoder latency seems to be about 7 packets.
+             */
+            libvlc_media_add_option(p_md, ":file-caching=1500");
+            libvlc_media_add_option(p_md, ":network-caching=1500");
+            libvlc_media_add_option(p_md, ":codec=mediacodec,iomx,all");
+        }
+        if (noVideo)
+            libvlc_media_add_option(p_md, ":no-video");
+    }
+    return p_md;
+}
+#endif
+
+libvlc_media_player_t *getMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_player_t*)(intptr_t)getLong(env, thiz, "mInternalMediaPlayerInstance");
+}
+
+static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t* p_mp = getMediaPlayer(env, thiz);
+    if (p_mp)
+    {
+        libvlc_media_player_stop(p_mp);
+        libvlc_media_player_release(p_mp);
+        setLong(env, thiz, "mInternalMediaPlayerInstance", 0);
+    }
+}
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+JavaVM *myVm;
+
+static jobject eventHandlerInstance = NULL;
+
+/** vout lock declared in vout.c */
+extern pthread_mutex_t vout_android_lock;
+
+#include "libvlcjni_danmaku_events.inc.c"
+static void vlc_event_callback(const libvlc_event_t *ev, void *data)
+{
+    JNIEnv *env;
+
+    bool isAttached = false;
+
+    if (eventHandlerInstance == NULL)
+        return;
+
+    if ((*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2) < 0) {
+        if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) < 0)
+            return;
+        isAttached = true;
+    }
+
+    JavaBundle javaBundle;
+    memset(&javaBundle, 0, sizeof(javaBundle));
+    if (NULL == jbundle_from_event(env, ev, &javaBundle)) {
+        LOGE("EventHandler: failed to crate bundle");
+        return;
+    }
+
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, eventHandlerInstance);
+    if (!cls) {
+        LOGE("EventHandler: failed to get class reference");
+        goto end;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
+    if (methodID) {
+        (*env)->CallVoidMethod(env, eventHandlerInstance, methodID, ev->type, javaBundle.bundle);
+    } else {
+        LOGE("EventHandler: failed to get the callback method");
+    }
+
+end:
+    jbundle_destroy(env, &javaBundle);
+
+    if (isAttached)
+        (*myVm)->DetachCurrentThread(myVm);
+}
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved)
+{
+    // Keep a reference on the Java VM.
+    myVm = vm;
+
+    pthread_mutex_init(&vout_android_lock, NULL);
+    pthread_cond_init(&vout_android_surf_attached, NULL);
+
+    LOGD("JNI interface loaded.");
+    return JNI_VERSION_1_2;
+}
+
+void JNI_OnUnload(JavaVM* vm, void* reserved) {
+    pthread_mutex_destroy(&vout_android_lock);
+    pthread_cond_destroy(&vout_android_surf_attached);
+}
+
+// FIXME: use atomics
+static bool verbosity;
+
+#include "libvlcjni_fflog.inc.c"
+
+void Java_org_videolan_libvlc_LibVLC_changeVerbosity(JNIEnv *env, jobject thiz, jboolean verbose)
+{
+    verbosity = verbose;
+}
+
+#include "libvlcjni_danmaku_nativeInitEx.inc.c"
+#if 0
+void Java_org_videolan_libvlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz)
+{
+    //only use OpenSLES if java side says we can
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    bool use_opensles = (*env)->CallIntMethod(env, thiz, methodId) == AOUT_OPENSLES;
+
+    methodId = (*env)->GetMethodID(env, cls, "getVout", "()I");
+    bool use_opengles2 = (*env)->CallIntMethod(env, thiz, methodId) == VOUT_OPENGLES2;
+
+    methodId = (*env)->GetMethodID(env, cls, "timeStretchingEnabled", "()Z");
+    bool enable_time_stretch = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "frameSkipEnabled", "()Z");
+    bool enable_frame_skip = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "getDeblocking", "()I");
+    int deblocking = (*env)->CallIntMethod(env, thiz, methodId);
+    char deblockstr[2] = "3";
+    snprintf(deblockstr, 2, "%d", deblocking);
+    LOGD("Using deblocking level %d", deblocking);
+
+    methodId = (*env)->GetMethodID(env, cls, "getNetworkCaching", "()I");
+    int networkCaching = (*env)->CallIntMethod(env, thiz, methodId);
+    char networkCachingstr[25] = "0";
+    if(networkCaching > 0) {
+        snprintf(networkCachingstr, 25, "--network-caching=%d", networkCaching);
+        LOGD("Using network caching of %d ms", networkCaching);
+    }
+
+    methodId = (*env)->GetMethodID(env, cls, "getChroma", "()Ljava/lang/String;");
+    jstring chroma = (*env)->CallObjectMethod(env, thiz, methodId);
+    const char *chromastr = (*env)->GetStringUTFChars(env, chroma, 0);
+    LOGD("Chroma set to \"%s\"", chromastr);
+
+    methodId = (*env)->GetMethodID(env, cls, "getSubtitlesEncoding", "()Ljava/lang/String;");
+    jstring subsencoding = (*env)->CallObjectMethod(env, thiz, methodId);
+    const char *subsencodingstr = (*env)->GetStringUTFChars(env, subsencoding, 0);
+    LOGD("Subtitle encoding set to \"%s\"", subsencodingstr);
+
+    methodId = (*env)->GetMethodID(env, cls, "isVerboseMode", "()Z");
+    verbosity = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "getHardwareAcceleration", "()I");
+    int hardwareAcceleration = (*env)->CallIntMethod(env, thiz, methodId);
+    /* With the MediaCodec opaque mode we cannot use the OpenGL ES vout. */
+    if (hardwareAcceleration == HW_ACCELERATION_FULL)
+        use_opengles2 = false;
+
+    /* Don't add any invalid options, otherwise it causes LibVLC to crash */
+    const char *argv[] = {
+        "-I", "dummy",
+        "--no-osd",
+        "--no-video-title-show",
+        "--no-stats",
+        "--no-plugins-cache",
+        "--no-drop-late-frames",
+        /* The VLC default is to pick the highest resolution possible
+         * (i.e. 1080p). For mobile, pick a more sane default for slow
+         * mobile data networks and slower hardware. */
+        "--preferred-resolution", "360",
+        "--avcodec-fast",
+        "--avcodec-threads=0",
+        "--subsdec-encoding", subsencodingstr,
+        enable_time_stretch ? "--audio-time-stretch" : "--no-audio-time-stretch",
+        "--avcodec-skiploopfilter", deblockstr,
+        "--avcodec-skip-frame", enable_frame_skip ? "2" : "0",
+        "--avcodec-skip-idct", enable_frame_skip ? "2" : "0",
+        (networkCaching > 0) ? networkCachingstr : "",
+        use_opensles ? "--aout=opensles" : "--aout=android_audiotrack",
+        use_opengles2 ? "--vout=gles2" : "--vout=androidsurface",
+        "--androidsurface-chroma", chromastr != NULL && chromastr[0] != 0 ? chromastr : "RV32",
+        (hardwareAcceleration == HW_ACCELERATION_FULL) ? "" : "--no-mediacodec-dr",
+    };
+    libvlc_instance_t *instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    (*env)->ReleaseStringUTFChars(env, chroma, chromastr);
+    (*env)->ReleaseStringUTFChars(env, subsencoding, subsencodingstr);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/libvlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+
+    libvlc_log_set(instance, debug_log, &verbosity);
+}
+#endif
+
+void Java_org_videolan_libvlc_LibVLC_nativeDestroy(JNIEnv *env, jobject thiz)
+{
+    releaseMediaPlayer(env, thiz);
+    jlong libVlcInstance = getLong(env, thiz, "mLibVlcInstance");
+    if (!libVlcInstance)
+        return; // Already destroyed
+
+    libvlc_instance_t *instance = (libvlc_instance_t*)(intptr_t) libVlcInstance;
+    libvlc_log_unset(instance);
+    libvlc_release(instance);
+
+    setLong(env, thiz, "mLibVlcInstance", 0);
+}
+
+void Java_org_videolan_libvlc_LibVLC_detachEventHandler(JNIEnv *env, jobject thiz)
+{
+    if (eventHandlerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventHandlerInstance);
+        eventHandlerInstance = NULL;
+    }
+}
+
+void Java_org_videolan_libvlc_LibVLC_setEventHandler(JNIEnv *env, jobject thiz, jobject eventHandler)
+{
+    if (eventHandlerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventHandlerInstance);
+        eventHandlerInstance = NULL;
+    }
+
+    eventHandlerInstance = getEventHandlerReference(env, thiz, eventHandler);
+}
+
+void Java_org_videolan_libvlc_LibVLC_playMRL(JNIEnv *env, jobject thiz, jlong instance,
+                                             jstring mrl, jobjectArray mediaOptions)
+{
+    /* Release previous media player, if any */
+    releaseMediaPlayer(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_player_t *mp = libvlc_media_player_new((libvlc_instance_t*)(intptr_t)instance);
+    jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
+
+#if 0
+    //if AOUT_AUDIOTRACK_JAVA, we use amem
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    if ( (*env)->CallIntMethod(env, thiz, methodId) == AOUT_AUDIOTRACK_JAVA )
+    {
+        libvlc_audio_set_callbacks(mp, aout_play, aout_pause, NULL, NULL, NULL,
+                                   (void*) myJavaLibVLC);
+        libvlc_audio_set_format_callbacks(mp, aout_open, aout_close);
+    }
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaPlayerPlaying,
+        libvlc_MediaPlayerPaused,
+        libvlc_MediaPlayerEndReached,
+        libvlc_MediaPlayerStopped,
+        libvlc_MediaPlayerVout,
+        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerEncounteredError
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+#endif
+
+
+    /* Keep a pointer to this media player */
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)(intptr_t)mp);
+
+#if 0
+    cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "applyEqualizer", "()V");
+    (*env)->CallVoidMethod(env, thiz, methodID);
+#endif
+
+    const char* p_mrl = (*env)->GetStringUTFChars(env, mrl, 0);
+
+    libvlc_media_t* p_md = libvlc_media_new_location((libvlc_instance_t*)(intptr_t)instance, p_mrl);
+    /* media options */
+    if (mediaOptions != NULL)
+    {
+        int stringCount = (*env)->GetArrayLength(env, mediaOptions);
+        for(int i = 0; i < stringCount; i++)
+        {
+            jstring option = (jstring)(*env)->GetObjectArrayElement(env, mediaOptions, i);
+            const char* p_st = (*env)->GetStringUTFChars(env, option, 0);
+            LOGD("  %s", p_st);
+            if (!strncmp(p_st, ":aout=", 6)) {
+                // seems ":aout" does not effect libvlc_media_add_option()
+                const char* aout_name = p_st + 6;
+                if (!strncmp(aout_name, "audiotrack_java", 15)) {
+                    LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                    libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL,
+                                               NULL, NULL, (void*) myJavaLibVLC);
+                    libvlc_audio_set_format_callbacks(mp, aout_open,
+                                                      aout_close);
+                } else {
+                    LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                    libvlc_audio_output_set(mp, aout_name);
+                }
+            } else {
+                libvlc_media_add_option(p_md, p_st); // option
+            }
+            (*env)->ReleaseStringUTFChars(env, option, p_st);
+        }
+    }
+
+    (*env)->ReleaseStringUTFChars(env, mrl, p_mrl);
+
+    // FIXME: do not use get_vout_android_gui() for java_mp
+    libvlc_media_player_set_vsl_callback(mp, get_vout_android_gui(), //
+                                         jvsl_load, //
+                                         jvsl_load_segment, //
+                                         jvsl_get_count, //
+                                         jvsl_get_mrl, //
+                                         jvsl_get_url, //
+                                         jvsl_get_duration, //
+                                         jvsl_get_bytes);
+
+    libvlc_media_player_set_media(mp, p_md);
+    /* No need to keep the media now */
+    libvlc_media_release(p_md);
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    for (int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    p_md = libvlc_media_player_get_media(mp);
+    if (p_md) {
+        ev = libvlc_media_event_manager(p_md);
+        for (int i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
+        }
+    }
+
+    libvlc_media_player_play(mp);
+}
+
+#if 0
+jfloat Java_org_videolan_libvlc_LibVLC_getRate(JNIEnv *env, jobject thiz) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        return libvlc_media_player_get_rate(mp);
+    else
+        return 1.00;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setRate(JNIEnv *env, jobject thiz, jfloat rate) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        libvlc_media_player_set_rate(mp, rate);
+}
+#endif
+
+jboolean Java_org_videolan_libvlc_LibVLC_hasMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return !!getMediaPlayer(env, thiz);
+}
+
+jboolean Java_org_videolan_libvlc_LibVLC_isPlaying(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_playing(mp);
+    else
+        return 0;
+}
+
+jboolean Java_org_videolan_libvlc_LibVLC_isSeekable(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_seekable(mp);
+    return 0;
+}
+
+void Java_org_videolan_libvlc_LibVLC_play(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_play(mp);
+}
+
+void Java_org_videolan_libvlc_LibVLC_pause(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_pause(mp);
+}
+
+void Java_org_videolan_libvlc_LibVLC_stop(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_stop(mp);
+}
+
+#if 0
+jint Java_org_videolan_libvlc_LibVLC_getVolume(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_audio_get_volume(mp);
+    return -1;
+}
+
+jint Java_org_videolan_libvlc_LibVLC_setVolume(JNIEnv *env, jobject thiz, jint volume)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        //Returns 0 if the volume was set, -1 if it was out of range or error
+        return (jint) libvlc_audio_set_volume(mp, (int) volume);
+    return -1;
+}
+#endif
+
+jlong Java_org_videolan_libvlc_LibVLC_getTime(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_media_player_get_time(mp);
+    return -1;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setTime(JNIEnv *env, jobject thiz, jlong time)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_time(mp, time);
+}
+
+jfloat Java_org_videolan_libvlc_LibVLC_getPosition(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jfloat) libvlc_media_player_get_position(mp);
+    return -1;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setPosition(JNIEnv *env, jobject thiz, jfloat pos)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_position(mp, pos);
+}
+
+jlong Java_org_videolan_libvlc_LibVLC_getLength(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jlong) libvlc_media_player_get_length(mp);
+    return -1;
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_version(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_version());
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_compiler(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_compiler());
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_changeset(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_changeset());
+}
diff --git a/vlc-android/jni/libvlcjni_danmaku_events.inc.c b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
new file mode 100644
index 0000000..7b129ed
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
@@ -0,0 +1,65 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_events.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+#define LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+static const libvlc_event_type_t md_events[] = {
+//        libvlc_MediaMetaChanged,
+//        libvlc_MediaSubItemAdded,
+        libvlc_MediaDurationChanged, //
+        libvlc_MediaParsedChanged, //
+//        libvlc_MediaFreed,
+        libvlc_MediaStateChanged, //
+        };
+
+static const libvlc_event_type_t mp_events[] = {
+//        libvlc_MediaPlayerMediaChanged,
+//        libvlc_MediaPlayerNothingSpecial,
+        libvlc_MediaPlayerOpening, //
+        libvlc_MediaPlayerBuffering, //
+        libvlc_MediaPlayerPlaying, //
+        libvlc_MediaPlayerPaused, //
+        libvlc_MediaPlayerStopped, //
+//        libvlc_MediaPlayerForward,
+//        libvlc_MediaPlayerBackward,
+        libvlc_MediaPlayerEndReached, //
+        libvlc_MediaPlayerEncounteredError, //
+//        libvlc_MediaPlayerTimeChanged,
+//        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerSeekableChanged, //
+        libvlc_MediaPlayerPausableChanged, //
+//        libvlc_MediaPlayerTitleChanged,
+//        libvlc_MediaPlayerSnapshotTaken,
+        libvlc_MediaPlayerLengthChanged, //
+//        libvlc_MediaPlayerVout,
+        libvlc_MediaPlayerBufferingTotal, //
+        libvlc_MediaPlayerModuleChanged, //
+        };
+
+#endif//LIBVLCJNI_DANMAKU_INCLUDE_INC_C
diff --git a/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
new file mode 100644
index 0000000..ab052f3
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_nativeInitEx.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+#define LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+
+void Java_org_videolan_libvlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jboolean verbose, jarray arguments)
+{
+    libvlc_instance_t *instance = NULL;
+
+    int user_argc = (*env)->GetArrayLength(env, arguments);
+    char **user_argv = (char **) calloc(user_argc, sizeof(char *));
+    int i = 0;
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            user_argv[i] = (char *) (*env)->GetStringUTFChars(env, argument, NULL);
+    }
+    instance = libvlc_new(user_argc, (const char **) user_argv);
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            (*env)->ReleaseStringUTFChars(env, argument, user_argv[i]);
+    }
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/libvlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+
+    libvlc_log_set(instance, debug_log, &verbosity);
+    av_log_set_callback(ffmpeg_debug_log);
+}
+
+#endif//LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
diff --git a/vlc-android/jni/libvlcjni_fflog.inc.c b/vlc-android/jni/libvlcjni_fflog.inc.c
new file mode 100644
index 0000000..632c6f2
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_fflog.inc.c
@@ -0,0 +1,71 @@
+/*****************************************************************************
+ * libvlcjni_fflog.inc.c
+ *****************************************************************************
+ * Copyright © 2013 Zhang Rui <bbcallen@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+static void ffmpeg_debug_log(void* ptr, int level, const char* fmt, va_list vl)
+{
+    bool *verbose = &verbosity;
+
+    int prio = ANDROID_LOG_DEBUG;
+    if      (level <= AV_LOG_ERROR)     prio = ANDROID_LOG_ERROR;
+    else if (level <= AV_LOG_WARNING)   prio = ANDROID_LOG_WARN;
+    else if (level <= AV_LOG_INFO)      prio = ANDROID_LOG_INFO;
+    else if (level <= AV_LOG_VERBOSE)   prio = ANDROID_LOG_DEBUG;
+    else                                prio = ANDROID_LOG_DEBUG;
+
+    if (!*verbose)
+        return;
+
+    static int print_prefix = 1;
+    static int count;
+    static char prev[1024];
+    char line[1024];
+    static int is_atty;
+    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;
+    line[0] = 0;
+    if (print_prefix && avc) {
+        if (avc->parent_log_context_offset) {
+            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +
+                                               avc->parent_log_context_offset);
+            if (parent && *parent) {
+                snprintf(line, sizeof(line), "[%s @ %p] ",
+                         (*parent)->item_name(parent), parent);
+            }
+        }
+        snprintf(line + strlen(line), sizeof(line) - strlen(line), "[%s @ %p] ",
+                 avc->item_name(ptr), ptr);
+    }
+
+    vsnprintf(line + strlen(line), sizeof(line) - strlen(line), fmt, vl);
+
+    print_prefix = strlen(line) && line[strlen(line) - 1] == '\n';
+
+    if (print_prefix && !strncmp(line, prev, sizeof line)) {
+        count++;
+        if (is_atty == 1)
+            fprintf(stderr, "    Last message repeated %d times\r", count);
+        return;
+    }
+    if (count > 0) {
+        fprintf(stderr, "    Last message repeated %d times\n", count);
+        count = 0;
+    }
+    __android_log_write(prio, "VLC-FF", line);
+    av_strlcpy(prev, line, sizeof line);
+}
diff --git a/vlc-android/jni/utils.h b/vlc-android/jni/utils.h
index f8502d9..182099b 100644
--- a/vlc-android/jni/utils.h
+++ b/vlc-android/jni/utils.h
@@ -45,4 +45,6 @@ jobject getEventHandlerReference(JNIEnv *env, jobject thiz, jobject eventHandler
 
 void debug_log(void *data, int level, const libvlc_log_t *ctx, const char *fmt, va_list ap);
 
+void *get_vout_android_gui();
+
 #endif // LIBVLCJNI_UTILS_H
diff --git a/vlc-android/jni/vout.c b/vlc-android/jni/vout.c
index cac3213..17d291f 100644
--- a/vlc-android/jni/vout.c
+++ b/vlc-android/jni/vout.c
@@ -33,6 +33,11 @@ static void *vout_android_gui = NULL;
 static jobject vout_android_java_surf = NULL;
 static jobject vout_android_subtitles_surf = NULL;
 
+// FIXME: this is VlcMediaPlayer
+extern void *get_vout_android_gui() {
+    return vout_android_gui;
+}
+
 void *jni_LockAndGetSubtitlesSurface() {
     pthread_mutex_lock(&vout_android_lock);
     while (vout_android_subtitles_surf == NULL)
diff --git a/vlc-android/src/org/videolan/libvlc/LibVLC.java b/vlc-android/src/org/videolan/libvlc/LibVLC.java
index 8838d04..68291d8 100644
--- a/vlc-android/src/org/videolan/libvlc/LibVLC.java
+++ b/vlc-android/src/org/videolan/libvlc/LibVLC.java
@@ -21,7 +21,14 @@
 package org.videolan.libvlc;
 
 import java.util.ArrayList;
-import java.util.Map;
+
+import org.videolan.libvlc.LibVlcException;
+
+import tv.danmaku.pragma.Pragma;
+import tv.danmaku.android.annotations.CalledByNative;
+import tv.danmaku.android.util.CollectionHelper;
+import tv.danmaku.android.util.DebugLog;
+//import tv.danmaku.bili.pluginapk.PluginApkManager;
 
 import android.content.Context;
 import android.os.Build;
@@ -30,12 +37,18 @@ import android.view.Surface;
 
 public class LibVLC {
     private static final String TAG = "VLC/LibVLC";
+
+    private static boolean mLibIomxLoaded = false;
+    private static boolean mLibVlcLoaded = false;
+
+    /*- MERGE
     public static final int AOUT_AUDIOTRACK_JAVA = 0;
     public static final int AOUT_AUDIOTRACK = 1;
     public static final int AOUT_OPENSLES = 2;
 
     public static final int VOUT_ANDROID_SURFACE = 0;
     public static final int VOUT_OPEGLES2 = 1;
+    */
 
     private static LibVLC sInstance;
 
@@ -45,12 +58,16 @@ public class LibVLC {
     private int mInternalMediaPlayerIndex = 0; // Read-only, reserved for JNI
     private long mInternalMediaPlayerInstance = 0; // Read-only, reserved for JNI
 
+    /*- MERGE
     private MediaList mMediaList; // Pointer to media list being followed
     private MediaList mPrimaryList; // Primary/default media list; see getPrimaryMediaList()
+    */
 
     /** Buffer for VLC messages */
+    /*- MERGE
     private StringBuffer mDebugLogBuffer;
     private boolean mIsBufferingLog = false;
+    */
 
     private Aout mAout;
 
@@ -58,6 +75,7 @@ public class LibVLC {
     //private WakeLock mWakeLock;
 
     /** Settings */
+    /*- MERGE
     private int hardwareAcceleration = -1;
     private String subtitlesEncoding = "";
     private int aout = LibVlcUtil.isGingerbreadOrLater() ? AOUT_OPENSLES : AOUT_AUDIOTRACK_JAVA;
@@ -69,15 +87,19 @@ public class LibVLC {
     private float[] equalizer = null;
     private boolean frameSkip = false;
     private int networkCaching = 0;
+    */
 
     /** Check in libVLC already initialized otherwise crash */
     private boolean mIsInitialized = false;
+
     public native void attachSurface(Surface surface, IVideoPlayer player);
 
     public native void detachSurface();
 
+    /*- MERGE
     public native void attachSubtitlesSurface(Surface surface);
     public native void detachSubtitlesSurface();
+    */
 
     /* Load library before object instantiation */
     static {
@@ -103,6 +125,37 @@ public class LibVLC {
             System.exit(1);
         }
     }
+    private static void loadLib(Context context, LibVlcLibraryLoader libLoader)
+            throws LibVlcException {
+        synchronized (LibVLC.class) {
+            if (!mLibIomxLoaded) {
+                try {
+                    libLoader.loadVlcLibIomx(context);
+                } catch (Throwable t) {
+                    DebugLog.w(TAG, "Unable to load the iomx library: " + t);
+                    throw new LibVlcException(t);
+                }
+            }
+
+            if (mLibVlcLoaded)
+                return;
+
+            try {
+                DebugLog.d(TAG, "loading vlcjni");
+                libLoader.loadLibVlc(context);
+                DebugLog.d(TAG, "vlcjni loaded: ");
+                mLibVlcLoaded = true;
+            } catch (UnsatisfiedLinkError ule) {
+                DebugLog.e(TAG, "Can't load vlcjni library: " + ule);
+                throw new LibVlcException(ule);
+            } catch (SecurityException se) {
+                DebugLog.e(TAG,
+                        "Encountered a security issue when loading vlcjni library: "
+                                + se);
+                throw new LibVlcException(se);
+            }
+        }
+    }
 
     /**
      * Singleton constructor of libVLC Without surface and vout to create the
@@ -111,11 +164,23 @@ public class LibVLC {
      * @return libVLC instance
      * @throws LibVlcException
      */
-    public static LibVLC getInstance() throws LibVlcException {
+    public static LibVLC getInstance(Context context,
+            LibVlcLibraryLoader libLoader) throws LibVlcException {
         synchronized (LibVLC.class) {
             if (sInstance == null) {
                 /* First call */
+                loadLib(context, libLoader);
                 sInstance = new LibVLC();
+
+                ArrayList<String> params = new ArrayList<String>();
+                CollectionHelper.Append(params, LibVLCOptions.sDefaultParameters);
+
+                DebugLog.v(TAG, "libvlc arguments:");
+                for (String par : params) {
+                    DebugLog.v(TAG, "    " + par);
+                }
+
+                sInstance.initEx(params.toArray(new String[params.size()]));
             }
         }
 
@@ -160,25 +225,32 @@ public class LibVLC {
      *
      * @return The media list object being followed
      */
+    /*- MERGE
     public MediaList getMediaList() {
         return mMediaList;
     }
+    */
+
 
     /**
      * Set the media list for LibVLC to follow.
      *
      * @param mediaList The media list object to follow
      */
+    /*- MERGE
     public void setMediaList(MediaList mediaList) {
         mMediaList = mediaList;
     }
+    */
 
     /**
      * Sets LibVLC to follow the default media list (see below)
      */
+    /*- MERGE
     public void setMediaList() {
         mMediaList = mPrimaryList;
     }
+    */
 
     /**
      * Gets the primary media list, or the "currently playing" list.
@@ -194,9 +266,11 @@ public class LibVLC {
      *
      * @return The primary media list
      */
+    /*- MERGE
     public MediaList getPrimaryMediaList() {
         return mPrimaryList;
     }
+    */
 
     /**
      * Give to LibVLC the surface to draw the video.
@@ -204,6 +278,7 @@ public class LibVLC {
      */
     public native void setSurface(Surface f);
 
+    /*-
     public static synchronized void restart(Context context) {
         if (sInstance != null) {
             try {
@@ -214,11 +289,13 @@ public class LibVLC {
             }
         }
     }
+    */
 
     /**
      * those get/is* are called from native code to get settings values.
      */
 
+    /*- MERGE
     public int getHardwareAcceleration() {
         return this.hardwareAcceleration;
     }
@@ -276,13 +353,13 @@ public class LibVLC {
     public int getDeblocking() {
         int ret = deblocking;
         if(deblocking < 0) {
-            /**
+             **
              * Set some reasonable deblocking defaults:
              *
              * Skip all (4) for armv6 and MIPS by default
              * Skip non-ref (1) for all armv7 more than 1.2 Ghz and more than 2 cores
              * Skip non-key (3) for all devices that don't meet anything above
-             */
+             *
             LibVlcUtil.MachineSpecs m = LibVlcUtil.getMachineSpecs();
             if( (m.hasArmV6 && !(m.hasArmV7)) || m.hasMips )
                 ret = 4;
@@ -348,14 +425,15 @@ public class LibVLC {
     public void setNetworkCaching(int networkcaching) {
         this.networkCaching = networkcaching;
     }
+    */
 
     /**
      * Initialize the libVLC class.
-     *
      * This function must be called before using any libVLC functions.
      *
      * @throws LibVlcException
      */
+    /*- MERGE
     public void init(Context context) throws LibVlcException {
         Log.v(TAG, "Initializing LibVLC");
         mDebugLogBuffer = new StringBuffer();
@@ -370,9 +448,19 @@ public class LibVLC {
             mIsInitialized = true;
         }
     }
+    */
+    private void initEx(String[] params) throws LibVlcException {
+        DebugLog.v(TAG, "Initializing LibVLC");
+        if (!mIsInitialized) {
+            nativeInitEx(Pragma.DEBUG, params);
+            setEventHandler(EventHandler.getInstance());
+            mIsInitialized = true;
+        }
+    }
 
     /**
      * Destroy this libVLC instance
+     *
      * @note You must call it before exiting
      */
     public void destroy() {
@@ -422,6 +510,7 @@ public class LibVLC {
      *
      * @param position The index of the media
      */
+    /*- MERGE
     public void playIndex(int position) {
         String mrl = mMediaList.getMRL(position);
         if (mrl == null)
@@ -430,12 +519,14 @@ public class LibVLC {
         mInternalMediaPlayerIndex = position;
         playMRL(mLibVlcInstance, mrl, options);
     }
+    */
 
     /**
      * Play an MRL directly.
      *
      * @param mrl MRL of the media to play.
      */
+    /*- MERGE
     public void playMRL(String mrl) {
         // index=-1 will return options from libvlc instance without relying on MediaList
         String[] options = mMediaList.getMediaOptions(-1);
@@ -446,38 +537,62 @@ public class LibVLC {
     public TrackInfo[] readTracksInfo(String mrl) {
         return readTracksInfo(mLibVlcInstance, mrl);
     }
+    */
 
     /**
      * Get a media thumbnail.
      */
+    /*- MERGE
     public byte[] getThumbnail(String mrl, int i_width, int i_height) {
         return getThumbnail(mLibVlcInstance, mrl, i_width, i_height);
     }
+    */
 
     /**
      * Return true if there is a video track in the file
      */
+    /*- MERGE
     public boolean hasVideoTrack(String mrl) throws java.io.IOException {
         return hasVideoTrack(mLibVlcInstance, mrl);
     }
+    */
 
     /**
      * Sets the speed of playback (1 being normal speed, 2 being twice as fast)
      *
      * @param rate
      */
+    /*- MERGE
     public native void setRate(float rate);
+    */
 
     /**
      * Get the current playback speed
      */
+    /*- MERGE
     public native float getRate();
+    */
+
+    public void readMediaEx(String mrl, String[] options) {
+        DebugLog.v(TAG, "Reading " + mrl);
+
+        DebugLog.v(TAG, "libvlcplayer options:");
+        for (String opt : options) {
+            DebugLog.v(TAG, "    " + opt);
+        }
+
+        readMediaEx(mLibVlcInstance, mrl, options);
+    }
+
+    public native void changeVerbosity(boolean verbose);
 
     /**
      * Initialize the libvlc C library
+     *
      * @return a pointer to the libvlc instance
      */
-    private native void nativeInit() throws LibVlcException;
+    private native void nativeInitEx(boolean verbose, String[] params)
+            throws LibVlcException;
 
     /**
      * Close the libvlc C library
@@ -488,6 +603,7 @@ public class LibVLC {
     /**
      * Start buffering to the mDebugLogBuffer.
      */
+    /*- MERGE
     public native void startDebugBuffer();
     public native void stopDebugBuffer();
     public String getBufferContent() {
@@ -501,11 +617,29 @@ public class LibVLC {
     public boolean isDebugBuffering() {
         return mIsBufferingLog;
     }
+    */
 
     /**
      * Play an mrl
      */
+    /*- MERGE
     private native void playMRL(long instance, String mrl, String[] mediaOptions);
+    */
+
+    /**
+     * Read a media
+     *
+     * @param instance
+     *            : the instance of libVLC
+     * @param mrl
+     *            : the media mrl
+     */
+    private native int readMediaEx(long instance, String mrl, String[] options);
+
+    /**
+     * Return true if there is currently a running media player.
+     */
+    public native boolean hasMediaPlayer();
 
     /**
      * Returns true if any media is playing
@@ -535,13 +669,17 @@ public class LibVLC {
     /**
      * Gets volume as integer
      */
+    /*- MERGE
     public native int getVolume();
+    */
 
     /**
      * Sets volume as integer
      * @param volume: Volume level passed as integer
      */
+    /*- MERGE
     public native int setVolume(int volume);
+    */
 
     /**
      * Gets the current movie time (in ms).
@@ -578,29 +716,38 @@ public class LibVLC {
      * Get the libVLC version
      * @return the libVLC version string
      */
+    /*- MERGE
     public native String version();
+    */
 
     /**
      * Get the libVLC compiler
      * @return the libVLC compiler string
      */
+    /*- MERGE
     public native String compiler();
+    */
 
     /**
      * Get the libVLC changeset
      * @return the libVLC changeset string
      */
+    /*- MERGE
     public native String changeset();
+    */
 
     /**
      * Get a media thumbnail.
      * @return a bytearray with the RGBA thumbnail data inside.
      */
+    /*- MERGE
     private native byte[] getThumbnail(long instance, String mrl, int i_width, int i_height);
+    */
 
     /**
      * Return true if there is a video track in the file
      */
+    /*- MERGE
     private native boolean hasVideoTrack(long instance, String mrl);
 
     private native TrackInfo[] readTracksInfo(long instance, String mrl);
@@ -628,6 +775,7 @@ public class LibVLC {
     public native int getSpuTracksCount();
 
     public static native String nativeToURI(String path);
+    */
 
     /**
      * Quickly converts path to URIs, which are mandatory in libVLC.
@@ -636,6 +784,7 @@ public class LibVLC {
      *            The path to be converted.
      * @return A URI representation of path
      */
+    /*- MERGE
     public static String PathToURI(String path) {
         if(path == null) {
             throw new NullPointerException("Cannot convert null path!");
@@ -646,34 +795,41 @@ public class LibVLC {
     public static native void nativeReadDirectory(String path, ArrayList<String> res);
 
     public native static boolean nativeIsPathDirectory(String path);
+    */
 
      /**
       * Expand and continue playing the current media.
       *
       * @return the index of the media was expanded, and -1 if no media was expanded
       */
+    /*- MERGE
     public int expandAndPlay() {
         int r = mMediaList.expandMedia(mInternalMediaPlayerIndex);
         if(r == 0)
             this.playIndex(mInternalMediaPlayerIndex);
         return r;
     }
+    */
 
     /**
      * Expand the current media.
      * @return the index of the media was expanded, and -1 if no media was expanded
      */
+    /*-
     public int expand() {
         return mMediaList.expandMedia(mInternalMediaPlayerIndex);
     }
+    */
 
     private native void setEventHandler(EventHandler eventHandler);
 
     private native void detachEventHandler();
 
+    /*- MERGE
     public native float[] getBands();
 
     public native String[] getPresets();
 
     public native float[] getPreset(int index);
+    */
 }
-- 
1.8.3.4

