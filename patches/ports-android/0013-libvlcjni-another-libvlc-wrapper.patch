From 3dfe18710441940ace6a09181ae43b73447d7fdb Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Sat, 13 Oct 2012 09:18:44 +0800
Subject: [PATCH] libvlcjni: another libvlc wrapper

---
 vlc-android/jni/Android.mk                         |   6 +-
 vlc-android/jni/jni_bundle.c                       | 162 ++++++
 vlc-android/jni/jni_bundle.h                       |  60 +++
 vlc-android/jni/jni_libvlc.c                       |  72 +++
 vlc-android/jni/jni_libvlc.h                       |  38 ++
 vlc-android/jni/jni_libvlcevent.c                  |  92 ++++
 vlc-android/jni/jni_libvlcevent.h                  |  32 ++
 vlc-android/jni/jni_vsl.c                          | 300 +++++++++++
 vlc-android/jni/jni_vsl.h                          |  37 ++
 vlc-android/jni/libvlcjni-util.c                   |  17 +-
 vlc-android/jni/libvlcjni_danmaku.c                | 567 +++++++++++++++++++++
 vlc-android/jni/libvlcjni_danmaku_events.inc.c     |  65 +++
 .../jni/libvlcjni_danmaku_nativeInitEx.inc.c       |  61 +++
 vlc-android/jni/libvlcjni_fflog.inc.c              |  71 +++
 vlc-android/jni/utils.h                            |   2 +
 vlc-android/jni/vout.c                             |   9 +
 16 files changed, 1586 insertions(+), 5 deletions(-)
 create mode 100644 vlc-android/jni/jni_bundle.c
 create mode 100644 vlc-android/jni/jni_bundle.h
 create mode 100644 vlc-android/jni/jni_libvlc.c
 create mode 100644 vlc-android/jni/jni_libvlc.h
 create mode 100644 vlc-android/jni/jni_libvlcevent.c
 create mode 100644 vlc-android/jni/jni_libvlcevent.h
 create mode 100644 vlc-android/jni/jni_vsl.c
 create mode 100644 vlc-android/jni/jni_vsl.h
 create mode 100644 vlc-android/jni/libvlcjni_danmaku.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_events.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_fflog.inc.c

diff --git a/vlc-android/jni/Android.mk b/vlc-android/jni/Android.mk
index 7e1225b..982f6e2 100644
--- a/vlc-android/jni/Android.mk
+++ b/vlc-android/jni/Android.mk
@@ -3,8 +3,10 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE    := libvlcjni
 
-LOCAL_SRC_FILES := libvlcjni.c libvlcjni-util.c libvlcjni-track.c libvlcjni-medialist.c aout.c vout.c libvlcjni-equalizer.c
-LOCAL_SRC_FILES += thumbnailer.c pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c
+LOCAL_SRC_FILES := libvlcjni-util.c aout.c
+LOCAL_SRC_FILES += pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c vout.c
+LOCAL_SRC_FILES += libvlcjni_danmaku.c
+LOCAL_SRC_FILES += jni_bundle.c jni_libvlcevent.c jni_vsl.c jni_libvlc.c
 LOCAL_SRC_FILES += pipe2.c
 LOCAL_SRC_FILES += wchar/wcpcpy.c
 LOCAL_SRC_FILES += wchar/wcpncpy.c
diff --git a/vlc-android/jni/jni_bundle.c b/vlc-android/jni/jni_bundle.c
new file mode 100644
index 0000000..3722cea
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.c
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * jni_bundle.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdbool.h>
+
+#define LOG_TAG "VLC/JNI/jni_bundle"
+#include "log.h"
+
+#include "jni_bundle.h"
+
+static jclass g_cls_bundle;
+
+static jclass jbundle_get_class(JNIEnv *env)
+{
+    if (!g_cls_bundle) {
+        jclass cls_bundle = (*env)->FindClass(env, "android/os/Bundle");
+        g_cls_bundle = (*env)->NewGlobalRef(env, cls_bundle);
+        (*env)->DeleteLocalRef(env, cls_bundle);
+    }
+
+    return g_cls_bundle;
+}
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    jclass cls_bundle = jbundle_get_class(env);
+    jmethodID clsCtor = (*env)->GetMethodID(env, cls_bundle, "<init>",
+            "()V");
+
+    p_bundle->bundle = (*env)->NewObject(env, cls_bundle, clsCtor);
+    p_bundle->needReleaseBundle = true;
+    return p_bundle;
+}
+
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    p_bundle->bundle = jbundle;
+    p_bundle->needReleaseBundle = false;
+    return p_bundle;
+}
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle) {
+    if (p_bundle->needReleaseBundle && p_bundle->bundle != NULL) {
+        (*env)->DeleteLocalRef(env, p_bundle->bundle);
+    }
+
+    memset(p_bundle, 0, sizeof(JavaBundle));
+}
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value) {
+    if (p_bundle->putInt == NULL) {
+        p_bundle->putInt = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "putInt", "(Ljava/lang/String;I)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putInt, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value) {
+    if (p_bundle->getInt == NULL) {
+        p_bundle->getInt = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "getInt", "(Ljava/lang/String;I)I");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jint ret = (*env)->CallIntMethod(env, p_bundle->bundle, p_bundle->getInt,
+            j_key, default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value) {
+    if (p_bundle->getLong == NULL) {
+        p_bundle->getLong = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "getLong", "(Ljava/lang/String;J)J");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jlong ret = (*env)->CallLongMethod(env, p_bundle->bundle, p_bundle->getLong,
+            j_key, (jlong) default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value) {
+    if (p_bundle->putFloat == NULL) {
+        p_bundle->putFloat = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "putFloat", "(Ljava/lang/String;F)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putFloat, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value) {
+    if (p_bundle->putString == NULL) {
+        p_bundle->putString = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "putString", "(Ljava/lang/String;Ljava/lang/String;)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jstring j_value = (*env)->NewStringUTF(env, value ? value : "");
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putString, j_key,
+            j_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    (*env)->DeleteLocalRef(env, j_value);
+}
+
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key) {
+    if (p_bundle->getString == NULL) {
+        p_bundle->getString = (*env)->GetMethodID(env, jbundle_get_class(env),
+                "getString", "(Ljava/lang/String;)Ljava/lang/String;");
+    }
+
+    char *ret = NULL;
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jobject j_value = (*env)->CallObjectMethod(env, p_bundle->bundle,
+            p_bundle->getString, j_key);
+    (*env)->DeleteLocalRef(env, j_key);
+    if (j_value) {
+        char *utf_chars = (char *) (*env)->GetStringUTFChars(env, j_value,
+                NULL);
+        if (utf_chars) {
+            ret = strdup(utf_chars);
+            (*env)->ReleaseStringUTFChars(env, j_value, utf_chars);
+        }
+        (*env)->DeleteLocalRef(env, j_value);
+    }
+
+    return ret;
+}
diff --git a/vlc-android/jni/jni_bundle.h b/vlc-android/jni/jni_bundle.h
new file mode 100644
index 0000000..f32054c
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.h
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * jni_bundle.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_BUNDLE_H
+#define JNI_BUNDLE_H
+
+#include "jni_libvlc.h"
+
+typedef struct {
+    jobject bundle;
+    bool needReleaseBundle;
+
+    jmethodID putInt;
+    jmethodID getInt;
+    jmethodID getLong;
+    jmethodID putFloat;
+    jmethodID putString;
+    jmethodID getString;
+} JavaBundle;
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle);
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle);
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle);
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value);
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value);
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value);
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value);
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value);
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key);
+
+#endif//JNI_BUNDLE_H
diff --git a/vlc-android/jni/jni_libvlc.c b/vlc-android/jni/jni_libvlc.c
new file mode 100644
index 0000000..a5cf11c
--- /dev/null
+++ b/vlc-android/jni/jni_libvlc.c
@@ -0,0 +1,72 @@
+/*****************************************************************************
+ * jni_libvlc.c
+ *****************************************************************************
+ * Copyright (C) 2012~2014 Zhang Rui
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "jni_libvlc.h"
+
+#define LOG_TAG "VLC/JNI/jni"
+#include "log.h"
+
+#include <pthread.h>
+
+extern JavaVM *myVm;
+
+static pthread_key_t g_thread_key;
+static pthread_once_t g_key_once = PTHREAD_ONCE_INIT;
+
+static void SDL_AndroidJni_ThreadDestroyed(void* value)
+{
+    JNIEnv *env = (JNIEnv*) value;
+    if (env != NULL) {
+        (*myVm)->DetachCurrentThread(myVm);
+        pthread_setspecific(g_thread_key, NULL);
+    }
+}
+
+static void make_thread_key()
+{
+    pthread_key_create(&g_thread_key, SDL_AndroidJni_ThreadDestroyed);
+}
+
+jint SDL_AndroidJni_SetupThreadEnv(JNIEnv **p_env, void *thr_args)
+{
+    JavaVM *jvm = myVm;
+    if (!jvm) {
+        LOGE("SDL_AndroidJni_GetJvm: AttachCurrentThread: NULL jvm");
+        return -1;
+    }
+
+    pthread_once(&g_key_once, make_thread_key);
+
+    JNIEnv *env = (JNIEnv*) pthread_getspecific(g_thread_key);
+    if (env) {
+        *p_env = env;
+        return 0;
+    }
+
+    if ((*jvm)->AttachCurrentThread(jvm, &env, thr_args) == JNI_OK) {
+        pthread_setspecific(g_thread_key, env);
+        *p_env = env;
+        return 0;
+    }
+
+    return -1;
+}
diff --git a/vlc-android/jni/jni_libvlc.h b/vlc-android/jni/jni_libvlc.h
new file mode 100644
index 0000000..f33abf0
--- /dev/null
+++ b/vlc-android/jni/jni_libvlc.h
@@ -0,0 +1,38 @@
+/*****************************************************************************
+ * jni_libvlc.h
+ *****************************************************************************
+ * Copyright (C) 2012~2014 Zhang Rui
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLC_H
+#define JNI_LIBVLC_H
+
+#include <stdint.h>
+#include <string.h>
+#include <jni.h>
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+extern jint SDL_AndroidJni_SetupThreadEnv(JNIEnv **p_env, void *thr_args);
+
+#endif//JNI_LIBVLC_H
diff --git a/vlc-android/jni/jni_libvlcevent.c b/vlc-android/jni/jni_libvlcevent.c
new file mode 100644
index 0000000..9dc5ecd
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.c
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * jni_libvlcevent.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "jni_libvlcevent.h"
+
+#define BUNDLE_MediaPlayerBuffering_NEW_CACHE "new_cache"
+#define BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE "new_seekable"
+#define BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE "new_pausable"
+#define BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL "new_cache_total"
+
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoder "video_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl "video_decoder_impl"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoder "audio_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl "audio_decoder_impl"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle) {
+    if (NULL == jbundle_init(env, p_bundle))
+        return NULL;
+
+    switch (ev->type) {
+    case libvlc_MediaPlayerBuffering: {
+        float new_cache = ev->u.media_player_buffering.new_cache;
+        jbundle_put_float(env, p_bundle, BUNDLE_MediaPlayerBuffering_NEW_CACHE,
+                new_cache);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int new_seekable = ev->u.media_player_seekable_changed.new_seekable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE, new_seekable);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int new_pausable = ev->u.media_player_pausable_changed.new_pausable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE, new_pausable);
+        break;
+    }
+    case libvlc_MediaPlayerBufferingTotal: {
+        float new_cache_total =
+                ev->u.media_player_buffering_total.new_cache_total;
+        jbundle_put_float(env, p_bundle,
+                BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL,
+                new_cache_total);
+        break;
+    }
+    case libvlc_MediaPlayerModuleChanged: {
+        const char* video_decoder =
+                ev->u.media_player_module_changed.psz_video_decoder;
+        const char* video_decoder_impl =
+                ev->u.media_player_module_changed.psz_video_decoder_impl;
+        const char* audio_decoder =
+                ev->u.media_player_module_changed.psz_audio_decoder;
+        const char* audio_decoder_impl =
+                ev->u.media_player_module_changed.psz_audio_decoder_impl;
+
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoder, video_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl,
+                video_decoder_impl);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoder, audio_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl,
+                audio_decoder_impl);
+        break;
+    }
+    }
+
+    return p_bundle;
+}
diff --git a/vlc-android/jni/jni_libvlcevent.h b/vlc-android/jni/jni_libvlcevent.h
new file mode 100644
index 0000000..92e39f2
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.h
@@ -0,0 +1,32 @@
+/*****************************************************************************
+ * jni_libvlcevent.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLCEVENT_H
+#define JNI_LIBVLCEVENT_H
+
+#include <vlc/vlc.h>
+#include "jni_bundle.h"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle);
+
+#endif//JNI_LIBVLCEVENT_H
diff --git a/vlc-android/jni/jni_vsl.c b/vlc-android/jni/jni_vsl.c
new file mode 100644
index 0000000..d7b510e
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.c
@@ -0,0 +1,300 @@
+/*****************************************************************************
+ * jni_vsl.c: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <jni.h>
+
+#include <vlc/vlc.h>
+
+#include "jni_vsl.h"
+#include "jni_bundle.h"
+
+#define LOG_TAG "VLC/JNI/vsl"
+#include "log.h"
+
+/** Unique Java VM instance, as defined in libvlcjni.c */
+extern JavaVM *myVm;
+
+#define BUNDLE_KEY_BUF_SIZE 64
+#define BUNDLE_COUNT "count"
+
+#define BUNDLE_MRL "segment_mrl"
+#define BUNDLE_URL "segment_url"
+#define BUNDLE_DURATION "duration"
+#define BUNDLE_BYTES "bytes"
+
+static JavaVMAttachArgs g_jvsl_thr_args = {JNI_VERSION_1_2, "vsl-thread", NULL};
+
+static jobject do_get_bundle(JNIEnv* env, jobject gui)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return NULL;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslGetBundle",
+            "()Landroid/os/Bundle;");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslGetBundle");
+        return NULL;
+    }
+
+    jobject jbundle = (*env)->CallObjectMethod(env, gui, methodID);
+    return jbundle;
+}
+
+/* */
+static int do_load(JNIEnv* env, jobject gui, bool b_force_reload)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return -1;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslLoad", "(Z)Z");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslLoad");
+        return -1;
+    }
+
+    jboolean jsuccess = (*env)->CallBooleanMethod(env, gui, methodID,
+            b_force_reload);
+    return jsuccess ? 0 : -1;
+}
+
+int jvsl_load(void *p_cb_data, bool b_force_reload)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_load(env, p_cb_data, b_force_reload);
+    return ret;
+}
+
+/* */
+static int do_load_segment(JNIEnv* env, jobject gui, bool b_force_reload, int segment)
+{
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return -1;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslLoadSegment", "(ZI)Z");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslLoad");
+        return -1;
+    }
+
+    jboolean jsuccess = (*env)->CallBooleanMethod(env, gui, methodID,
+                                                  b_force_reload, segment);
+    return jsuccess ? 0 : -1;
+}
+
+int jvsl_load_segment(void *p_cb_data, bool b_force_reload, int segment)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_load_segment(env, p_cb_data, b_force_reload, segment);
+    return ret;
+}
+
+/* */
+static int do_get_count(JNIEnv* env, jobject gui)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    int ret = jbundle_get_int(env, &javaBundle, BUNDLE_COUNT, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_count(void *p_cb_data)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_count(env, p_cb_data);
+    return ret;
+}
+
+/* */
+static char *do_get_mrl(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_MRL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_mrl: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_mrl(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_mrl(env, p_cb_data, order);
+    return ret;
+}
+
+/* */
+static char *do_get_url(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_URL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_url: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_url(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_url(env, p_cb_data, order);
+    return ret;
+}
+
+/* */
+static int do_get_duratuon(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_DURATION);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_duratuon: %s", szBuf);
+    int ret = jbundle_get_int(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_duration(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_duratuon(env, p_cb_data, order);
+    return ret;
+}
+
+/* */
+static int64_t do_get_bytes(JNIEnv* env, jobject gui, int order)
+{
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_BYTES);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_bytes: %s", szBuf);
+    int64_t ret = jbundle_get_long(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int64_t jvsl_get_bytes(void *p_cb_data, int order)
+{
+    JNIEnv *env = NULL;
+    if (SDL_AndroidJni_SetupThreadEnv(&env, &g_jvsl_thr_args) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int64_t ret = do_get_bytes(env, p_cb_data, order);
+    return ret;
+}
diff --git a/vlc-android/jni/jni_vsl.h b/vlc-android/jni/jni_vsl.h
new file mode 100644
index 0000000..527277a
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.h
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * jni_vsl.h: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_VSL_H
+#define JNI_VSL_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+int     jvsl_load(void *p_cb_data, bool b_force_reload);
+int     jvsl_load_segment(void *p_cb_data, bool b_force_reload, int segment);
+int     jvsl_get_count(void *p_cb_data);
+char   *jvsl_get_mrl(void *p_cb_data, int i_order);
+char   *jvsl_get_url(void *p_cb_data, int i_order);
+int     jvsl_get_duration(void *p_cb_data, int i_order);
+int64_t jvsl_get_bytes(void *p_cb_data, int i_order);
+
+#endif // JNI_VSL_H
diff --git a/vlc-android/jni/libvlcjni-util.c b/vlc-android/jni/libvlcjni-util.c
index 37f4d2d..0c4da3c 100644
--- a/vlc-android/jni/libvlcjni-util.c
+++ b/vlc-android/jni/libvlcjni-util.c
@@ -43,7 +43,9 @@ jint getInt(JNIEnv *env, jobject thiz, const char* field) {
     jclass clazz = (*env)->GetObjectClass(env, thiz);
     jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
                                           field, "I");
-    return (*env)->GetIntField(env, thiz, fieldMP);
+    jint ret = (*env)->GetIntField(env, thiz, fieldMP);
+    (*env)->DeleteLocalRef(env, clazz);
+    return ret;
 }
 void setInt(JNIEnv *env, jobject item, const char* field, jint value) {
     jclass cls;
@@ -58,13 +60,16 @@ void setInt(JNIEnv *env, jobject item, const char* field, jint value) {
         return;
 
     (*env)->SetIntField(env, item, fieldId, value);
+    (*env)->DeleteLocalRef(env, cls);
 }
 
 jlong getLong(JNIEnv *env, jobject thiz, const char* field) {
     jclass clazz = (*env)->GetObjectClass(env, thiz);
     jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
                                           field, "J");
-    return (*env)->GetLongField(env, thiz, fieldMP);
+    jlong ret = (*env)->GetLongField(env, thiz, fieldMP);
+    (*env)->DeleteLocalRef(env, clazz);
+    return ret;
 }
 void setLong(JNIEnv *env, jobject item, const char* field, jlong value) {
     jclass cls;
@@ -79,6 +84,7 @@ void setLong(JNIEnv *env, jobject item, const char* field, jlong value) {
         return;
 
     (*env)->SetLongField(env, item, fieldId, value);
+    (*env)->DeleteLocalRef(env, cls);
 }
 
 void setFloat(JNIEnv *env, jobject item, const char* field, jfloat value) {
@@ -94,6 +100,7 @@ void setFloat(JNIEnv *env, jobject item, const char* field, jfloat value) {
         return;
 
     (*env)->SetFloatField(env, item, fieldId, value);
+    (*env)->DeleteLocalRef(env, cls);
 }
 void setString(JNIEnv *env, jobject item, const char* field, const char* text) {
     jclass cls;
@@ -113,6 +120,7 @@ void setString(JNIEnv *env, jobject item, const char* field, const char* text) {
     if (jstr == NULL)
         return;
     (*env)->SetObjectField(env, item, fieldId, jstr);
+    (*env)->DeleteLocalRef(env, cls);
 }
 
 void arrayListGetIDs(JNIEnv *env, jclass* p_class, jmethodID* p_add, jmethodID* p_remove) {
@@ -140,10 +148,13 @@ jobject getEventHandlerReference(JNIEnv *env, jobject thiz, jobject eventHandler
     jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
     if (!methodID) {
         LOGE("setEventHandler: failed to get the callback method");
+        (*env)->DeleteLocalRef(env, cls);
         return NULL;
     }
 
-    return (*env)->NewGlobalRef(env, eventHandler);
+    jobject ref = (*env)->NewGlobalRef(env, eventHandler);
+    (*env)->DeleteLocalRef(env, cls);
+    return ref;
 }
 
 static void debug_buffer_log(void *data, int level, const char *fmt, va_list ap)
diff --git a/vlc-android/jni/libvlcjni_danmaku.c b/vlc-android/jni/libvlcjni_danmaku.c
new file mode 100644
index 0000000..ae3cca0
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku.c
@@ -0,0 +1,567 @@
+/*****************************************************************************
+ * libvlcjni.c
+ *****************************************************************************
+ * Copyright © 2010-2013 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <vlc/vlc.h>
+#include <vlc_common.h>
+#include <vlc_url.h>
+
+#include <jni.h>
+
+#include <android/api-level.h>
+
+#include "../../vlc/contrib/android/ffmpeg/libavutil/avstring.h"
+#include "../../vlc/contrib/android/ffmpeg/libavutil/log.h"
+
+#include "libvlcjni.h"
+#include "aout.h"
+#include "vout.h"
+#include "utils.h"
+
+#define VOUT_ANDROID_SURFACE 0
+#define VOUT_OPENGLES2       1
+
+#define HW_ACCELERATION_DISABLED 0
+#define HW_ACCELERATION_DECODING 1
+#define HW_ACCELERATION_FULL     2
+
+#define LOG_TAG "VLC/JNI/main"
+#include "log.h"
+
+#include "jni_libvlc.h"
+#include "jni_bundle.h"
+#include "jni_libvlcevent.h"
+#include "jni_vsl.h"
+#include "libvlcjni_danmaku_events.inc.c"
+
+#define AOUT_AUDIOTRACK_JAVA 0
+#define AOUT_AUDIOTRACK      1
+#define AOUT_OPENSLES        2
+
+#if 0
+libvlc_media_t *new_media(jlong instance, JNIEnv *env, jobject thiz, jstring fileLocation, bool noOmx, bool noVideo)
+{
+    libvlc_instance_t *libvlc = (libvlc_instance_t*)(intptr_t)instance;
+    jboolean isCopy;
+    const char *psz_location = (*env)->GetStringUTFChars(env, fileLocation, &isCopy);
+    libvlc_media_t *p_md = libvlc_media_new_location(libvlc, psz_location);
+    (*env)->ReleaseStringUTFChars(env, fileLocation, psz_location);
+    if (!p_md)
+        return NULL;
+
+    if (!noOmx) {
+        jclass cls = (*env)->GetObjectClass(env, thiz);
+        jmethodID methodId = (*env)->GetMethodID(env, cls, "getHardwareAcceleration", "()I");
+        int hardwareAcceleration = (*env)->CallIntMethod(env, thiz, methodId);
+        if (hardwareAcceleration == HW_ACCELERATION_DECODING || hardwareAcceleration == HW_ACCELERATION_FULL) {
+            /*
+             * Set higher caching values if using iomx decoding, since some omx
+             * decoders have a very high latency, and if the preroll data isn't
+             * enough to make the decoder output a frame, the playback timing gets
+             * started too soon, and every decoded frame appears to be too late.
+             * On Nexus One, the decoder latency seems to be 25 input packets
+             * for 320x170 H.264, a few packets less on higher resolutions.
+             * On Nexus S, the decoder latency seems to be about 7 packets.
+             */
+            libvlc_media_add_option(p_md, ":file-caching=1500");
+            libvlc_media_add_option(p_md, ":network-caching=1500");
+            libvlc_media_add_option(p_md, ":codec=mediacodec,iomx,all");
+        }
+        if (noVideo)
+            libvlc_media_add_option(p_md, ":no-video");
+    }
+    return p_md;
+}
+#endif
+
+libvlc_media_player_t *getMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_player_t*)(intptr_t)getLong(env, thiz, "mInternalMediaPlayerInstance");
+}
+
+static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t* p_mp = getMediaPlayer(env, thiz);
+    if (p_mp)
+    {
+        libvlc_media_player_stop(p_mp);
+        libvlc_media_player_release(p_mp);
+        setLong(env, thiz, "mInternalMediaPlayerInstance", 0);
+    }
+}
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+JavaVM *myVm;
+
+static jobject eventHandlerInstance = NULL;
+
+/** vout lock declared in vout.c */
+extern pthread_mutex_t vout_android_lock;
+
+#include "libvlcjni_danmaku_events.inc.c"
+static void vlc_event_callback(const libvlc_event_t *ev, void *data)
+{
+    JNIEnv *env;
+
+    bool isAttached = false;
+
+    if (eventHandlerInstance == NULL)
+        return;
+
+    if ((*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2) < 0) {
+        if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) < 0)
+            return;
+        isAttached = true;
+    }
+
+    JavaBundle javaBundle;
+    memset(&javaBundle, 0, sizeof(javaBundle));
+    if (NULL == jbundle_from_event(env, ev, &javaBundle)) {
+        LOGE("EventHandler: failed to crate bundle");
+        return;
+    }
+
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, eventHandlerInstance);
+    if (!cls) {
+        LOGE("EventHandler: failed to get class reference");
+        goto end;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
+    if (methodID) {
+        (*env)->CallVoidMethod(env, eventHandlerInstance, methodID, ev->type, javaBundle.bundle);
+    } else {
+        LOGE("EventHandler: failed to get the callback method");
+    }
+
+    (*env)->DeleteLocalRef(env, cls);
+end:
+    jbundle_destroy(env, &javaBundle);
+
+    if (isAttached)
+        (*myVm)->DetachCurrentThread(myVm);
+}
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved)
+{
+    // Keep a reference on the Java VM.
+    myVm = vm;
+
+    pthread_mutex_init(&vout_android_lock, NULL);
+    pthread_cond_init(&vout_android_surf_attached, NULL);
+
+    LOGD("JNI interface loaded.");
+    return JNI_VERSION_1_2;
+}
+
+void JNI_OnUnload(JavaVM* vm, void* reserved) {
+    pthread_mutex_destroy(&vout_android_lock);
+    pthread_cond_destroy(&vout_android_surf_attached);
+}
+
+// FIXME: use atomics
+static bool verbosity;
+
+#include "libvlcjni_fflog.inc.c"
+
+void Java_org_videolan_libvlc_LibVLC_changeVerbosity(JNIEnv *env, jobject thiz, jboolean verbose)
+{
+    verbosity = verbose;
+}
+
+#include "libvlcjni_danmaku_nativeInitEx.inc.c"
+#if 0
+void Java_org_videolan_libvlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz)
+{
+    //only use OpenSLES if java side says we can
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    bool use_opensles = (*env)->CallIntMethod(env, thiz, methodId) == AOUT_OPENSLES;
+
+    methodId = (*env)->GetMethodID(env, cls, "getVout", "()I");
+    bool use_opengles2 = (*env)->CallIntMethod(env, thiz, methodId) == VOUT_OPENGLES2;
+
+    methodId = (*env)->GetMethodID(env, cls, "timeStretchingEnabled", "()Z");
+    bool enable_time_stretch = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "frameSkipEnabled", "()Z");
+    bool enable_frame_skip = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "getDeblocking", "()I");
+    int deblocking = (*env)->CallIntMethod(env, thiz, methodId);
+    char deblockstr[2] = "3";
+    snprintf(deblockstr, 2, "%d", deblocking);
+    LOGD("Using deblocking level %d", deblocking);
+
+    methodId = (*env)->GetMethodID(env, cls, "getNetworkCaching", "()I");
+    int networkCaching = (*env)->CallIntMethod(env, thiz, methodId);
+    char networkCachingstr[25] = "0";
+    if(networkCaching > 0) {
+        snprintf(networkCachingstr, 25, "--network-caching=%d", networkCaching);
+        LOGD("Using network caching of %d ms", networkCaching);
+    }
+
+    methodId = (*env)->GetMethodID(env, cls, "getChroma", "()Ljava/lang/String;");
+    jstring chroma = (*env)->CallObjectMethod(env, thiz, methodId);
+    const char *chromastr = (*env)->GetStringUTFChars(env, chroma, 0);
+    LOGD("Chroma set to \"%s\"", chromastr);
+
+    methodId = (*env)->GetMethodID(env, cls, "getSubtitlesEncoding", "()Ljava/lang/String;");
+    jstring subsencoding = (*env)->CallObjectMethod(env, thiz, methodId);
+    const char *subsencodingstr = (*env)->GetStringUTFChars(env, subsencoding, 0);
+    LOGD("Subtitle encoding set to \"%s\"", subsencodingstr);
+
+    methodId = (*env)->GetMethodID(env, cls, "isVerboseMode", "()Z");
+    verbosity = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    methodId = (*env)->GetMethodID(env, cls, "getHardwareAcceleration", "()I");
+    int hardwareAcceleration = (*env)->CallIntMethod(env, thiz, methodId);
+    /* With the MediaCodec opaque mode we cannot use the OpenGL ES vout. */
+    if (hardwareAcceleration == HW_ACCELERATION_FULL)
+        use_opengles2 = false;
+
+    /* Don't add any invalid options, otherwise it causes LibVLC to crash */
+    const char *argv[] = {
+        "-I", "dummy",
+        "--no-osd",
+        "--no-video-title-show",
+        "--no-stats",
+        "--no-plugins-cache",
+        "--no-drop-late-frames",
+        /* The VLC default is to pick the highest resolution possible
+         * (i.e. 1080p). For mobile, pick a more sane default for slow
+         * mobile data networks and slower hardware. */
+        "--preferred-resolution", "360",
+        "--avcodec-fast",
+        "--avcodec-threads=0",
+        "--subsdec-encoding", subsencodingstr,
+        enable_time_stretch ? "--audio-time-stretch" : "--no-audio-time-stretch",
+        "--avcodec-skiploopfilter", deblockstr,
+        "--avcodec-skip-frame", enable_frame_skip ? "2" : "0",
+        "--avcodec-skip-idct", enable_frame_skip ? "2" : "0",
+        (networkCaching > 0) ? networkCachingstr : "",
+        use_opensles ? "--aout=opensles" : "--aout=android_audiotrack",
+        use_opengles2 ? "--vout=gles2" : "--vout=androidsurface",
+        "--androidsurface-chroma", chromastr != NULL && chromastr[0] != 0 ? chromastr : "RV32",
+        (hardwareAcceleration == HW_ACCELERATION_FULL) ? "" : "--no-mediacodec-dr",
+    };
+    libvlc_instance_t *instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    (*env)->ReleaseStringUTFChars(env, chroma, chromastr);
+    (*env)->ReleaseStringUTFChars(env, subsencoding, subsencodingstr);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/libvlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+
+    libvlc_log_set(instance, debug_log, &verbosity);
+}
+#endif
+
+void Java_org_videolan_libvlc_LibVLC_nativeDestroy(JNIEnv *env, jobject thiz)
+{
+    releaseMediaPlayer(env, thiz);
+    jlong libVlcInstance = getLong(env, thiz, "mLibVlcInstance");
+    if (!libVlcInstance)
+        return; // Already destroyed
+
+    libvlc_instance_t *instance = (libvlc_instance_t*)(intptr_t) libVlcInstance;
+    libvlc_log_unset(instance);
+    libvlc_release(instance);
+
+    setLong(env, thiz, "mLibVlcInstance", 0);
+}
+
+void Java_org_videolan_libvlc_LibVLC_detachEventHandler(JNIEnv *env, jobject thiz)
+{
+    if (eventHandlerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventHandlerInstance);
+        eventHandlerInstance = NULL;
+    }
+}
+
+void Java_org_videolan_libvlc_LibVLC_setEventHandler(JNIEnv *env, jobject thiz, jobject eventHandler)
+{
+    if (eventHandlerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventHandlerInstance);
+        eventHandlerInstance = NULL;
+    }
+
+    eventHandlerInstance = getEventHandlerReference(env, thiz, eventHandler);
+}
+
+void Java_org_videolan_libvlc_LibVLC_playMRL(JNIEnv *env, jobject thiz, jlong instance,
+                                             jstring mrl, jobjectArray mediaOptions)
+{
+    /* Release previous media player, if any */
+    releaseMediaPlayer(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_player_t *mp = libvlc_media_player_new((libvlc_instance_t*)(intptr_t)instance);
+    jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
+
+#if 0
+    //if AOUT_AUDIOTRACK_JAVA, we use amem
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    if ( (*env)->CallIntMethod(env, thiz, methodId) == AOUT_AUDIOTRACK_JAVA )
+    {
+        libvlc_audio_set_callbacks(mp, aout_play, aout_pause, NULL, NULL, NULL,
+                                   (void*) myJavaLibVLC);
+        libvlc_audio_set_format_callbacks(mp, aout_open, aout_close);
+    }
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaPlayerPlaying,
+        libvlc_MediaPlayerPaused,
+        libvlc_MediaPlayerEndReached,
+        libvlc_MediaPlayerStopped,
+        libvlc_MediaPlayerVout,
+        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerEncounteredError
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+#endif
+
+
+    /* Keep a pointer to this media player */
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)(intptr_t)mp);
+
+#if 0
+    cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "applyEqualizer", "()V");
+    (*env)->CallVoidMethod(env, thiz, methodID);
+#endif
+
+    const char* p_mrl = (*env)->GetStringUTFChars(env, mrl, 0);
+
+    libvlc_media_t* p_md = libvlc_media_new_location((libvlc_instance_t*)(intptr_t)instance, p_mrl);
+    /* media options */
+    if (mediaOptions != NULL)
+    {
+        int stringCount = (*env)->GetArrayLength(env, mediaOptions);
+        for(int i = 0; i < stringCount; i++)
+        {
+            jstring option = (jstring)(*env)->GetObjectArrayElement(env, mediaOptions, i);
+            const char* p_st = (*env)->GetStringUTFChars(env, option, 0);
+            LOGD("  %s", p_st);
+            if (!strncmp(p_st, ":aout=", 6)) {
+                // seems ":aout" does not effect libvlc_media_add_option()
+                const char* aout_name = p_st + 6;
+                if (!strncmp(aout_name, "audiotrack_java", 15)) {
+                    LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                    libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL,
+                                               NULL, NULL, (void*) myJavaLibVLC);
+                    libvlc_audio_set_format_callbacks(mp, aout_open,
+                                                      aout_close);
+                } else {
+                    LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                    libvlc_audio_output_set(mp, aout_name);
+                }
+            } else {
+                libvlc_media_add_option(p_md, p_st); // option
+            }
+            (*env)->ReleaseStringUTFChars(env, option, p_st);
+        }
+    }
+
+    (*env)->ReleaseStringUTFChars(env, mrl, p_mrl);
+
+    // FIXME: do not use get_vout_android_gui() for java_mp
+    libvlc_media_player_set_vsl_callback(mp, get_vout_android_gui(), //
+                                         jvsl_load, //
+                                         jvsl_load_segment, //
+                                         jvsl_get_count, //
+                                         jvsl_get_mrl, //
+                                         jvsl_get_url, //
+                                         jvsl_get_duration, //
+                                         jvsl_get_bytes);
+
+    libvlc_media_player_set_media(mp, p_md);
+    /* No need to keep the media now */
+    libvlc_media_release(p_md);
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    for (int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    p_md = libvlc_media_player_get_media(mp);
+    if (p_md) {
+        ev = libvlc_media_event_manager(p_md);
+        for (int i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
+        }
+    }
+
+    libvlc_media_player_play(mp);
+}
+
+#if 0
+jfloat Java_org_videolan_libvlc_LibVLC_getRate(JNIEnv *env, jobject thiz) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        return libvlc_media_player_get_rate(mp);
+    else
+        return 1.00;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setRate(JNIEnv *env, jobject thiz, jfloat rate) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        libvlc_media_player_set_rate(mp, rate);
+}
+#endif
+
+jboolean Java_org_videolan_libvlc_LibVLC_hasMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return !!getMediaPlayer(env, thiz);
+}
+
+jboolean Java_org_videolan_libvlc_LibVLC_isPlaying(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_playing(mp);
+    else
+        return 0;
+}
+
+jboolean Java_org_videolan_libvlc_LibVLC_isSeekable(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_seekable(mp);
+    return 0;
+}
+
+void Java_org_videolan_libvlc_LibVLC_play(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_play(mp);
+}
+
+void Java_org_videolan_libvlc_LibVLC_pause(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_pause(mp);
+}
+
+void Java_org_videolan_libvlc_LibVLC_stop(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_stop(mp);
+}
+
+#if 0
+jint Java_org_videolan_libvlc_LibVLC_getVolume(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_audio_get_volume(mp);
+    return -1;
+}
+
+jint Java_org_videolan_libvlc_LibVLC_setVolume(JNIEnv *env, jobject thiz, jint volume)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        //Returns 0 if the volume was set, -1 if it was out of range or error
+        return (jint) libvlc_audio_set_volume(mp, (int) volume);
+    return -1;
+}
+#endif
+
+jlong Java_org_videolan_libvlc_LibVLC_getTime(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_media_player_get_time(mp);
+    return -1;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setTime(JNIEnv *env, jobject thiz, jlong time)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_time(mp, time);
+}
+
+jfloat Java_org_videolan_libvlc_LibVLC_getPosition(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jfloat) libvlc_media_player_get_position(mp);
+    return -1;
+}
+
+void Java_org_videolan_libvlc_LibVLC_setPosition(JNIEnv *env, jobject thiz, jfloat pos)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_position(mp, pos);
+}
+
+jlong Java_org_videolan_libvlc_LibVLC_getLength(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jlong) libvlc_media_player_get_length(mp);
+    return -1;
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_version(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_version());
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_compiler(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_compiler());
+}
+
+jstring Java_org_videolan_libvlc_LibVLC_changeset(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_changeset());
+}
diff --git a/vlc-android/jni/libvlcjni_danmaku_events.inc.c b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
new file mode 100644
index 0000000..7b129ed
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
@@ -0,0 +1,65 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_events.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+#define LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+static const libvlc_event_type_t md_events[] = {
+//        libvlc_MediaMetaChanged,
+//        libvlc_MediaSubItemAdded,
+        libvlc_MediaDurationChanged, //
+        libvlc_MediaParsedChanged, //
+//        libvlc_MediaFreed,
+        libvlc_MediaStateChanged, //
+        };
+
+static const libvlc_event_type_t mp_events[] = {
+//        libvlc_MediaPlayerMediaChanged,
+//        libvlc_MediaPlayerNothingSpecial,
+        libvlc_MediaPlayerOpening, //
+        libvlc_MediaPlayerBuffering, //
+        libvlc_MediaPlayerPlaying, //
+        libvlc_MediaPlayerPaused, //
+        libvlc_MediaPlayerStopped, //
+//        libvlc_MediaPlayerForward,
+//        libvlc_MediaPlayerBackward,
+        libvlc_MediaPlayerEndReached, //
+        libvlc_MediaPlayerEncounteredError, //
+//        libvlc_MediaPlayerTimeChanged,
+//        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerSeekableChanged, //
+        libvlc_MediaPlayerPausableChanged, //
+//        libvlc_MediaPlayerTitleChanged,
+//        libvlc_MediaPlayerSnapshotTaken,
+        libvlc_MediaPlayerLengthChanged, //
+//        libvlc_MediaPlayerVout,
+        libvlc_MediaPlayerBufferingTotal, //
+        libvlc_MediaPlayerModuleChanged, //
+        };
+
+#endif//LIBVLCJNI_DANMAKU_INCLUDE_INC_C
diff --git a/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
new file mode 100644
index 0000000..ab052f3
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_nativeInitEx.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+#define LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+
+void Java_org_videolan_libvlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jboolean verbose, jarray arguments)
+{
+    libvlc_instance_t *instance = NULL;
+
+    int user_argc = (*env)->GetArrayLength(env, arguments);
+    char **user_argv = (char **) calloc(user_argc, sizeof(char *));
+    int i = 0;
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            user_argv[i] = (char *) (*env)->GetStringUTFChars(env, argument, NULL);
+    }
+    instance = libvlc_new(user_argc, (const char **) user_argv);
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            (*env)->ReleaseStringUTFChars(env, argument, user_argv[i]);
+    }
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/libvlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+
+    libvlc_log_set(instance, debug_log, &verbosity);
+    av_log_set_callback(ffmpeg_debug_log);
+}
+
+#endif//LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
diff --git a/vlc-android/jni/libvlcjni_fflog.inc.c b/vlc-android/jni/libvlcjni_fflog.inc.c
new file mode 100644
index 0000000..632c6f2
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_fflog.inc.c
@@ -0,0 +1,71 @@
+/*****************************************************************************
+ * libvlcjni_fflog.inc.c
+ *****************************************************************************
+ * Copyright © 2013 Zhang Rui <bbcallen@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+static void ffmpeg_debug_log(void* ptr, int level, const char* fmt, va_list vl)
+{
+    bool *verbose = &verbosity;
+
+    int prio = ANDROID_LOG_DEBUG;
+    if      (level <= AV_LOG_ERROR)     prio = ANDROID_LOG_ERROR;
+    else if (level <= AV_LOG_WARNING)   prio = ANDROID_LOG_WARN;
+    else if (level <= AV_LOG_INFO)      prio = ANDROID_LOG_INFO;
+    else if (level <= AV_LOG_VERBOSE)   prio = ANDROID_LOG_DEBUG;
+    else                                prio = ANDROID_LOG_DEBUG;
+
+    if (!*verbose)
+        return;
+
+    static int print_prefix = 1;
+    static int count;
+    static char prev[1024];
+    char line[1024];
+    static int is_atty;
+    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;
+    line[0] = 0;
+    if (print_prefix && avc) {
+        if (avc->parent_log_context_offset) {
+            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +
+                                               avc->parent_log_context_offset);
+            if (parent && *parent) {
+                snprintf(line, sizeof(line), "[%s @ %p] ",
+                         (*parent)->item_name(parent), parent);
+            }
+        }
+        snprintf(line + strlen(line), sizeof(line) - strlen(line), "[%s @ %p] ",
+                 avc->item_name(ptr), ptr);
+    }
+
+    vsnprintf(line + strlen(line), sizeof(line) - strlen(line), fmt, vl);
+
+    print_prefix = strlen(line) && line[strlen(line) - 1] == '\n';
+
+    if (print_prefix && !strncmp(line, prev, sizeof line)) {
+        count++;
+        if (is_atty == 1)
+            fprintf(stderr, "    Last message repeated %d times\r", count);
+        return;
+    }
+    if (count > 0) {
+        fprintf(stderr, "    Last message repeated %d times\n", count);
+        count = 0;
+    }
+    __android_log_write(prio, "VLC-FF", line);
+    av_strlcpy(prev, line, sizeof line);
+}
diff --git a/vlc-android/jni/utils.h b/vlc-android/jni/utils.h
index f8502d9..182099b 100644
--- a/vlc-android/jni/utils.h
+++ b/vlc-android/jni/utils.h
@@ -45,4 +45,6 @@ jobject getEventHandlerReference(JNIEnv *env, jobject thiz, jobject eventHandler
 
 void debug_log(void *data, int level, const libvlc_log_t *ctx, const char *fmt, va_list ap);
 
+void *get_vout_android_gui();
+
 #endif // LIBVLCJNI_UTILS_H
diff --git a/vlc-android/jni/vout.c b/vlc-android/jni/vout.c
index eea4d9e..3514374 100644
--- a/vlc-android/jni/vout.c
+++ b/vlc-android/jni/vout.c
@@ -33,6 +33,11 @@ static void *vout_android_gui = NULL;
 static jobject vout_android_java_surf = NULL;
 static jobject vout_android_subtitles_surf = NULL;
 
+// FIXME: this is VlcMediaPlayer
+extern void *get_vout_android_gui() {
+    return vout_android_gui;
+}
+
 void *jni_LockAndGetSubtitlesSurface() {
     pthread_mutex_lock(&vout_android_lock);
     while (vout_android_subtitles_surf == NULL)
@@ -42,15 +47,19 @@ void *jni_LockAndGetSubtitlesSurface() {
 
 void *jni_LockAndGetAndroidSurface() {
     pthread_mutex_lock(&vout_android_lock);
+#if 0
     while (vout_android_surf == NULL)
         pthread_cond_wait(&vout_android_surf_attached, &vout_android_lock);
+#endif
     return vout_android_surf;
 }
 
 jobject jni_LockAndGetAndroidJavaSurface() {
     pthread_mutex_lock(&vout_android_lock);
+#if 0
     while (vout_android_java_surf == NULL)
         pthread_cond_wait(&vout_android_surf_attached, &vout_android_lock);
+#endif
     return vout_android_java_surf;
 }
 
-- 
1.8.3.4

