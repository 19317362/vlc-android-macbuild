From b1e6e002fc64acb7368feb204ad44cfb37034d37 Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Sat, 13 Oct 2012 09:18:44 +0800
Subject: [PATCH 8/8] libvlcjni: another libvlc wrapper

---
 vlc-android/jni/Android.mk                         |    3 +-
 vlc-android/jni/jni_bundle.c                       |  150 +++
 vlc-android/jni/jni_bundle.h                       |   61 +
 vlc-android/jni/jni_libvlc.h                       |   36 +
 vlc-android/jni/jni_libvlcevent.c                  |   92 ++
 vlc-android/jni/jni_libvlcevent.h                  |   32 +
 vlc-android/jni/jni_vsl.c                          |  263 +++++
 vlc-android/jni/jni_vsl.h                          |   36 +
 vlc-android/jni/libvlcjni_danmaku.c                | 1174 ++++++++++++++++++++
 vlc-android/jni/libvlcjni_danmaku_events.inc.c     |   65 ++
 .../jni/libvlcjni_danmaku_nativeInitEx.inc.c       |   61 +
 .../jni/libvlcjni_danmaku_readMediaEx.inc.c        |  108 ++
 12 个文件被修改，插入 2080 行(+)，删除 1 行(-)
 create mode 100644 vlc-android/jni/jni_bundle.c
 create mode 100644 vlc-android/jni/jni_bundle.h
 create mode 100644 vlc-android/jni/jni_libvlc.h
 create mode 100644 vlc-android/jni/jni_libvlcevent.c
 create mode 100644 vlc-android/jni/jni_libvlcevent.h
 create mode 100644 vlc-android/jni/jni_vsl.c
 create mode 100644 vlc-android/jni/jni_vsl.h
 create mode 100644 vlc-android/jni/libvlcjni_danmaku.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_events.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c

diff --git a/vlc-android/jni/Android.mk b/vlc-android/jni/Android.mk
index 62e1418..37c313e 100644
--- a/vlc-android/jni/Android.mk
+++ b/vlc-android/jni/Android.mk
@@ -3,7 +3,8 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE    := libvlcjni
 
-LOCAL_SRC_FILES := libvlcjni.c aout.c thumbnailer.c pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c
+LOCAL_SRC_FILES := libvlcjni_danmaku.c aout.c pthread-condattr.c pthread-rwlocks.c pthread-once.c eventfd.c sem.c
+LOCAL_SRC_FILES += jni_bundle.c jni_libvlcevent.c jni_vsl.c
 LOCAL_SRC_FILES += pipe2.c
 LOCAL_SRC_FILES += wchar/wcpcpy.c
 LOCAL_SRC_FILES += wchar/wcpncpy.c
diff --git a/vlc-android/jni/jni_bundle.c b/vlc-android/jni/jni_bundle.c
new file mode 100644
index 0000000..a99751e
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.c
@@ -0,0 +1,150 @@
+/*****************************************************************************
+ * jni_bundle.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdbool.h>
+
+#define LOG_TAG "VLC/JNI/jni_bundle"
+#include "log.h"
+
+#include "jni_bundle.h"
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    p_bundle->clsBundle = (*env)->FindClass(env, "android/os/Bundle");
+    jmethodID clsCtor = (*env)->GetMethodID(env, p_bundle->clsBundle, "<init>",
+            "()V");
+
+    p_bundle->bundle = (*env)->NewObject(env, p_bundle->clsBundle, clsCtor);
+    p_bundle->needReleaseBundle = true;
+    return p_bundle;
+}
+
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle) {
+    memset(p_bundle, 0, sizeof(JavaBundle));
+
+    p_bundle->clsBundle = (*env)->FindClass(env, "android/os/Bundle");
+    p_bundle->bundle = jbundle;
+    p_bundle->needReleaseBundle = false;
+    return p_bundle;
+}
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle) {
+    if (p_bundle->needReleaseBundle && p_bundle->bundle != NULL) {
+        (*env)->DeleteLocalRef(env, p_bundle->bundle);
+    }
+
+    memset(p_bundle, 0, sizeof(JavaBundle));
+}
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value) {
+    if (p_bundle->putInt == NULL) {
+        p_bundle->putInt = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putInt", "(Ljava/lang/String;I)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putInt, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value) {
+    if (p_bundle->getInt == NULL) {
+        p_bundle->getInt = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getInt", "(Ljava/lang/String;I)I");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jint ret = (*env)->CallIntMethod(env, p_bundle->bundle, p_bundle->getInt,
+            j_key, default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value) {
+    if (p_bundle->getLong == NULL) {
+        p_bundle->getLong = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getLong", "(Ljava/lang/String;J)J");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jlong ret = (*env)->CallLongMethod(env, p_bundle->bundle, p_bundle->getLong,
+            j_key, (jlong) default_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    return ret;
+}
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value) {
+    if (p_bundle->putFloat == NULL) {
+        p_bundle->putFloat = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putFloat", "(Ljava/lang/String;F)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putFloat, j_key,
+            value);
+    (*env)->DeleteLocalRef(env, j_key);
+}
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value) {
+    if (p_bundle->putString == NULL) {
+        p_bundle->putString = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "putString", "(Ljava/lang/String;Ljava/lang/String;)V");
+    }
+
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jstring j_value = (*env)->NewStringUTF(env, value ? value : "");
+    (*env)->CallVoidMethod(env, p_bundle->bundle, p_bundle->putString, j_key,
+            j_value);
+    (*env)->DeleteLocalRef(env, j_key);
+    (*env)->DeleteLocalRef(env, j_value);
+}
+
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key) {
+    if (p_bundle->getString == NULL) {
+        p_bundle->getString = (*env)->GetMethodID(env, p_bundle->clsBundle,
+                "getString", "(Ljava/lang/String;)Ljava/lang/String;");
+    }
+
+    char *ret = NULL;
+    jstring j_key = (*env)->NewStringUTF(env, key);
+    jobject j_value = (*env)->CallObjectMethod(env, p_bundle->bundle,
+            p_bundle->getString, j_key);
+    (*env)->DeleteLocalRef(env, j_key);
+    if (j_value) {
+        char *utf_chars = (char *) (*env)->GetStringUTFChars(env, j_value,
+                NULL);
+        if (utf_chars) {
+            ret = strdup(utf_chars);
+            (*env)->ReleaseStringUTFChars(env, j_value, utf_chars);
+        }
+        (*env)->DeleteLocalRef(env, j_value);
+    }
+
+    return ret;
+}
diff --git a/vlc-android/jni/jni_bundle.h b/vlc-android/jni/jni_bundle.h
new file mode 100644
index 0000000..13c9ee4
--- /dev/null
+++ b/vlc-android/jni/jni_bundle.h
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * jni_bundle.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_BUNDLE_H
+#define JNI_BUNDLE_H
+
+#include "jni_libvlc.h"
+
+typedef struct {
+    jclass clsBundle;
+    jobject bundle;
+    bool needReleaseBundle;
+
+    jmethodID putInt;
+    jmethodID getInt;
+    jmethodID getLong;
+    jmethodID putFloat;
+    jmethodID putString;
+    jmethodID getString;
+} JavaBundle;
+
+JavaBundle *jbundle_init(JNIEnv *env, JavaBundle *p_bundle);
+JavaBundle *jbundle_attach(JNIEnv *env, JavaBundle *p_bundle, jobject jbundle);
+
+void jbundle_destroy(JNIEnv *env, JavaBundle *p_bundle);
+
+void jbundle_put_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int value);
+int jbundle_get_int(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int default_value);
+
+int64_t jbundle_get_long(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        int64_t default_value);
+
+void jbundle_put_float(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        float value);
+
+void jbundle_put_string(JNIEnv *env, JavaBundle *p_bundle, const char *key,
+        const char *value);
+char *jbundle_get_string(JNIEnv *env, JavaBundle *p_bundle, const char *key);
+
+#endif//JNI_BUNDLE_H
diff --git a/vlc-android/jni/jni_libvlc.h b/vlc-android/jni/jni_libvlc.h
new file mode 100644
index 0000000..66b3cb8
--- /dev/null
+++ b/vlc-android/jni/jni_libvlc.h
@@ -0,0 +1,36 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_include.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLC_H
+#define JNI_LIBVLC_H
+
+#include <stdint.h>
+#include <string.h>
+#include <jni.h>
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+#endif//JNI_LIBVLC_H
diff --git a/vlc-android/jni/jni_libvlcevent.c b/vlc-android/jni/jni_libvlcevent.c
new file mode 100644
index 0000000..9dc5ecd
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.c
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * jni_libvlcevent.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "jni_libvlcevent.h"
+
+#define BUNDLE_MediaPlayerBuffering_NEW_CACHE "new_cache"
+#define BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE "new_seekable"
+#define BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE "new_pausable"
+#define BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL "new_cache_total"
+
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoder "video_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl "video_decoder_impl"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoder "audio_decoder"
+#define BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl "audio_decoder_impl"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle) {
+    if (NULL == jbundle_init(env, p_bundle))
+        return NULL;
+
+    switch (ev->type) {
+    case libvlc_MediaPlayerBuffering: {
+        float new_cache = ev->u.media_player_buffering.new_cache;
+        jbundle_put_float(env, p_bundle, BUNDLE_MediaPlayerBuffering_NEW_CACHE,
+                new_cache);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int new_seekable = ev->u.media_player_seekable_changed.new_seekable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerSeekableChanged_NEW_SEEKABLE, new_seekable);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int new_pausable = ev->u.media_player_pausable_changed.new_pausable;
+        jbundle_put_int(env, p_bundle,
+                BUNDLE_MediaPlayerPausableChanged_NEW_PAUSABLE, new_pausable);
+        break;
+    }
+    case libvlc_MediaPlayerBufferingTotal: {
+        float new_cache_total =
+                ev->u.media_player_buffering_total.new_cache_total;
+        jbundle_put_float(env, p_bundle,
+                BUNDLE_MediaPlayerBufferingTotal_NEW_CACHE_TOTAL,
+                new_cache_total);
+        break;
+    }
+    case libvlc_MediaPlayerModuleChanged: {
+        const char* video_decoder =
+                ev->u.media_player_module_changed.psz_video_decoder;
+        const char* video_decoder_impl =
+                ev->u.media_player_module_changed.psz_video_decoder_impl;
+        const char* audio_decoder =
+                ev->u.media_player_module_changed.psz_audio_decoder;
+        const char* audio_decoder_impl =
+                ev->u.media_player_module_changed.psz_audio_decoder_impl;
+
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoder, video_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_VideoDecoderImpl,
+                video_decoder_impl);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoder, audio_decoder);
+        jbundle_put_string(env, p_bundle,
+                BUNDLE_MediaPlayerModuleChanged_AudioDecoderImpl,
+                audio_decoder_impl);
+        break;
+    }
+    }
+
+    return p_bundle;
+}
diff --git a/vlc-android/jni/jni_libvlcevent.h b/vlc-android/jni/jni_libvlcevent.h
new file mode 100644
index 0000000..92e39f2
--- /dev/null
+++ b/vlc-android/jni/jni_libvlcevent.h
@@ -0,0 +1,32 @@
+/*****************************************************************************
+ * jni_libvlcevent.h
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_LIBVLCEVENT_H
+#define JNI_LIBVLCEVENT_H
+
+#include <vlc/vlc.h>
+#include "jni_bundle.h"
+
+JavaBundle *jbundle_from_event(JNIEnv *env, const libvlc_event_t *ev,
+        JavaBundle *p_bundle);
+
+#endif//JNI_LIBVLCEVENT_H
diff --git a/vlc-android/jni/jni_vsl.c b/vlc-android/jni/jni_vsl.c
new file mode 100644
index 0000000..8c57a4a
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.c
@@ -0,0 +1,263 @@
+/*****************************************************************************
+ * jni_vsl.c: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <jni.h>
+
+#include <vlc/vlc.h>
+
+#include "jni_vsl.h"
+#include "jni_bundle.h"
+
+#define LOG_TAG "VLC/JNI/vsl"
+#include "log.h"
+
+/** Unique Java VM instance, as defined in libvlcjni.c */
+extern JavaVM *myVm;
+
+#define BUNDLE_KEY_BUF_SIZE 64
+#define BUNDLE_COUNT "count"
+
+#define BUNDLE_MRL "segment_mrl"
+#define BUNDLE_URL "segment_url"
+#define BUNDLE_DURATION "duration"
+#define BUNDLE_BYTES "bytes"
+
+static jobject do_get_bundle(JNIEnv* env, jobject gui) {
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return NULL;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslGetBundle",
+            "()Landroid/os/Bundle;");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslGetBundle");
+        return NULL;
+    }
+
+    jobject jbundle = (*env)->CallObjectMethod(env, gui, methodID);
+    return jbundle;
+}
+
+/* */
+static int do_load(JNIEnv* env, jobject gui, bool b_force_reload) {
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, gui);
+    if (!cls) {
+        LOGE("vsl: failed to get class reference");
+        return -1;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "vslLoad", "(Z)Z");
+    if (!methodID) {
+        LOGE("vsl: failed to get method vslLoad");
+        return -1;
+    }
+
+    jboolean jsuccess = (*env)->CallBooleanMethod(env, gui, methodID,
+            b_force_reload);
+    return jsuccess ? 0 : -1;
+}
+
+int jvsl_load(void *p_cb_data, bool b_force_reload) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_load(env, p_cb_data, b_force_reload);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int do_get_count(JNIEnv* env, jobject gui) {
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    int ret = jbundle_get_int(env, &javaBundle, BUNDLE_COUNT, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_count(void *p_cb_data) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_count(env, p_cb_data);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static char *do_get_mrl(JNIEnv* env, jobject gui, int order) {
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_MRL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_mrl: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_mrl(void *p_cb_data, int order) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_mrl(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static char *do_get_url(JNIEnv* env, jobject gui, int order) {
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return NULL;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_URL);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_url: %s", szBuf);
+    char *ret = jbundle_get_string(env, &javaBundle, szBuf);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+char *jvsl_get_url(void *p_cb_data, int order) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return NULL;
+    }
+
+    char *ret = do_get_url(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int do_get_duratuon(JNIEnv* env, jobject gui, int order) {
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_DURATION);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_duratuon: %s", szBuf);
+    int ret = jbundle_get_int(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int jvsl_get_duration(void *p_cb_data, int order) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int ret = do_get_duratuon(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
+
+/* */
+static int64_t do_get_bytes(JNIEnv* env, jobject gui, int order) {
+    jobject jbundle = do_get_bundle(env, gui);
+    if (!jbundle) {
+        LOGE("do_get_count NULL bundle");
+        return -1;
+    }
+
+    char szBuf[BUNDLE_KEY_BUF_SIZE];
+    sprintf(szBuf, "%d_%s", order, BUNDLE_BYTES);
+    JavaBundle javaBundle;
+    jbundle_attach(env, &javaBundle, jbundle);
+    LOGD("do_get_bytes: %s", szBuf);
+    int64_t ret = jbundle_get_long(env, &javaBundle, szBuf, -1);
+    jbundle_destroy(env, &javaBundle);
+
+    (*env)->DeleteLocalRef(env, jbundle);
+    return ret;
+}
+
+int64_t jvsl_get_bytes(void *p_cb_data, int order) {
+    JNIEnv *env = NULL;
+    if ((*myVm)->AttachCurrentThread(myVm, &env, NULL) != 0) {
+        LOGE("Could not attach the jvsl thread to the JVM !");
+        return -1;
+    }
+
+    int64_t ret = do_get_bytes(env, p_cb_data, order);
+
+    (*myVm)->DetachCurrentThread(myVm);
+    return ret;
+}
diff --git a/vlc-android/jni/jni_vsl.h b/vlc-android/jni/jni_vsl.h
new file mode 100644
index 0000000..256b0ed
--- /dev/null
+++ b/vlc-android/jni/jni_vsl.h
@@ -0,0 +1,36 @@
+/*****************************************************************************
+ * jni_vsl.h: video segment list access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef JNI_VSL_H
+#define JNI_VSL_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+int jvsl_load(void *p_cb_data, bool b_force_reload);
+int jvsl_get_count(void *p_cb_data);
+char *jvsl_get_mrl(void *p_cb_data, int i_order);
+char *jvsl_get_url(void *p_cb_data, int i_order);
+int jvsl_get_duration(void *p_cb_data, int i_order);
+int64_t jvsl_get_bytes(void *p_cb_data, int i_order);
+
+#endif // JNI_VSL_H
diff --git a/vlc-android/jni/libvlcjni_danmaku.c b/vlc-android/jni/libvlcjni_danmaku.c
new file mode 100644
index 0000000..d012825
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku.c
@@ -0,0 +1,1174 @@
+/*****************************************************************************
+ * libvlcjni.c
+ *****************************************************************************
+ * Copyright © 2010-2012 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <vlc/vlc.h>
+#include <vlc_common.h>
+#include <vlc_url.h>
+#include <vlc_fourcc.h>
+
+#include <jni.h>
+
+#include <android/api-level.h>
+
+#include "libvlcjni.h"
+#include "aout.h"
+#include "utils.h"
+
+#define LOG_TAG "VLC/JNI/main"
+#include "log.h"
+
+#include "jni_libvlc.h"
+#include "jni_bundle.h"
+#include "jni_libvlcevent.h"
+#include "jni_vsl.h"
+#include "libvlcjni_danmaku_events.inc.c"
+
+#define AOUT_AUDIOTRACK_JAVA 0
+#define AOUT_AUDIOTRACK      1
+#define AOUT_OPENSLES        2
+
+static jint getInt(JNIEnv *env, jobject thiz, const char* field) {
+    jclass clazz = (*env)->GetObjectClass(env, thiz);
+    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
+                                          field, "I");
+    return (*env)->GetIntField(env, thiz, fieldMP);
+}
+static void setInt(JNIEnv *env, jobject item, const char* field, jint value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "I");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetIntField(env, item, fieldId, value);
+}
+
+static jlong getLong(JNIEnv *env, jobject thiz, const char* field) {
+    jclass clazz = (*env)->GetObjectClass(env, thiz);
+    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
+                                          field, "J");
+    return (*env)->GetLongField(env, thiz, fieldMP);
+}
+static void setLong(JNIEnv *env, jobject item, const char* field, jlong value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "J");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetLongField(env, item, fieldId, value);
+}
+
+static void setFloat(JNIEnv *env, jobject item, const char* field, jfloat value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "F");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetFloatField(env, item, fieldId, value);
+}
+static void setString(JNIEnv *env, jobject item, const char* field, const char* text) {
+    jclass cls;
+    jfieldID fieldId;
+    jstring jstr;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "Ljava/lang/String;");
+    if (fieldId == NULL)
+        return;
+
+    /* Create a new string and overwrite the instance field */
+    jstr = (*env)->NewStringUTF(env, text);
+    if (jstr == NULL)
+        return;
+    (*env)->SetObjectField(env, item, fieldId, jstr);
+}
+
+struct length_change_monitor {
+    pthread_mutex_t doneMutex;
+    pthread_cond_t doneCondVar;
+    bool length_changed;
+};
+
+static void length_changed_callback(const libvlc_event_t *ev, void *data)
+{
+    struct length_change_monitor *monitor = data;
+    pthread_mutex_lock(&monitor->doneMutex);
+    monitor->length_changed = true;
+    pthread_cond_signal(&monitor->doneCondVar);
+    pthread_mutex_unlock(&monitor->doneMutex);
+}
+
+libvlc_media_t *new_media(jlong instance, JNIEnv *env, jobject thiz, jstring fileLocation, bool noOmx, bool noVideo)
+{
+    libvlc_instance_t *libvlc = (libvlc_instance_t*)(intptr_t)instance;
+    jboolean isCopy;
+    const char *psz_location = (*env)->GetStringUTFChars(env, fileLocation, &isCopy);
+    libvlc_media_t *p_md = libvlc_media_new_location(libvlc, psz_location);
+    (*env)->ReleaseStringUTFChars(env, fileLocation, psz_location);
+    if (!p_md)
+        return NULL;
+
+    if (!noOmx) {
+#if 0
+        jclass cls = (*env)->GetObjectClass(env, thiz);
+        jmethodID methodId = (*env)->GetMethodID(env, cls, "useIOMX", "()Z");
+        if ((*env)->CallBooleanMethod(env, thiz, methodId)) {
+            /*
+             * Set higher caching values if using iomx decoding, since some omx
+             * decoders have a very high latency, and if the preroll data isn't
+             * enough to make the decoder output a frame, the playback timing gets
+             * started too soon, and every decoded frame appears to be too late.
+             * On Nexus One, the decoder latency seems to be 25 input packets
+             * for 320x170 H.264, a few packets less on higher resolutions.
+             * On Nexus S, the decoder latency seems to be about 7 packets.
+             */
+            libvlc_media_add_option(p_md, ":file-caching=1500");
+            libvlc_media_add_option(p_md, ":network-caching=1500");
+            libvlc_media_add_option(p_md, ":codec=iomx,all");
+        }
+#endif
+        if (noVideo)
+            libvlc_media_add_option(p_md, ":no-video");
+    }
+    return p_md;
+}
+
+#if 0
+static libvlc_media_list_t *getMediaList(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_list_t*)(intptr_t)getLong(env, thiz, "mMediaListInstance");
+}
+#endif
+
+static libvlc_media_player_t *getMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_player_t*)(intptr_t)getLong(env, thiz, "mInternalMediaPlayerInstance");
+}
+
+#if 0
+static libvlc_media_list_player_t *getMediaListPlayer(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_list_player_t*)(intptr_t)getLong(env, thiz, "mMediaListPlayerInstance");
+}
+#endif
+
+static void unsetMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)0);
+}
+
+static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+    {
+        libvlc_media_player_stop(mp);
+        libvlc_media_player_release(mp);
+        unsetMediaPlayer(env, thiz);
+        setLong(env, thiz, "mInternalMediaPlayerInstance", 0);
+    }
+}
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+JavaVM *myVm;
+
+static jobject eventManagerInstance = NULL;
+
+static pthread_mutex_t vout_android_lock;
+static void *vout_android_surf = NULL;
+static void *vout_android_gui = NULL;
+
+void *jni_LockAndGetAndroidSurface() {
+    pthread_mutex_lock(&vout_android_lock);
+    return vout_android_surf;
+}
+
+void jni_UnlockAndroidSurface() {
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+/* TODO: send sar_num and sar_den to java side */
+void jni_SetAndroidSurfaceSize(int width, int height, int sar_num, int sar_den)
+{
+    if (vout_android_gui == NULL)
+        return;
+
+    JNIEnv *p_env;
+
+    (*myVm)->AttachCurrentThread (myVm, &p_env, NULL);
+    jclass cls = (*p_env)->GetObjectClass (p_env, vout_android_gui);
+    jmethodID methodId = (*p_env)->GetMethodID (p_env, cls, "setSurfaceSize", "(II)V");
+
+    (*p_env)->CallVoidMethod (p_env, vout_android_gui, methodId, width, height);
+
+    (*p_env)->DeleteLocalRef(p_env, cls);
+    (*myVm)->DetachCurrentThread (myVm);
+}
+
+#include "libvlcjni_danmaku_events.inc.c"
+static void vlc_event_callback(const libvlc_event_t *ev, void *data)
+{
+    JNIEnv *env;
+    JavaVM *myVm = data;
+
+    bool isAttached = false;
+
+    if (eventManagerInstance == NULL)
+        return;
+
+    int status = (*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2);
+    if (status < 0) {
+#if 0
+        LOGD("vlc_event_callback: failed to get JNI environment, "
+             "assuming native thread");
+#endif
+        status = (*myVm)->AttachCurrentThread(myVm, &env, NULL);
+        if (status < 0)
+            return;
+        isAttached = true;
+    }
+
+    JavaBundle javaBundle;
+    memset(&javaBundle, 0, sizeof(javaBundle));
+    if (NULL == jbundle_from_event(env, ev, &javaBundle)) {
+        LOGE("EventManager: failed to crate bundle");
+        return;
+    }
+
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, eventManagerInstance);
+    if (!cls) {
+        LOGE("EventManager: failed to get class reference");
+        goto end;
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
+    if (methodID) {
+        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type, javaBundle.bundle);
+    } else {
+        LOGE("EventManager: failed to get the callback method");
+    }
+
+end:
+    jbundle_destroy(env, &javaBundle);
+
+    if (isAttached)
+        (*myVm)->DetachCurrentThread(myVm);
+}
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved)
+{
+    // Keep a reference on the Java VM.
+    myVm = vm;
+
+    pthread_mutex_init(&vout_android_lock, NULL);
+
+    LOGD("JNI interface loaded.");
+    return JNI_VERSION_1_2;
+}
+
+void JNI_OnUnload(JavaVM* vm, void* reserved) {
+    pthread_mutex_destroy(&vout_android_lock);
+}
+
+void Java_org_videolan_vlc_LibVLC_attachSurface(JNIEnv *env, jobject thiz, jobject surf, jobject gui, jint width, jint height) {
+    jclass clz;
+    jfieldID fid;
+
+    pthread_mutex_lock(&vout_android_lock);
+    clz = (*env)->GetObjectClass(env, surf);
+    fid = (*env)->GetFieldID(env, clz, "mSurface", "I");
+    if (fid == NULL) {
+        jthrowable exp = (*env)->ExceptionOccurred(env);
+        if (exp) {
+            (*env)->DeleteLocalRef(env, exp);
+            (*env)->ExceptionClear(env);
+        }
+        fid = (*env)->GetFieldID(env, clz, "mNativeSurface", "I");
+    }
+    vout_android_surf = (void*)(*env)->GetIntField(env, surf, fid);
+    (*env)->DeleteLocalRef(env, clz);
+
+    vout_android_gui = (*env)->NewGlobalRef(env, gui);
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+void Java_org_videolan_vlc_LibVLC_detachSurface(JNIEnv *env, jobject thiz) {
+    pthread_mutex_lock(&vout_android_lock);
+    vout_android_surf = NULL;
+    if (vout_android_gui != NULL)
+        (*env)->DeleteGlobalRef(env, vout_android_gui);
+    vout_android_gui = NULL;
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+static void debug_log(void *data, int level, const char *fmt, va_list ap)
+{
+    bool *verbose = data;
+
+    static const uint8_t priority[5] = {
+        [LIBVLC_DEBUG]   = ANDROID_LOG_DEBUG,
+        [1 /* ??? */]    = ANDROID_LOG_DEBUG,
+        [LIBVLC_NOTICE]  = ANDROID_LOG_INFO,
+        [LIBVLC_WARNING] = ANDROID_LOG_WARN,
+        [LIBVLC_ERROR]   = ANDROID_LOG_ERROR,
+    };
+
+    int prio = ANDROID_LOG_DEBUG;
+    if (level >= LIBVLC_DEBUG && level <= LIBVLC_ERROR)
+        prio = priority[level];
+
+    if (!*verbose)
+        return;
+
+    __android_log_vprint(prio, "VLC", fmt, ap);
+}
+
+static libvlc_log_subscriber_t debug_subscriber;
+static bool verbosity;
+
+void Java_org_videolan_vlc_LibVLC_changeVerbosity(JNIEnv *env, jobject thiz, jboolean verbose)
+{
+    verbosity = verbose;
+    libvlc_log_unsubscribe(&debug_subscriber);
+    libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
+}
+
+#include "libvlcjni_danmaku_nativeInitEx.inc.c"
+#if 0
+void Java_org_videolan_vlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz, jboolean verbose)
+{
+    //only use OpenSLES if java side says we can
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    bool use_opensles = (*env)->CallIntMethod(env, thiz, methodId) == AOUT_OPENSLES;
+
+    methodId = (*env)->GetMethodID(env, cls, "timeStretchingEnabled", "()Z");
+    bool enable_time_stretch = (*env)->CallBooleanMethod(env, thiz, methodId);
+
+    verbosity = verbose;
+    libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
+
+    /* Don't add any invalid options, otherwise it causes LibVLC to crash */
+    const char *argv[] = {
+        "-I", "dummy",
+        "--no-osd",
+        "--no-video-title-show",
+        "--no-stats",
+        "--no-plugins-cache",
+        "--no-drop-late-frames",
+        "--avcodec-fast",
+        enable_time_stretch ? "--audio-time-stretch" : "--no-audio-time-stretch",
+        use_opensles ? "--aout=opensles" : "--aout=android_audiotrack",
+    };
+    libvlc_instance_t *instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+
+    /* Initialize media list (a.k.a. playlist/history) */
+    libvlc_media_list_t* pointer = libvlc_media_list_new( instance );
+    if(!pointer) {
+        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to create LibVLC media list");
+        return;
+    }
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_list_event_manager(pointer);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaListItemAdded,
+        libvlc_MediaListItemDeleted,
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    setLong(env, thiz, "mMediaListInstance", (jlong)(intptr_t)pointer);
+}
+#endif
+
+jstring Java_org_videolan_vlc_LibVLC_nativeToURI(JNIEnv *env, jobject thiz, jstring path)
+{
+    jboolean isCopy;
+    /* Get C string */
+    const char* psz_path = (*env)->GetStringUTFChars(env, path, &isCopy);
+    /* Convert the path to URI */
+    char* psz_location;
+    if(unlikely( strstr( psz_path, "://" ) ))
+        psz_location = strdup(psz_path);
+    else
+        psz_location = vlc_path2uri(psz_path, "file");
+    /* Box into jstring */
+    jstring t = (*env)->NewStringUTF(env, psz_location);
+    /* Clean up */
+    (*env)->ReleaseStringUTFChars(env, path, psz_path);
+    free(psz_location);
+    return t;
+}
+
+void Java_org_videolan_vlc_LibVLC_nativeDestroy(JNIEnv *env, jobject thiz)
+{
+    releaseMediaPlayer(env, thiz);
+    jlong libVlcInstance = getLong(env, thiz, "mLibVlcInstance");
+    if (!libVlcInstance)
+        return; // Already destroyed
+
+    libvlc_instance_t *instance = (libvlc_instance_t*)(intptr_t) libVlcInstance;
+    libvlc_release(instance);
+    libvlc_log_unsubscribe(&debug_subscriber);
+
+    setLong(env, thiz, "mLibVlcInstance", 0);
+}
+
+void Java_org_videolan_vlc_LibVLC_detachEventManager(JNIEnv *env, jobject thiz)
+{
+    if (eventManagerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventManagerInstance);
+        eventManagerInstance = NULL;
+    }
+}
+
+void Java_org_videolan_vlc_LibVLC_setEventManager(JNIEnv *env, jobject thiz, jobject eventManager)
+{
+    if (eventManagerInstance != NULL) {
+        (*env)->DeleteGlobalRef(env, eventManagerInstance);
+        eventManagerInstance = NULL;
+    }
+
+    jclass cls = (*env)->GetObjectClass(env, eventManager);
+    if (!cls) {
+        LOGE("setEventManager: failed to get class reference");
+        return;
+    }
+
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
+    if (!methodID) {
+        LOGE("setEventManager: failed to get the callback method");
+        return;
+    }
+
+    eventManagerInstance = (*env)->NewGlobalRef(env, eventManager);
+}
+
+#if 0
+jobjectArray Java_org_videolan_vlc_LibVLC_readMediaMeta(JNIEnv *env,
+                                                        jobject thiz, jlong instance, jstring mrl)
+{
+    jobjectArray array = (*env)->NewObjectArray(env, 8,
+            (*env)->FindClass(env, "java/lang/String"),
+            (*env)->NewStringUTF(env, ""));
+
+    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, false);
+    if (!m)
+    {
+        LOGE("readMediaMeta: Could not create the media!");
+        return array;
+    }
+
+    libvlc_media_parse(m);
+
+    static const char str[][7] = {
+        "artist", "album", "title", "genre",
+    };
+    static const libvlc_meta_t meta_id[] = {
+        libvlc_meta_Artist,
+        libvlc_meta_Album,
+        libvlc_meta_Title,
+        libvlc_meta_Genre,
+    };
+    for (int i=0; i < sizeof(str) / sizeof(*str); i++) {
+        char *meta = libvlc_media_get_meta(m, meta_id[i]);
+        if (!meta)
+            meta = strdup("");
+
+        jstring k = (*env)->NewStringUTF(env, str[i]);
+        (*env)->SetObjectArrayElement(env, array, 2*i, k);
+        jstring v = (*env)->NewStringUTF(env, meta);
+        (*env)->SetObjectArrayElement(env, array, 2*i+1, v);
+
+        free(meta);
+   }
+
+   libvlc_media_release(m);
+   return array;
+}
+#endif
+
+#include "libvlcjni_danmaku_readMediaEx.inc.c"
+void Java_org_videolan_vlc_LibVLC_readMediaEx(JNIEnv *env,
+                                              jobject thiz, jlong instance, jstring mrl, jarray options)
+{
+    create_player_and_play_ex(env, thiz, instance, vout_android_gui, mrl, options);
+}
+#if 0
+static void create_player_and_play(JNIEnv* env, jobject thiz,
+                                   jlong instance, int position) {
+    /* Release previous media player, if any */
+    releaseMediaPlayer(env, thiz);
+
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_list_player_t* p_mlp = libvlc_media_list_player_new((libvlc_instance_t*)instance);
+    libvlc_media_player_t *mp = libvlc_media_player_new((libvlc_instance_t*)instance);
+
+    jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
+
+    //if AOUT_AUDIOTRACK_JAVA, we use amem
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    if ( (*env)->CallIntMethod(env, thiz, methodId) == AOUT_AUDIOTRACK_JAVA )
+    {
+        libvlc_audio_set_callbacks(mp, aout_play, aout_pause, NULL, NULL, NULL,
+                                   (void*) myJavaLibVLC);
+        libvlc_audio_set_format_callbacks(mp, aout_open, aout_close);
+    }
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaPlayerPlaying,
+        libvlc_MediaPlayerPaused,
+        libvlc_MediaPlayerEndReached,
+        libvlc_MediaPlayerStopped,
+        libvlc_MediaPlayerVout,
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    libvlc_media_list_player_set_media_list(p_mlp, p_mlist);
+    libvlc_media_list_player_set_media_player(p_mlp, mp);
+
+    /* Keep a pointer to this media player */
+    setLong(env, thiz, "mMediaListPlayerInstance", (jlong)(intptr_t)p_mlp);
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)(intptr_t)mp);
+
+    libvlc_media_list_player_play_item_at_index(p_mlp, position);
+}
+
+void Java_org_videolan_vlc_LibVLC_readMedia(JNIEnv *env, jobject thiz,
+                                            jlong instance, jstring mrl, jboolean novideo)
+{
+    /* Create a new item */
+    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, novideo);
+    if (!m)
+    {
+        LOGE("readMedia: Could not create the media!");
+        return;
+    }
+
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+
+    libvlc_media_list_lock(p_mlist);
+    if(libvlc_media_list_add_media(p_mlist, m) != 0) {
+        LOGE("readMedia: Could not add to the media list!");
+        libvlc_media_list_unlock(p_mlist);
+        libvlc_media_release(m);
+        return;
+    }
+    int position = libvlc_media_list_index_of_item(p_mlist, m);
+    libvlc_media_list_unlock(p_mlist);
+
+    /* No need to keep the media now */
+    libvlc_media_release(m);
+
+    create_player_and_play(env, thiz, instance, position);
+}
+
+void Java_org_videolan_vlc_LibVLC_playIndex(JNIEnv *env, jobject thiz,
+                                            jlong instance, int position) {
+    create_player_and_play(env, thiz, instance, position);
+}
+
+void Java_org_videolan_vlc_LibVLC_getMediaListItems(
+                JNIEnv *env, jobject thiz, jobject arrayList) {
+    jclass arrayClass = (*env)->FindClass(env, "java/util/ArrayList");
+    jmethodID methodID = (*env)->GetMethodID(env, arrayClass, "add", "(Ljava/lang/Object;)Z");
+    jstring str;
+
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+    libvlc_media_list_lock( p_mlist );
+    for(int i = 0; i < libvlc_media_list_count( p_mlist ); i++) {
+        char* mrl = libvlc_media_get_mrl( libvlc_media_list_item_at_index( p_mlist, i ) );
+        str = (*env)->NewStringUTF(env, mrl);
+        (*env)->CallBooleanMethod(env, arrayList, methodID, str);
+        (*env)->DeleteLocalRef(env, str);
+        free(mrl);
+    }
+    libvlc_media_list_unlock( p_mlist );
+}
+
+jfloat Java_org_videolan_vlc_LibVLC_getRate(JNIEnv *env, jobject thiz) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        return libvlc_media_player_get_rate(mp);
+    else
+        return 1.00;
+}
+
+void Java_org_videolan_vlc_LibVLC_setRate(JNIEnv *env, jobject thiz, jfloat rate) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        libvlc_media_player_set_rate(mp, rate);
+}
+
+jboolean Java_org_videolan_vlc_LibVLC_hasVideoTrack(JNIEnv *env, jobject thiz,
+                                                    jlong i_instance, jstring fileLocation)
+{
+    /* Create a new item and assign it to the media player. */
+    libvlc_media_t *p_m = new_media(i_instance, env, thiz, fileLocation, false, false);
+    if (p_m == NULL)
+    {
+        LOGE("Could not create the media!");
+        return JNI_FALSE;
+    }
+
+    /* Get the tracks information of the media. */
+    libvlc_media_track_info_t *p_tracks;
+    libvlc_media_parse(p_m);
+
+    libvlc_media_player_t* p_mp = libvlc_media_player_new_from_media(p_m);
+
+    struct length_change_monitor* monitor;
+    monitor = malloc(sizeof(struct length_change_monitor));
+    if (!monitor) return 0;
+
+    /* Initialize pthread variables. */
+    pthread_mutex_init(&monitor->doneMutex, NULL);
+    pthread_cond_init(&monitor->doneCondVar, NULL);
+    monitor->length_changed = false;
+
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(p_mp);
+    libvlc_event_attach(ev, libvlc_MediaPlayerLengthChanged, length_changed_callback, monitor);
+    libvlc_media_player_play( p_mp );
+
+    pthread_mutex_lock(&monitor->doneMutex);
+
+    struct timespec deadline;
+    clock_gettime(CLOCK_REALTIME, &deadline);
+    deadline.tv_sec += 2; /* If "VLC can't open the file", return */
+    int mp_alive = 1;
+    while( !monitor->length_changed && mp_alive ) {
+        pthread_cond_timedwait(&monitor->doneCondVar, &monitor->doneMutex, &deadline);
+        mp_alive = libvlc_media_player_will_play(p_mp);
+    }
+    pthread_mutex_unlock(&monitor->doneMutex);
+
+    int i_nbTracks;
+    if( mp_alive )
+        i_nbTracks = libvlc_video_get_track_count(p_mp);
+    else
+        i_nbTracks = -1;
+    LOGI("Number of video tracks: %d",i_nbTracks);
+
+    libvlc_event_detach(ev, libvlc_MediaPlayerLengthChanged, length_changed_callback, monitor);
+    libvlc_media_player_stop(p_mp);
+    libvlc_media_player_release(p_mp);
+    libvlc_media_release(p_m);
+
+    pthread_mutex_destroy(&monitor->doneMutex);
+    pthread_cond_destroy(&monitor->doneCondVar);
+    free(monitor);
+
+    if(i_nbTracks > 0)
+        return JNI_TRUE;
+    else if(i_nbTracks < 0)
+        (*env)->ThrowNew(env, (*env)->FindClass(env, "java/io/IOException"), "VLC can't open the file");
+    else
+        return JNI_FALSE;
+}
+
+jobjectArray read_track_info_internal(JNIEnv *env, jobject thiz, libvlc_media_t* p_m)
+{
+    /* get java class */
+    jclass cls = (*env)->FindClass( env, "org/videolan/vlc/TrackInfo" );
+    if ( !cls )
+    {
+        LOGE("Failed to load class (org/videolan/vlc/TrackInfo)" );
+        return NULL;
+    }
+
+    /* get java class contructor */
+    jmethodID clsCtor = (*env)->GetMethodID( env, cls, "<init>", "()V" );
+    if ( !clsCtor )
+    {
+        LOGE("Failed to find class constructor (org/videolan/vlc/TrackInfo)" );
+        return NULL;
+    }
+
+    /* Get the tracks information of the media. */
+    libvlc_media_track_info_t *p_tracks;
+
+    int i_nbTracks = libvlc_media_get_tracks_info(p_m, &p_tracks);
+    jobjectArray array = (*env)->NewObjectArray(env, i_nbTracks + 1, cls, NULL);
+
+    unsigned i;
+    if (array != NULL)
+    {
+        for (i = 0; i <= i_nbTracks; ++i)
+        {
+            jobject item = (*env)->NewObject(env, cls, clsCtor);
+            if (item == NULL)
+                continue;
+            (*env)->SetObjectArrayElement(env, array, i, item);
+
+            // use last track for metadata
+            if (i == i_nbTracks)
+            {
+                setInt(env, item, "Type", 3 /* TYPE_META */);
+                setLong(env, item, "Length", libvlc_media_get_duration(p_m));
+                setString(env, item, "Title", libvlc_media_get_meta(p_m, libvlc_meta_Title));
+                setString(env, item, "Artist", libvlc_media_get_meta(p_m, libvlc_meta_Artist));
+                setString(env, item, "Album", libvlc_media_get_meta(p_m, libvlc_meta_Album));
+                setString(env, item, "Genre", libvlc_media_get_meta(p_m, libvlc_meta_Genre));
+                setString(env, item, "ArtworkURL", libvlc_media_get_meta(p_m, libvlc_meta_ArtworkURL));
+                continue;
+            }
+
+            setInt(env, item, "Id", p_tracks[i].i_id);
+            setInt(env, item, "Type", p_tracks[i].i_type);
+            setString(env, item, "Codec", (const char*)vlc_fourcc_GetDescription(0,p_tracks[i].i_codec));
+            setString(env, item, "Language", p_tracks[i].psz_language);
+
+            if (p_tracks[i].i_type == libvlc_track_video)
+            {
+                setInt(env, item, "Height", p_tracks[i].u.video.i_height);
+                setInt(env, item, "Width", p_tracks[i].u.video.i_width);
+                setFloat(env, item, "Framerate", p_tracks[i].u.video.f_frame_rate);
+            }
+            if (p_tracks[i].i_type == libvlc_track_audio)
+            {
+                setInt(env, item, "Channels", p_tracks[i].u.audio.i_channels);
+                setInt(env, item, "Samplerate", p_tracks[i].u.audio.i_rate);
+            }
+        }
+    }
+
+    libvlc_media_tracks_info_release(p_tracks, i_nbTracks);
+    return array;
+}
+
+
+jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject thiz,
+                                                         jlong instance, jstring mrl)
+{
+    /* Create a new item and assign it to the media player. */
+    libvlc_media_t *p_m = new_media(instance, env, thiz, mrl, false, false);
+    if (p_m == NULL)
+    {
+        LOGE("Could not create the media!");
+        return NULL;
+    }
+
+    libvlc_media_parse(p_m);
+    jobjectArray jar = read_track_info_internal(env, thiz, p_m);
+    libvlc_media_release(p_m);
+    return jar;
+}
+
+
+jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfoPosition(JNIEnv *env, jobject thiz,
+                                                         jint position)
+{
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+    libvlc_media_t *p_m = libvlc_media_list_item_at_index( p_mlist, position );
+    if (p_m == NULL) {
+        LOGE("Could not load get media @ position %d!", position);
+        return NULL;
+    } else
+        return read_track_info_internal(env, thiz, p_m);
+}
+
+jlong Java_org_videolan_vlc_LibVLC_getLengthFromLocation(JNIEnv *env, jobject thiz,
+                                                     jlong i_instance, jstring fileLocation)
+{
+    jlong length = 0;
+    struct length_change_monitor *monitor;
+    monitor = malloc(sizeof(*monitor));
+    if (!monitor)
+        return 0;
+
+    /* Initialize pthread variables. */
+    pthread_mutex_init(&monitor->doneMutex, NULL);
+    pthread_cond_init(&monitor->doneCondVar, NULL);
+    monitor->length_changed = false;
+
+    /* Create a new item and assign it to the media player. */
+    libvlc_media_t *m = new_media(i_instance, env, thiz, fileLocation, false, false);
+    if (m == NULL)
+    {
+        LOGE("Could not create the media to play!");
+        goto end;
+    }
+
+    /* Create a media player playing environment */
+    libvlc_media_player_t *mp = libvlc_media_player_new_from_media (m);
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    libvlc_event_attach(ev, libvlc_MediaPlayerLengthChanged, length_changed_callback, monitor);
+    libvlc_media_release (m);
+    libvlc_media_player_play( mp );
+
+    pthread_mutex_lock(&monitor->doneMutex);
+    while (!monitor->length_changed)
+        pthread_cond_wait(&monitor->doneCondVar, &monitor->doneMutex);
+    pthread_mutex_unlock(&monitor->doneMutex);
+
+    length = libvlc_media_player_get_length( mp );
+    libvlc_media_player_stop( mp );
+    libvlc_media_player_release( mp );
+
+end:
+    pthread_mutex_destroy(&monitor->doneMutex);
+    pthread_cond_destroy(&monitor->doneCondVar);
+    free(monitor);
+
+    return length;
+}
+#endif
+
+jboolean Java_org_videolan_vlc_LibVLC_hasMediaPlayer(JNIEnv *env, jobject thiz)
+{
+    return !!getMediaPlayer(env, thiz);
+}
+
+jboolean Java_org_videolan_vlc_LibVLC_isPlaying(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_playing(mp);
+    else
+        return 0;
+}
+
+jboolean Java_org_videolan_vlc_LibVLC_isSeekable(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return !!libvlc_media_player_is_seekable(mp);
+    return 0;
+}
+
+void Java_org_videolan_vlc_LibVLC_play(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_play(mp);
+}
+
+void Java_org_videolan_vlc_LibVLC_pause(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_pause(mp, 1);
+}
+
+void Java_org_videolan_vlc_LibVLC_stop(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_stop(mp);
+}
+
+#if 0
+void Java_org_videolan_vlc_LibVLC_previous(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_list_player_t *mp = getMediaListPlayer(env, thiz);
+    if (mp)
+        libvlc_media_list_player_previous(mp);
+}
+
+void Java_org_videolan_vlc_LibVLC_next(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_list_player_t *mp = getMediaListPlayer(env, thiz);
+    if (mp)
+        libvlc_media_list_player_next(mp);
+}
+
+jint Java_org_videolan_vlc_LibVLC_getVolume(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_audio_get_volume(mp);
+    return -1;
+}
+
+jint Java_org_videolan_vlc_LibVLC_setVolume(JNIEnv *env, jobject thiz, jint volume)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        //Returns 0 if the volume was set, -1 if it was out of range or error
+        return (jint) libvlc_audio_set_volume(mp, (int) volume);
+    return -1;
+}
+#endif
+
+jlong Java_org_videolan_vlc_LibVLC_getTime(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_media_player_get_time(mp);
+    return -1;
+}
+
+void Java_org_videolan_vlc_LibVLC_setTime(JNIEnv *env, jobject thiz, jlong time)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_time(mp, time);
+}
+
+jfloat Java_org_videolan_vlc_LibVLC_getPosition(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jfloat) libvlc_media_player_get_position(mp);
+    return -1;
+}
+
+void Java_org_videolan_vlc_LibVLC_setPosition(JNIEnv *env, jobject thiz, jfloat pos)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        libvlc_media_player_set_position(mp, pos);
+}
+
+jlong Java_org_videolan_vlc_LibVLC_getLength(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jlong) libvlc_media_player_get_length(mp);
+    return -1;
+}
+
+jstring Java_org_videolan_vlc_LibVLC_version(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_version());
+}
+
+jstring Java_org_videolan_vlc_LibVLC_compiler(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_compiler());
+}
+
+jstring Java_org_videolan_vlc_LibVLC_changeset(JNIEnv* env, jobject thiz)
+{
+    return (*env)->NewStringUTF(env, libvlc_get_changeset());
+}
+
+#if 0
+jint Java_org_videolan_vlc_LibVLC_getAudioTracksCount(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_audio_get_track_count(mp);
+    return -1;
+}
+
+jobjectArray Java_org_videolan_vlc_LibVLC_getAudioTrackDescription(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (!mp)
+        return NULL;
+
+    int i_nbTracks = libvlc_audio_get_track_count(mp) - 1;
+    if (i_nbTracks < 0)
+        i_nbTracks = 0;
+    jobjectArray array = (*env)->NewObjectArray(env, i_nbTracks,
+            (*env)->FindClass(env, "java/lang/String"),
+            NULL);
+
+    libvlc_track_description_t *first = libvlc_audio_get_track_description(mp);
+    libvlc_track_description_t *desc = first != NULL ? first->p_next : NULL;
+    unsigned i;
+    for (i = 0; i < i_nbTracks; ++i)
+    {
+        jstring name = (*env)->NewStringUTF(env, desc->psz_name);
+        (*env)->SetObjectArrayElement(env, array, i, name);
+        desc = desc->p_next;
+    }
+    libvlc_track_description_list_release(first);
+    return array;
+}
+
+jint Java_org_videolan_vlc_LibVLC_getAudioTrack(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_audio_get_track(mp);
+    return -1;
+}
+
+jint Java_org_videolan_vlc_LibVLC_setAudioTrack(JNIEnv *env, jobject thiz, jint index)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_audio_set_track(mp, index);
+    return -1;
+}
+
+jint Java_org_videolan_vlc_LibVLC_getVideoTracksCount(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_video_get_track_count(mp);
+    return -1;
+}
+
+jobjectArray Java_org_videolan_vlc_LibVLC_getSpuTrackDescription(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (!mp)
+        return NULL;
+
+    int i_nbTracks = libvlc_video_get_spu_count(mp);
+    jobjectArray array = (*env)->NewObjectArray(env, i_nbTracks,
+            (*env)->FindClass(env, "java/lang/String"),
+            NULL);
+
+    libvlc_track_description_t *first = libvlc_video_get_spu_description(mp);
+    libvlc_track_description_t *desc = first;
+    unsigned i;
+    for (i = 0; i < i_nbTracks; ++i)
+    {
+        jstring name = (*env)->NewStringUTF(env, desc->psz_name);
+        (*env)->SetObjectArrayElement(env, array, i, name);
+        desc = desc->p_next;
+    }
+    libvlc_track_description_list_release(first);
+    return array;
+}
+
+jint Java_org_videolan_vlc_LibVLC_getSpuTracksCount(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return (jint) libvlc_video_get_spu_count(mp);
+    return -1;
+}
+
+jint Java_org_videolan_vlc_LibVLC_getSpuTrack(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_video_get_spu(mp);
+    return -1;
+}
+
+jint Java_org_videolan_vlc_LibVLC_setSpuTrack(JNIEnv *env, jobject thiz, jint index)
+{
+    libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
+    if (mp)
+        return libvlc_video_set_spu(mp, index);
+    return -1;
+}
+
+void Java_org_videolan_vlc_LibVLC_nativeReadDirectory(JNIEnv *env, jobject thiz, jstring path, jobject arrayList)
+{
+    jboolean isCopy;
+    /* Get C string */
+    const char* psz_path = (*env)->GetStringUTFChars(env, path, &isCopy);
+
+    DIR* p_dir = opendir(psz_path);
+    (*env)->ReleaseStringUTFChars(env, path, psz_path);
+    if(!p_dir)
+        return;
+
+    jclass arrayClass = (*env)->FindClass(env, "java/util/ArrayList");
+    jmethodID methodID = (*env)->GetMethodID(env, arrayClass, "add", "(Ljava/lang/Object;)Z");
+
+    struct dirent* p_dirent;
+    jstring str;
+    while(1) {
+        errno = 0;
+        p_dirent = readdir(p_dir);
+        if(p_dirent == NULL) {
+            if(errno > 0) /* error reading this entry */
+                continue;
+            else if(errno == 0) /* end of stream */
+                break;
+        }
+        str = (*env)->NewStringUTF(env, p_dirent->d_name);
+        (*env)->CallBooleanMethod(env, arrayList, methodID, str);
+        (*env)->DeleteLocalRef(env, str);
+    }
+    closedir(p_dir);
+}
+
+jboolean Java_org_videolan_vlc_LibVLC_nativeIsPathDirectory(JNIEnv *env, jobject thiz, jstring path)
+{
+    jboolean isCopy;
+    /* Get C string */
+    const char* psz_path = (*env)->GetStringUTFChars(env, path, &isCopy);
+
+    jboolean isDirectory;
+    struct stat buf;
+    if(stat(psz_path, &buf) != 0)
+        /* couldn't stat */
+        isDirectory = JNI_FALSE;
+    else {
+        if(S_ISDIR(buf.st_mode))
+            isDirectory = JNI_TRUE;
+        else
+            isDirectory = JNI_FALSE;
+    }
+
+    (*env)->ReleaseStringUTFChars(env, path, psz_path);
+    return isDirectory;
+}
+#endif
diff --git a/vlc-android/jni/libvlcjni_danmaku_events.inc.c b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
new file mode 100644
index 0000000..7b129ed
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_events.inc.c
@@ -0,0 +1,65 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_events.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+#define LIBVLCJNI_DANMAKU_INCLUDE_INC_C
+
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+extern JavaVM *myVm;
+
+static const libvlc_event_type_t md_events[] = {
+//        libvlc_MediaMetaChanged,
+//        libvlc_MediaSubItemAdded,
+        libvlc_MediaDurationChanged, //
+        libvlc_MediaParsedChanged, //
+//        libvlc_MediaFreed,
+        libvlc_MediaStateChanged, //
+        };
+
+static const libvlc_event_type_t mp_events[] = {
+//        libvlc_MediaPlayerMediaChanged,
+//        libvlc_MediaPlayerNothingSpecial,
+        libvlc_MediaPlayerOpening, //
+        libvlc_MediaPlayerBuffering, //
+        libvlc_MediaPlayerPlaying, //
+        libvlc_MediaPlayerPaused, //
+        libvlc_MediaPlayerStopped, //
+//        libvlc_MediaPlayerForward,
+//        libvlc_MediaPlayerBackward,
+        libvlc_MediaPlayerEndReached, //
+        libvlc_MediaPlayerEncounteredError, //
+//        libvlc_MediaPlayerTimeChanged,
+//        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerSeekableChanged, //
+        libvlc_MediaPlayerPausableChanged, //
+//        libvlc_MediaPlayerTitleChanged,
+//        libvlc_MediaPlayerSnapshotTaken,
+        libvlc_MediaPlayerLengthChanged, //
+//        libvlc_MediaPlayerVout,
+        libvlc_MediaPlayerBufferingTotal, //
+        libvlc_MediaPlayerModuleChanged, //
+        };
+
+#endif//LIBVLCJNI_DANMAKU_INCLUDE_INC_C
diff --git a/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
new file mode 100644
index 0000000..b93ad64
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
@@ -0,0 +1,61 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_nativeInitEx.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+#define LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
+
+void Java_org_videolan_vlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jboolean verbose, jarray arguments)
+{
+    libvlc_instance_t *instance = NULL;
+
+    verbosity = verbose;
+    libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
+
+    int user_argc = (*env)->GetArrayLength(env, arguments);
+    char **user_argv = (char **) calloc(user_argc, sizeof(char *));
+    int i = 0;
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            user_argv[i] = (char *) (*env)->GetStringUTFChars(env, argument, NULL);
+    }
+    instance = libvlc_new(user_argc, (const char **) user_argv);
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            (*env)->ReleaseStringUTFChars(env, argument, user_argv[i]);
+    }
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong)(intptr_t) instance);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+}
+
+#endif//LIBVLCJNI_DANMAKU_NATIVEINITEX_INC_C
diff --git a/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c
new file mode 100644
index 0000000..836c801
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c
@@ -0,0 +1,108 @@
+/*****************************************************************************
+ * libvlcjni_danmaku_readMediaEx.inc.c
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef LIBVLCJNI_DANMAKU_READMEDIAEX_INC_C
+#define LIBVLCJNI_DANMAKU_READMEDIAEX_INC_C
+
+void create_player_and_play_ex(JNIEnv *env, jobject thiz, jlong instance,
+        jobject gui, jstring mrl, jarray options) {
+    /* Release previous media player, if any */
+    releaseMediaPlayer(env, thiz);
+
+    /* Create a new item */
+    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, false);
+    if (!m) {
+        LOGE("readMediaEx: Could not create the media!");
+        return;
+    }
+
+    jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_player_t *mp = libvlc_media_player_new(
+            (libvlc_instance_t*) instance);
+
+    int user_argc = (*env)->GetArrayLength(env, options);
+    int i = 0;
+    LOGD("libvlc_media_add_option");
+    for (i = 0; i < user_argc; i++) {
+        jstring opt = (*env)->GetObjectArrayElement(env, options, i);
+        if (opt) {
+            const char* optString = (char *) (*env)->GetStringUTFChars(env, opt,
+                    NULL);
+            if (optString) {
+                LOGD("  %s", optString);
+                if (!strncmp(optString, ":aout=", 6)) {
+                    // seems ":aout" does not effect libvlc_media_add_option()
+                    const char* aout_name = optString + 6;
+                    if (!strncmp(aout_name, "audiotrack_java", 15)) {
+                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                        libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL,
+                                NULL, NULL, (void*) myJavaLibVLC);
+                        libvlc_audio_set_format_callbacks(mp, aout_open,
+                                aout_close);
+                    } else {
+                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                        libvlc_audio_output_set(mp, aout_name);
+                    }
+                } else {
+                    libvlc_media_add_option(m, optString);
+                }
+
+                (*env)->ReleaseStringUTFChars(env, opt, optString);
+            }
+        }
+    }
+
+    libvlc_media_player_set_vsl_callback(mp, gui, //
+            jvsl_load, //
+            jvsl_get_count, //
+            jvsl_get_mrl, //
+            jvsl_get_url, //
+            jvsl_get_duration, //
+            jvsl_get_bytes);
+
+    libvlc_media_player_set_media(mp, m);
+
+    /* No need to keep the media now */
+    libvlc_media_release(m);
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    for (i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    libvlc_media_t *md = libvlc_media_player_get_media(mp);
+    if (md) {
+        ev = libvlc_media_event_manager(md);
+        for (i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
+        }
+    }
+
+    /* Keep a pointer to this media player */
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)(intptr_t) mp);
+
+    libvlc_media_player_play(mp);
+}
+
+#endif//LIBVLCJNI_DANMAKU_READMEDIAEX_INC_C
-- 
1.7.10.4

