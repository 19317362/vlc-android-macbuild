From dafc7b0c5ccd0c11ea1ee65531bffdedde5590f2 Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Tue, 20 Mar 2012 18:28:35 +0800
Subject: [PATCH 4/4] libvlcjni support more event callback

---
 vlc-android/jni/libvlcjni.c                        |  229 ++++++++++++++++++--
 vlc-android/jni/log.h                              |    9 +-
 vlc-android/src/org/videolan/vlc/Aout.java         |    3 +-
 vlc-android/src/org/videolan/vlc/EventManager.java |   33 ++--
 vlc-android/src/org/videolan/vlc/LibVLC.java       |   37 ++--
 vlc-android/src/org/videolan/vlc/LibVlcEvent.java  |   22 ++
 vlc-android/src/tv/danmaku/util/DebugLog.java      |   75 +++++++
 7 files changed, 359 insertions(+), 49 deletions(-)
 create mode 100644 vlc-android/src/org/videolan/vlc/LibVlcEvent.java
 create mode 100644 vlc-android/src/tv/danmaku/util/DebugLog.java

diff --git a/vlc-android/jni/libvlcjni.c b/vlc-android/jni/libvlcjni.c
index abbff24..6d76f2f 100644
--- a/vlc-android/jni/libvlcjni.c
+++ b/vlc-android/jni/libvlcjni.c
@@ -39,6 +39,78 @@
 #define LOG_TAG "VLC/JNI/main"
 #include "log.h"
 
+/* Pointer to the Java virtual machine
+ * Note: It's okay to use a static variable for the VM pointer since there
+ * can only be one instance of this shared library in a single VM
+ */
+JavaVM *myVm;
+
+static const libvlc_event_type_t md_events[] = {
+//  libvlc_MediaMetaChanged,
+//  libvlc_MediaSubItemAdded,
+    libvlc_MediaDurationChanged,
+    libvlc_MediaParsedChanged,
+//  libvlc_MediaFreed,
+    libvlc_MediaStateChanged,
+};
+
+static const libvlc_event_type_t mp_events[] = {
+//        libvlc_MediaPlayerMediaChanged,
+//        libvlc_MediaPlayerNothingSpecial,
+    libvlc_MediaPlayerOpening,
+    libvlc_MediaPlayerBuffering,
+    libvlc_MediaPlayerPlaying,
+    libvlc_MediaPlayerPaused,
+    libvlc_MediaPlayerStopped,
+//        libvlc_MediaPlayerForward,
+//        libvlc_MediaPlayerBackward,
+    libvlc_MediaPlayerEndReached,
+    libvlc_MediaPlayerEncounteredError,
+//        libvlc_MediaPlayerTimeChanged,
+//        libvlc_MediaPlayerPositionChanged,
+    libvlc_MediaPlayerSeekableChanged,
+    libvlc_MediaPlayerPausableChanged,
+//        libvlc_MediaPlayerTitleChanged,
+//        libvlc_MediaPlayerSnapshotTaken,
+//        libvlc_MediaPlayerLengthChanged,
+//        libvlc_MediaPlayerVout,
+//
+//        libvlc_MediaListItemAdded,
+//        libvlc_MediaListWillAddItem,
+//        libvlc_MediaListItemDeleted,
+//        libvlc_MediaListWillDeleteItem,
+//
+//        libvlc_MediaListViewItemAdded,
+//        libvlc_MediaListViewWillAddItem,
+//        libvlc_MediaListViewItemDeleted,
+//        libvlc_MediaListViewWillDeleteItem,
+//
+//        libvlc_MediaListPlayerPlayed,
+//        libvlc_MediaListPlayerNextItemSet,
+//        libvlc_MediaListPlayerStopped,
+//
+//        libvlc_MediaDiscovererStarted,
+//        libvlc_MediaDiscovererEnded,
+//
+//        libvlc_VlmMediaAdded,
+//        libvlc_VlmMediaRemoved,
+//        libvlc_VlmMediaChanged,
+//        libvlc_VlmMediaInstanceStarted,
+//        libvlc_VlmMediaInstanceStopped,
+//        libvlc_VlmMediaInstanceStatusInit,
+//        libvlc_VlmMediaInstanceStatusOpening,
+//        libvlc_VlmMediaInstanceStatusPlaying,
+//        libvlc_VlmMediaInstanceStatusPause,
+//        libvlc_VlmMediaInstanceStatusEnd,
+//        libvlc_VlmMediaInstanceStatusError
+};
+
+void setInt(JNIEnv *env, jobject item, const char* field, int value);
+void setLong(JNIEnv *env, jobject item, const char* field, int64_t value);
+void setFloat(JNIEnv *env, jobject item, const char* field, float value);
+void setString(JNIEnv *env, jobject item, const char* field, const char* value);
+static void vlc_event_callback(const libvlc_event_t *ev, void *data);
+
 libvlc_media_t *new_media(jint instance, JNIEnv *env, jobject thiz, jstring filePath)
 {
     libvlc_instance_t *libvlc = (libvlc_instance_t*)instance;
@@ -86,21 +158,42 @@ static void unsetMediaPlayer(JNIEnv *env, jobject thiz)
 
 static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
 {
+    LOGD("releaseMediaPlayer");
     libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
     if (mp)
     {
+        LOGD("releaseMediaPlayer:mp");
+        size_t i = 0;
+        libvlc_event_manager_t *em;
+        libvlc_media_t *md = libvlc_media_player_get_media(mp);
+        if (md) {
+            LOGD("releaseMediaPlayer:md_events");
+            em = libvlc_media_event_manager(md);
+            if (!em) {
+                LOGD("releaseMediaPlayer:md_event_manager is null");
+            }
+            for (i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+                LOGV("detach:%x,%d,%x,%x", em, md_events[i], vlc_event_callback, myVm);
+                libvlc_event_detach(em, md_events[i], vlc_event_callback, myVm);
+            }
+        }
+
+        LOGD("releaseMediaPlayer:mp_events");
+        em = libvlc_media_player_event_manager(mp);
+        if (!em) {
+            LOGD("releaseMediaPlayer:mp_event_manager is null");
+        }
+        for (i = 0; i < sizeof(mp_events) / sizeof(*mp_events); i++) {
+            LOGV("detach:%x,%d,%x,%x", em, mp_events[i], vlc_event_callback, myVm);
+            libvlc_event_detach(em, mp_events[i], vlc_event_callback, myVm);
+        }
+
         libvlc_media_player_stop(mp);
         libvlc_media_player_release(mp);
         unsetMediaPlayer(env, thiz);
     }
 }
 
-/* Pointer to the Java virtual machine
- * Note: It's okay to use a static variable for the VM pointer since there
- * can only be one instance of this shared library in a single VM
- */
-JavaVM *myVm;
-
 static jobject eventManagerInstance = NULL;
 
 static pthread_mutex_t vout_android_lock;
@@ -133,6 +226,11 @@ void jni_SetAndroidSurfaceSize(int width, int height)
     (*myVm)->DetachCurrentThread (myVm);
 }
 
+static void vlc_event_set_int(JNIEnv *env, jobject item, int value);
+static void vlc_event_set_long(JNIEnv *env, jobject item, int64_t value);
+static void vlc_event_set_float(JNIEnv *env, jobject item, float value);
+static void vlc_event_set_string(JNIEnv *env, jobject item, const char* value);
+
 static void vlc_event_callback(const libvlc_event_t *ev, void *data)
 {
     JNIEnv *env;
@@ -148,8 +246,10 @@ static void vlc_event_callback(const libvlc_event_t *ev, void *data)
         LOGD("vlc_event_callback: failed to get JNI environment, "
              "assuming native thread");
         status = (*myVm)->AttachCurrentThread(myVm, &env, NULL);
-        if (status < 0)
+        if (status < 0) {
+            LOGD("vlc_event_callback: failed to attach thread");
             return;
+        }
         isAttached = true;
     }
 
@@ -160,15 +260,54 @@ static void vlc_event_callback(const libvlc_event_t *ev, void *data)
         goto end;
     }
 
+    jobject eventObject = NULL;
+
+    /* Find the callback ID */
+    jmethodID methodObtain = (*env)->GetMethodID(env, cls, "obtainEventObject", "()Lorg/videolan/vlc/LibVlcEvent;");
+    if (methodObtain) {
+        eventObject = (*env)->CallObjectMethod(env, eventManagerInstance, methodObtain);
+        if (eventObject == NULL) {
+            LOGE("EventManager: failed to obtainEventObject");
+            goto end;
+        }
+    } else {
+        LOGE("EventManager: failed to get the obtainEventObject method");
+        goto end;
+    }
+
+    setInt(env, eventObject, "mEventType", (int)ev->type);
+
+    switch (ev->type) {
+    case libvlc_MediaPlayerBuffering: {
+        float cache = ev->u.media_player_buffering.new_cache;
+        vlc_event_set_float(env, eventObject, cache);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int seekable = ev->u.media_player_seekable_changed.new_seekable;
+        vlc_event_set_int(env, eventObject, seekable);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int pausable = ev->u.media_player_pausable_changed.new_pausable;
+        vlc_event_set_int(env, eventObject, pausable);
+        break;
+    }
+    }
+
     /* Find the callback ID */
-    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(I)V");
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILorg/videolan/vlc/LibVlcEvent;)V");
     if (methodID) {
-        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type);
+        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type, eventObject);
     } else {
         LOGE("EventManager: failed to get the callback method");
+        goto end;
     }
 
 end:
+    if (eventObject)
+        (*env)->DeleteLocalRef(env, eventObject);
+
     if (isAttached)
         (*myVm)->DetachCurrentThread(myVm);
 }
@@ -256,7 +395,7 @@ void Java_org_videolan_vlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jarray
         }
     }
     else {
-    	instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
+        instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
     }
 
     jclass clazz = (*env)->GetObjectClass(env, thiz);
@@ -359,7 +498,7 @@ void Java_org_videolan_vlc_LibVLC_setEventManager(JNIEnv *env, jobject thiz, job
         return;
     }
 
-    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(I)V");
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILorg/videolan/vlc/LibVlcEvent;)V");
     if (!methodID) {
         LOGE("setEventManager: failed to get the callback method");
         return;
@@ -384,6 +523,38 @@ void setInt(JNIEnv *env, jobject item, const char* field, int value)
     (*env)->SetIntField(env, item, fieldId, value);
 }
 
+void setLong(JNIEnv *env, jobject item, const char* field, int64_t value)
+{
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "J");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetLongField(env, item, fieldId, value);
+}
+
+void setFloat(JNIEnv *env, jobject item, const char* field, float value)
+{
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "F");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetFloatField(env, item, fieldId, value);
+}
+
 void setString(JNIEnv *env, jobject item, const char* field, const char* text)
 {
     jclass cls;
@@ -481,15 +652,20 @@ void Java_org_videolan_vlc_LibVLC_readMedia(JNIEnv *env, jobject thiz,
 
     /* Connect the event manager */
     libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
-    static const libvlc_event_type_t mp_events[] = {
-        libvlc_MediaPlayerPlaying,
-        libvlc_MediaPlayerPaused,
-        libvlc_MediaPlayerEndReached,
-        libvlc_MediaPlayerStopped,
-    };
     int i;
-    for (i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
+    for (i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i) {
+        LOGV("attach:%x,%d,%x,%x", ev, mp_events[i], vlc_event_callback, myVm);
         libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+    }
+
+    libvlc_media_t *md = libvlc_media_player_get_media(mp);
+    if (md) {
+        ev = libvlc_media_event_manager(md);
+        for (i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+            LOGV("attach:%x,%d,%x,%x", ev, md_events[i], vlc_event_callback, myVm);
+            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
+        }
+    }
 
     /* Keep a pointer to this media player */
     jclass clazz = (*env)->GetObjectClass(env, thiz);
@@ -835,3 +1011,20 @@ jint Java_org_videolan_vlc_LibVLC_getSpuTracksCount(JNIEnv *env, jobject thiz)
     return -1;
 }
 
+
+
+static void vlc_event_set_int(JNIEnv *env, jobject item, int value) {
+    setInt(env, item, "mIntValue", value);
+}
+
+static void vlc_event_set_long(JNIEnv *env, jobject item, int64_t value) {
+    setLong(env, item, "mLongValue", value);
+}
+
+static void vlc_event_set_float(JNIEnv *env, jobject item, float value) {
+    setFloat(env, item, "mFloatValue", value);
+}
+
+static void vlc_event_set_string(JNIEnv *env, jobject item, const char* value) {
+    setString(env, item, "mStringValue", value);
+}
diff --git a/vlc-android/jni/log.h b/vlc-android/jni/log.h
index f82fbcd..839646b 100644
--- a/vlc-android/jni/log.h
+++ b/vlc-android/jni/log.h
@@ -28,7 +28,14 @@
 # error You must define LOG_TAG
 #endif
 
-#ifndef NDEBUG
+#ifdef NDEBUG
+# define DISABLE_VLC_JNI_LOG
+#else
+/* comment this line to enable log */
+//# define DISABLE_VLC_JNI_LOG
+#endif
+
+#ifndef DISABLE_VLC_JNI_LOG
 # define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
 # define LOGV(...)  __android_log_print(ANDROID_LOG_VERBOSE,LOG_TAG,__VA_ARGS__)
 #else
diff --git a/vlc-android/src/org/videolan/vlc/Aout.java b/vlc-android/src/org/videolan/vlc/Aout.java
index 740bb83..7bddac3 100644
--- a/vlc-android/src/org/videolan/vlc/Aout.java
+++ b/vlc-android/src/org/videolan/vlc/Aout.java
@@ -20,6 +20,7 @@
 
 package org.videolan.vlc;
 
+import tv.danmaku.util.DebugLog;
 import android.util.Log;
 import android.media.AudioFormat;
 import android.media.AudioManager;
@@ -40,7 +41,7 @@ public class Aout {
     private static final String TAG = "LibVLC/aout";
 
     public void init(int sampleRateInHz, int channels, int samples) {
-        Log.d(TAG, sampleRateInHz + ", " + channels + ", " + samples + "=>" + channels * samples);
+        DebugLog.d(TAG, sampleRateInHz + ", " + channels + ", " + samples + "=>" + channels * samples);
         int minBufferSize = AudioTrack.getMinBufferSize(sampleRateInHz,
                                                         AudioFormat.CHANNEL_CONFIGURATION_STEREO,
                                                         AudioFormat.ENCODING_PCM_16BIT);
diff --git a/vlc-android/src/org/videolan/vlc/EventManager.java b/vlc-android/src/org/videolan/vlc/EventManager.java
index 24fe4f4..ce9b0aa 100644
--- a/vlc-android/src/org/videolan/vlc/EventManager.java
+++ b/vlc-android/src/org/videolan/vlc/EventManager.java
@@ -22,7 +22,6 @@ package org.videolan.vlc;
 
 import java.util.ArrayList;
 
-import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 
@@ -34,26 +33,26 @@ public class EventManager {
 
     //public static final int MediaMetaChanged                = 0;
     //public static final int MediaSubItemAdded               = 1;
-    //public static final int MediaDurationChanged            = 2;
-    //public static final int MediaParsedChanged              = 3;
+    public static final int MediaDurationChanged            = 2;
+    public static final int MediaParsedChanged              = 3;
     //public static final int MediaFreed                      = 4;
-    //public static final int MediaStateChanged               = 5;
+    public static final int MediaStateChanged               = 5;
 
     //public static final int MediaPlayerMediaChanged         = 0x100;
     //public static final int MediaPlayerNothingSpecial       = 0x101;
-    //public static final int MediaPlayerOpening              = 0x102;
-    //public static final int MediaPlayerBuffering            = 0x103;
+    public static final int MediaPlayerOpening              = 0x102;
+    public static final int MediaPlayerBuffering            = 0x103;
     public static final int MediaPlayerPlaying = 0x104;
     public static final int MediaPlayerPaused = 0x105;
     public static final int MediaPlayerStopped = 0x106;
     //public static final int MediaPlayerForward              = 0x107;
     //public static final int MediaPlayerBackward             = 0x108;
     public static final int MediaPlayerEndReached = 0x109;
-    //public static final int MediaPlayerEncounteredError     = 0x10a;
+    public static final int MediaPlayerEncounteredError     = 0x10a;
     //public static final int MediaPlayerTimeChanged          = 0x10b;
     //public static final int MediaPlayerPositionChanged      = 0x10c;
-    //public static final int MediaPlayerSeekableChanged      = 0x10d;
-    //public static final int MediaPlayerPausableChanged      = 0x10e;
+    public static final int MediaPlayerSeekableChanged      = 0x10d;
+    public static final int MediaPlayerPausableChanged      = 0x10e;
     //public static final int MediaPlayerTitleChanged         = 0x10f;
     //public static final int MediaPlayerSnapshotTaken        = 0x110;
     //public static final int MediaPlayerLengthChanged        = 0x111;
@@ -111,13 +110,15 @@ public class EventManager {
     }
 
     /** This method is called by a native thread **/
-    public void callback(int event) {
-        Bundle b = new Bundle();
-        b.putInt("event", event);
-        for (int i = 0; i < mEventHandler.size(); i++) {
-            Message msg = Message.obtain();
-            msg.setData(b);
-            mEventHandler.get(i).sendMessage(msg);
+    public void callback(int event, LibVlcEvent eventObject) {
+        for (Handler handler: mEventHandler) {
+            Message msg = handler.obtainMessage(event, eventObject);
+            handler.sendMessage(msg);
         }
     }
+    
+    /** This method is called by a native thread **/
+    public LibVlcEvent obtainEventObject() {
+        return new LibVlcEvent();
+    }
 }
diff --git a/vlc-android/src/org/videolan/vlc/LibVLC.java b/vlc-android/src/org/videolan/vlc/LibVLC.java
index 50b95ad..d41ad51 100644
--- a/vlc-android/src/org/videolan/vlc/LibVLC.java
+++ b/vlc-android/src/org/videolan/vlc/LibVLC.java
@@ -22,7 +22,8 @@ package org.videolan.vlc;
 
 import org.videolan.vlc.LibVlcException;
 
-import android.util.Log;
+import tv.danmaku.util.DebugLog;
+
 import android.view.Surface;
 import android.preference.PreferenceManager;
 import android.content.Context;
@@ -31,6 +32,7 @@ import android.os.Build;
 public class LibVLC {
     private static final String TAG = "VLC/LibVLC";
 
+    private static boolean mLibLoaded = false;
     private static LibVLC sInstance;
     private static boolean sUseIomx = false;
 
@@ -51,23 +53,29 @@ public class LibVLC {
     public native void detachSurface();
 
     /* Load library before object instantiation */
-    static {
+    
+    public static void loadLib() {
+        if (mLibLoaded)
+            return;
+        
         try {
             if (Build.VERSION.SDK_INT <= 10)
                 System.loadLibrary("iomx-gingerbread");
             else /* No honeycomb build for now */
                 System.loadLibrary("iomx-ics");
         } catch (Throwable t) {
-            Log.w(TAG, "Unable to load the iomx library: " + t);
+            DebugLog.w(TAG, "Unable to load the iomx library: " + t);
         }
         try {
             System.loadLibrary("vlcjni");
+            DebugLog.d(TAG, "vlcjni loaded: ");
+            mLibLoaded = true;
         } catch (UnsatisfiedLinkError ule) {
-            Log.e(TAG, "Can't load vlcjni library: " + ule);
+            DebugLog.e(TAG, "Can't load vlcjni library: " + ule);
             /// FIXME Alert user
             System.exit(1);
         } catch (SecurityException se) {
-            Log.e(TAG, "Encountered a security issue when loading vlcjni library: " + se);
+            DebugLog.e(TAG, "Encountered a security issue when loading vlcjni library: " + se);
             /// FIXME Alert user
             System.exit(1);
         }
@@ -83,6 +91,7 @@ public class LibVLC {
     public static LibVLC getInstance() throws LibVlcException {
         if (sInstance == null) {
             /* First call */
+            loadLib();
             sInstance = new LibVLC();
             sInstance.initEx(null);
         }
@@ -102,6 +111,8 @@ public class LibVLC {
     }
 
     public static LibVLC createInstance(String[] params) throws LibVlcException {
+        loadLib();
+
         LibVLC newInstance = new LibVLC();
         newInstance.initEx(params);
 
@@ -123,7 +134,7 @@ public class LibVLC {
      */
     public void finalize() {
         if (mLibVlcInstance != 0) {
-            Log.d(TAG, "LibVLC is was destroyed yet before finalize()");
+            DebugLog.d(TAG, "LibVLC is was destroyed yet before finalize()");
             destroy();
         }
     }
@@ -153,7 +164,7 @@ public class LibVLC {
      * Initialize the libVLC class
      */
     private void initEx(String[] params) throws LibVlcException {
-        Log.v(TAG, "Initializing LibVLC");
+        DebugLog.v(TAG, "Initializing LibVLC");
         if (!mIsInitialized) {
             nativeInitEx(params);
             setEventManager(EventManager.getIntance());
@@ -166,7 +177,7 @@ public class LibVLC {
      * @note You must call it before exiting
      */
     public void destroy() {
-        Log.v(TAG, "Destroying LibVLC instance");
+        DebugLog.v(TAG, "Destroying LibVLC instance");
         nativeDestroy();
         detachEventManager();
         mIsInitialized = false;
@@ -177,7 +188,7 @@ public class LibVLC {
      * This function is called by the native code
      */
     public void initAout(int sampleRateInHz, int channels, int samples) {
-        Log.d(TAG, "Opening the java audio output");
+        DebugLog.d(TAG, "Opening the java audio output");
         mAout.init(sampleRateInHz, channels, samples);
     }
 
@@ -194,7 +205,7 @@ public class LibVLC {
      * This function is called by the native code
      */
     public void closeAout() {
-        Log.d(TAG, "Closing the java audio output");
+        DebugLog.d(TAG, "Closing the java audio output");
         mAout.release();
     }
 
@@ -202,7 +213,7 @@ public class LibVLC {
      * Read a media.
      */
     public void readMedia(String mrl) {
-        Log.v(TAG, "Reading " + mrl);
+        DebugLog.v(TAG, "Reading " + mrl);
         readMedia(mLibVlcInstance, mrl);
     }
 
@@ -229,7 +240,7 @@ public class LibVLC {
     }
 
     /**
-     * Return the length of the stream, in milliseconds
+     * Return true if there is a video track in the file
      */
     public long getLengthFromFile(String filePath) {
         return getLengthFromFile(mLibVlcInstance, filePath);
@@ -372,7 +383,7 @@ public class LibVLC {
     public native int getSpuTracksCount();
 
     /**
-     * Return the length of the stream, in milliseconds
+     * Return true if there is a video track in the file
      */
     private native long getLengthFromFile(int instance, String filePath);
 
diff --git a/vlc-android/src/org/videolan/vlc/LibVlcEvent.java b/vlc-android/src/org/videolan/vlc/LibVlcEvent.java
new file mode 100644
index 0000000..7214f1c
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/LibVlcEvent.java
@@ -0,0 +1,22 @@
+package org.videolan.vlc;
+
+public class LibVlcEvent {
+    public int mEventType;
+    
+    public int mIntValue;
+    public long mLongValue;
+    public float mFloatValue;
+    public String mStringValue;
+    
+    public boolean getMediaPlayerSeekableChanged_isSeekable() {
+        return mIntValue != 0;
+    }
+    
+    public boolean getMediaPlayerPausableChanged_isPausable() {
+        return mIntValue != 0;
+    }
+    
+    public float getMediaPlayerBuffering_percent() {
+        return mFloatValue;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/DebugLog.java b/vlc-android/src/tv/danmaku/util/DebugLog.java
new file mode 100644
index 0000000..f6527ac
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/DebugLog.java
@@ -0,0 +1,75 @@
+package tv.danmaku.util;
+
+import android.util.Log;
+
+public class DebugLog {
+
+    public static boolean ENABLE_ERROR = true;
+    public static boolean ENABLE_WARN = true;
+    public static boolean ENABLE_DEBUG = true;
+    public static boolean ENABLE_VERBOSE = true;
+
+    public static int e(String tag, String msg) {
+        if (ENABLE_ERROR) {
+            return Log.e(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int e(String tag, String msg, Throwable tr) {
+        if (ENABLE_ERROR) {
+            return Log.e(tag, msg, tr);
+        }
+
+        return 0;
+    }
+    
+    public static int w(String tag, String msg) {
+        if (ENABLE_WARN) {
+            return Log.w(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int w(String tag, String msg, Throwable tr) {
+        if (ENABLE_WARN) {
+            return Log.w(tag, msg, tr);
+        }
+
+        return 0;
+    }
+
+    public static int d(String tag, String msg) {
+        if (ENABLE_DEBUG) {
+            return Log.d(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int d(String tag, String msg, Throwable tr) {
+        if (ENABLE_DEBUG) {
+            return Log.d(tag, msg, tr);
+        }
+
+        return 0;
+    }
+
+    public static int v(String tag, String msg) {
+        if (ENABLE_VERBOSE) {
+            return Log.v(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int v(String tag, String msg, Throwable tr) {
+        if (ENABLE_VERBOSE) {
+            return Log.v(tag, msg, tr);
+        }
+
+        return 0;
+    }
+}
-- 
1.7.7.4

