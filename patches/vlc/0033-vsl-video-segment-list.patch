From 29af5d0c0cbb2cd2ef93a5512361375090bc47fc Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Tue, 4 Sep 2012 17:52:55 +0800
Subject: [PATCH 33/33] vsl: video segment list

---
 modules/access/vsl/index.c   |  879 ++++++++++++++++++++++++++++++++++++++++++
 modules/access/vsl/segment.c |  814 ++++++++++++++++++++++++++++++++++++++
 modules/access/vsl/vsl.c     |  189 ++++-----
 modules/access/vsl/vsl.h     |   66 ++--
 4 个文件被修改，插入 1801 行(+)，删除 147 行(-)
 create mode 100644 modules/access/vsl/index.c
 create mode 100644 modules/access/vsl/segment.c

diff --git a/modules/access/vsl/index.c b/modules/access/vsl/index.c
new file mode 100644
index 0000000..39de4e3
--- /dev/null
+++ b/modules/access/vsl/index.c
@@ -0,0 +1,879 @@
+/*****************************************************************************
+ * index.c: video segment list index access
+ *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
+ *
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc/libvlc_structures.h>
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_threads.h>
+#include <vlc_access.h>
+#include <vlc_demux.h>
+#include <vlc_block.h>
+#include <vlc_input.h>
+#include <vlc_es_out_managed.h>
+#include <assert.h>
+
+/* FIXME */
+#include "../../../src/input/demux.h"
+#include "../../../src/input/event.h"
+#include "../../../src/input/es_out.h"
+
+#include "vsl.h"
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+static int  Open ( vlc_object_t * );
+static void Close( vlc_object_t * );
+
+vlc_module_begin ()
+    set_shortname( N_("vslindex") )
+    set_description( N_("video segment list index access demux") )
+    set_category( CAT_INPUT )
+    set_subcategory( SUBCAT_INPUT_ACCESS )
+    set_capability( "access_demux", 100 )
+    add_shortcut( ACCESS_VSL_INDEX, ACCESS_SINA_INDEX,
+                  ACCESS_YOUKU_INDEX, ACCESS_CNTV_INDEX,
+                  ACCESS_SOHU_INDEX )
+    set_callbacks( Open, Close )
+vlc_module_end ()
+
+/*****************************************************************************
+ * Documentation
+ *  example: http://v.iask.com/v_play.php?vid=71442057
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+typedef struct
+{
+    /* will not change after parsed */
+    int             i_order;
+    int64_t         i_duration_micro;   /* (microsecond) */
+    int64_t         i_start_time_micro; /* (microsecond) */
+    char            *p_mrl;
+
+    /* segment data */
+    vlc_mutex_t     lock;
+
+    stream_t        *p_stream;          /* segment stream */
+    demux_t         *p_demux;           /* segment demux */
+
+    stream_t        *p_origin_stream;   /* weak referece */
+    stream_t        *p_membuf_filter;   /* weak referece */
+} vsl_segment_t;
+
+typedef struct
+{
+    vlc_array_t     *p_segment_array;       /* list of segments */
+    int64_t         i_total_duration_micro; /* (microsecond) */
+} vsl_index_t;
+
+struct demux_sys_t
+{
+    vsl_cb_t        cb;
+
+    /* */
+    vlc_mutex_t     lock;
+    vsl_index_t     *p_index;
+
+    vsl_segment_t   *p_segment;     /* current playing segment, weak reference */
+    int             i_last_total_cached_percent;
+
+    /* */
+    es_out_t        *p_out_managed; /* passed to sub demux */
+
+    bool            b_segment_changed;
+};
+
+static int Control( demux_t *p_demux, int i_query, va_list args );
+static int Demux( demux_t *p_demux );
+
+static demux_sys_t *vsl_Alloc( void );
+static void         vsl_Free( demux_sys_t* p_sys);
+
+static vsl_index_t *vsl_OpenIndex( demux_t *p_demux, demux_sys_t *p_sys );
+static int vsl_AssureOpenSegment( demux_t *p_demux, int i_demux );
+
+#define msg_VslDebug msg_Err
+
+/****************************************************************************
+ * Module Open/Close
+ ****************************************************************************/
+static int Open( vlc_object_t *p_this )
+{
+    demux_t     *p_demux = (demux_t*) p_this;
+    demux_sys_t *p_sys = NULL;
+
+    msg_Dbg( p_demux, "Open:check access: %s", p_demux->psz_access );
+    if( !p_demux->psz_access || !*p_demux->psz_access )
+        goto EXIT_ERROR;
+
+    msg_Dbg( p_demux, "Open:check location: %s", p_demux->psz_location );
+    if( !p_demux->psz_location || !*p_demux->psz_location )
+        goto EXIT_ERROR;
+
+    /* Init p_demux */
+    p_sys = vsl_Alloc();
+    if( !p_sys )
+        goto EXIT_ERROR;
+
+    if( VLC_SUCCESS != vsl_cbGetCallbacks( VLC_OBJECT( p_demux ), &p_sys->cb ) )
+        goto EXIT_ERROR;
+
+    msg_Dbg( p_demux, "Open:vsl_OpenIndex" );
+    p_sys->p_index = vsl_OpenIndex( p_demux, p_sys );
+    if( !p_sys->p_index )
+    {
+        msg_Err( p_demux, "vsl failed to open index" );
+        goto EXIT_ERROR;
+    }
+
+    assert( p_sys->p_index );
+    assert( p_sys->p_index->p_segment_array );
+    assert( vlc_array_count( p_sys->p_index->p_segment_array ) > 0 );
+
+    msg_Dbg( p_demux, "Open:demux_EsOutManagedNew" );
+    p_sys->p_out_managed = demux_EsOutManagedNew( p_demux, p_demux->out );
+
+    p_demux->p_sys = p_sys;
+    msg_Dbg( p_demux, "Open:vsl_AssureOpenSegment" );
+    if( VLC_SUCCESS != vsl_AssureOpenSegment( p_demux, 0 ) )
+    {
+        msg_Err( p_demux, "failed to open demux for head segment" );
+        goto EXIT_ERROR;
+    }
+
+    p_demux->pf_control = Control;
+    p_demux->pf_demux = Demux;
+
+    msg_Dbg( p_demux, "Open:succeeded" );
+    return VLC_SUCCESS;
+
+EXIT_ERROR:
+    if( p_sys )
+    {
+        if( p_sys->p_out_managed )
+            es_out_Delete( p_sys->p_out_managed );
+        vsl_Free(p_sys);
+    }
+    p_demux->p_sys = NULL;
+
+    return VLC_EGENERIC;
+}
+
+static void Close(vlc_object_t *p_this)
+{
+    demux_t *p_demux = (demux_t *) p_this;
+    demux_sys_t *p_sys = p_demux->p_sys;
+
+    vsl_Free(p_sys);
+}
+
+/****************************************************************************
+ * Open/Close
+ ****************************************************************************/
+static vsl_segment_t *vsl_AllocSegment()
+{
+    vsl_segment_t *p_segment = (vsl_segment_t *)malloc( sizeof(vsl_segment_t) );
+    if( !p_segment )
+        return NULL;
+    memset( p_segment, 0, sizeof(vsl_segment_t) );
+
+    vlc_mutex_init( &p_segment->lock );
+
+    return p_segment;
+}
+
+static void vsl_FreeSegment( vsl_segment_t *p_segment )
+{
+    if( !p_segment )
+        return;
+
+    if( p_segment->p_demux )
+        demux_Delete( p_segment->p_demux );
+
+    if( p_segment->p_stream )
+        stream_Delete( p_segment->p_stream );
+
+    VSL_SAFE_FREE( p_segment->p_mrl );
+
+    vlc_mutex_destroy( &p_segment->lock );
+    VSL_SAFE_FREE( p_segment );
+}
+
+static void vsl_FreeSegmentArray( vlc_array_t *p_segment_array )
+{
+    if( !p_segment_array )
+        return;
+
+    int count = vlc_array_count( p_segment_array );
+    for(int i = 0; i < count; ++i )
+    {
+        vsl_segment_t *p_segment = (vsl_segment_t *) vlc_array_item_at_index( p_segment_array, i );
+        if( p_segment )
+        {
+            vsl_FreeSegment( p_segment );
+        }
+    }
+
+    vlc_array_destroy( p_segment_array );
+}
+
+static vsl_index_t *vsl_AllocIndex()
+{
+    vsl_index_t *p_index = (vsl_index_t *) malloc( sizeof( vsl_index_t ) );
+    if( !p_index )
+        return NULL;
+
+    memset( p_index, 0, sizeof( vsl_index_t ) );
+    return p_index;
+}
+
+static void vsl_FreeIndex( vsl_index_t *p_index )
+{
+    if( !p_index )
+        return;
+
+    vlc_array_t *p_segment_array = p_index->p_segment_array;
+    if( p_segment_array )
+        vsl_FreeSegmentArray( p_segment_array );
+
+    VSL_SAFE_FREE( p_index );
+}
+
+static demux_sys_t *vsl_Alloc()
+{
+    demux_sys_t *p_sys = (demux_sys_t *) malloc( sizeof( demux_sys_t ) );
+    if (!p_sys)
+        return NULL;
+    memset( p_sys, 0, sizeof( demux_sys_t ) );
+
+    vlc_mutex_init( &p_sys->lock );
+
+    return p_sys;
+}
+
+static void vsl_Free( demux_sys_t* p_sys )
+{
+    if( !p_sys )
+        return;
+
+    if( p_sys->p_out_managed )
+        es_out_Delete( p_sys->p_out_managed );
+
+    if( p_sys->p_index)
+        vsl_FreeIndex( p_sys->p_index );
+
+    VSL_SAFE_FREE( p_sys );
+}
+
+/****************************************************************************
+ * Resolve
+ ****************************************************************************/
+static vsl_index_t *vsl_OpenIndex( demux_t *p_demux, demux_sys_t *p_sys )
+{
+    vsl_cb_t *p_cb = &p_sys->cb;
+    vlc_array_t *p_segment_array = NULL;
+    vsl_index_t *p_index = NULL;
+    int i_count = 0;
+
+    msg_Dbg( p_demux, "vsl_cbLoad" );
+    if( VLC_SUCCESS != vsl_cbLoad( p_cb, true ) )
+    {
+        msg_Err( p_demux, "vsl_cbLoad: failed" );
+        goto EXIT_ERROR;
+    }
+
+    p_index = vsl_AllocIndex();
+    if( !p_index )
+        goto EXIT_ERROR;
+
+    p_segment_array = vlc_array_new();
+    if( !p_segment_array )
+        goto EXIT_ERROR;
+    p_index->p_segment_array = p_segment_array;
+
+    msg_Dbg( p_demux, "vsl_cbGetCount" );
+    i_count = vsl_cbGetCount( p_cb );
+    if( i_count <= 0 )
+    {
+        msg_Err( p_demux, "0 segments?" );
+        goto EXIT_ERROR;
+    }
+    msg_Dbg( p_demux, "vsl_cbGetCount: %d", i_count );
+
+    for( int i = 0; i < i_count; ++i )
+    {
+        vsl_segment_t *p_segment = vsl_AllocSegment();
+        if( !p_segment_array )
+            goto EXIT_ERROR;
+
+        p_segment->i_order = i;
+        p_segment->p_mrl = vsl_cbGetMrl( p_cb, i );
+        p_segment->i_duration_micro = vsl_cbGetDuration( p_cb, i ) * 1000;
+        p_segment->i_start_time_micro = p_index->i_total_duration_micro;
+
+        p_index->i_total_duration_micro += p_segment->i_duration_micro;
+
+        msg_Dbg( p_demux, "vsl_cbGetSegment: %d, %d, %s",
+                p_segment->i_order,
+                (int) p_segment->i_duration_micro,
+                p_segment->p_mrl ? p_segment->p_mrl : "NULL");
+
+        vlc_array_append( p_segment_array, p_segment );
+        if( !p_segment->p_mrl || !*p_segment->p_mrl )
+        {
+            msg_Err( p_demux, "empty segment mrl" );
+            goto EXIT_ERROR;
+        }
+    }
+
+    return p_index;
+EXIT_ERROR:
+    if( p_index )
+        vsl_FreeIndex( p_index );
+
+    return NULL;
+}
+
+/****************************************************************************
+ * Demux
+ ****************************************************************************/
+static int vsl_AssureOpenSegment( demux_t *p_demux, int i_segment )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys );
+
+    int i_playing_segment = 0;
+    if( p_sys->p_segment )
+        i_playing_segment = p_sys->p_segment->i_order;
+
+    assert( p_sys->p_index );
+    vlc_array_t *p_segment_array = p_sys->p_index->p_segment_array;
+    assert( p_segment_array );
+
+    if( p_sys->p_segment )
+    {
+        if( i_playing_segment == i_segment )
+        {   /* Same segment, just return */
+            return VLC_SUCCESS;
+        }
+        else
+        {   /* Different segment, close current */
+            msg_Info( p_demux, "vsl_AssureOpenSegment: change segment" );
+            if( p_sys->p_segment->p_demux )
+            {
+                demux_Delete( p_sys->p_segment->p_demux );
+                p_sys->p_segment->p_demux = NULL;
+
+                /* Reset PCR before use next demux */
+                // es_out_Control( p_demux->out, ES_OUT_RESET_PCR );
+                //if( p_sys->p_out_managed )
+                //    es_out_Control( p_sys->p_out_managed, ES_OUT_POST_DISCONTINUITY );
+            }
+            if( p_sys->p_segment->p_stream )
+            {
+                stream_Delete( p_sys->p_segment->p_stream );
+                p_sys->p_segment->p_stream = NULL;
+            }
+
+            p_sys->b_segment_changed = true;
+        }
+    }
+    else
+    {
+        msg_Info( p_demux, "vsl_AssureOpenSegment: new segment" );
+    }
+
+    /* Open new segment */
+    input_thread_t *p_parent_input = demux_GetParentInput( p_demux );
+    assert( p_parent_input );
+
+    int i_segment_count = vlc_array_count( p_segment_array );
+    if( i_segment < 0 || i_segment > i_segment_count )
+    {
+        msg_Err( p_demux, "vsl_AssureOpenSegment: invalid segment %d", i_segment );
+        return VLC_EGENERIC;
+    }
+
+    vsl_segment_t *p_new_segment = (vsl_segment_t *) vlc_array_item_at_index( p_segment_array, i_segment );
+    assert( p_new_segment );
+
+    if( !p_new_segment->p_stream )
+    {
+        /* Create segment stream */
+        msg_Info( p_demux, "vsl open segment stream %d", p_new_segment->i_order );
+
+        stream_t *p_stream = stream_UrlNew( p_demux, p_new_segment->p_mrl );
+        if( !p_stream )
+        {
+            msg_Err( p_demux, "failed to open stream %s", p_new_segment->p_mrl );
+            return VLC_EGENERIC;
+        }
+
+        p_new_segment->p_origin_stream = p_stream;
+
+        /* Use membuf to prebuffer segment */
+        stream_t *p_stream_filter = stream_FilterNew( p_stream, "membuf" );
+        if( p_stream_filter )
+        {
+            msg_Dbg( p_demux, "open membuf" );
+            p_stream = p_stream_filter;
+            p_new_segment->p_membuf_filter = p_stream_filter;
+        }
+        else
+        {
+            msg_Err( p_demux, "failed to open membuf" );
+            /* ignore membuf */
+        }
+
+        int64_t segment_size = stream_Size( p_stream );
+        msg_Info( p_demux, "vsl segment size %"PRId64, segment_size );
+
+        /* try to peek some data, retry if failed */
+        const uint8_t* p_buf = NULL;
+        int i_peek = stream_Peek( p_stream, &p_buf, 1024 );
+        if( i_peek <= 0 )
+        {
+            stream_Delete( p_stream );
+            return VLC_EGENERIC;
+        }
+
+        p_new_segment->p_stream = p_stream;
+    }
+
+    /* Set current segment */
+    p_sys->p_segment = p_new_segment;
+
+    if( !p_new_segment->p_stream )
+    {
+        msg_Err( p_demux, "vsl_AssureOpenSegment: failed to open stream %s", p_new_segment->p_mrl );
+        return VLC_EGENERIC;
+    }
+
+    if( !p_new_segment->p_demux )
+    {
+        msg_Info( p_demux, "vsl open segment demux %d", p_new_segment->i_order );
+        p_new_segment->p_demux = demux_New( p_new_segment->p_stream,
+                                           p_new_segment->p_stream->p_input,
+                                           "", "any", "",
+                                           p_new_segment->p_stream,
+                                           //p_demux->out,
+                                           p_sys->p_out_managed,
+                                           false);
+        if( !p_new_segment->p_demux )
+        {
+            msg_Err( p_demux, "failed to open demux %s", p_new_segment->p_mrl );
+            return VLC_EGENERIC;
+        }
+
+        /* Set current segment */
+        p_sys->p_segment = p_new_segment;
+    }
+
+    assert( p_sys->p_segment );
+    msg_Info( p_demux, "vsl_AssureOpenSegment: succeeded" );
+    return VLC_SUCCESS;
+}
+
+static int Demux( demux_t *p_demux )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+
+    vsl_index_t *p_index = p_sys->p_index;
+    assert( p_index );
+    assert( p_index->p_segment_array );
+
+    bool b_stop_buffering = false;
+    while( p_sys->p_segment && vlc_object_alive(p_demux) )
+    {
+        if( !p_sys->p_segment || !p_sys->p_segment->p_demux )
+        {
+            msg_Err( p_demux, "NULL segment or demux, maybe EOF" );
+            return 0;
+        }
+
+        int i_demux_ret = demux_Demux( p_sys->p_segment->p_demux );
+        if( i_demux_ret != 0 )
+        {
+            if( i_demux_ret > 0 && b_stop_buffering)
+            {
+                es_out_GetEmpty( p_demux->out );
+                b_stop_buffering = false;
+            }
+
+            int64_t i_cached_size = 0;
+            int i_ret = stream_Control( p_sys->p_segment->p_stream,
+                                        STREAM_GET_CACHED_SIZE,
+                                        &i_cached_size );
+
+            /* Send cached total event */
+            if( VLC_SUCCESS == i_ret &&
+               i_cached_size > 0 &&
+               p_sys->p_segment->i_duration_micro > 0 )
+            {
+                int64_t i_size = stream_Size( p_sys->p_segment->p_stream );
+                if ( i_size > 0 && i_size >= i_cached_size )
+                {
+                    float f_total_cached = i_cached_size;
+                    f_total_cached /= i_size;
+                    f_total_cached *= p_sys->p_segment->i_duration_micro;
+                    f_total_cached += p_sys->p_segment->i_start_time_micro;
+                    f_total_cached /= p_sys->p_index->i_total_duration_micro;
+
+                    int i_total_cached_percent = f_total_cached * 100;
+                    if( p_sys->i_last_total_cached_percent != i_total_cached_percent &&
+                        i_total_cached_percent >= 0 && i_total_cached_percent <= 100 )
+                    {
+                        input_thread_t *p_input = demux_GetParentInput( p_demux );
+                        if( p_input )
+                        {
+                            input_SendEventCacheTotal( p_input, f_total_cached );
+                            p_sys->i_last_total_cached_percent = i_total_cached_percent;
+                        }
+                    }
+                }
+            }
+
+            return i_demux_ret;  /* success or fail */
+        }
+
+        /* segment EOF */
+        assert( p_sys->p_index );
+        vlc_array_t *p_segment_array = p_sys->p_index->p_segment_array;
+        assert( p_segment_array );
+
+        /* test if whole stream EOF */
+        if( p_sys->p_segment->i_order + 1 >= vlc_array_count( p_sys->p_index->p_segment_array ) )
+            break;
+
+        msg_Info( p_demux, "vsl segment EOF, try next segment %d", p_sys->p_segment->i_order + 1 );
+
+        p_sys->b_segment_changed = false;
+        int i_ret = vsl_AssureOpenSegment( p_demux, p_sys->p_segment->i_order + 1 );
+        if( VLC_SUCCESS != i_ret )
+            return -1;
+
+        if( p_sys->b_segment_changed )
+        {
+            /* wait es out empty, up to 'network-caching' */
+
+#define VSL_SEG_WAIT_STEP ( 50 * 1000 )
+            int64_t i_pts_delay = INT64_C(1000) * var_InheritInteger( p_demux, "network-caching" );
+            if( i_pts_delay < 0 )
+                i_pts_delay = 0;
+
+            for( int64_t i = 0; i < i_pts_delay; i += VSL_SEG_WAIT_STEP )
+            {
+                if( es_out_GetEmpty( p_demux->out ) )
+                    break;
+
+                msleep( VSL_SEG_WAIT_STEP );
+            }
+
+            es_out_Control( p_demux->out, ES_OUT_RESET_PCR );
+            b_stop_buffering = true;
+        }
+    }
+
+    /* whole stream EOF */
+    return 0;
+}
+
+/****************************************************************************
+ * Control
+ ****************************************************************************/
+#if 0
+static void vsl_DebugControlCode( demux_t *p_demux, int i_query )
+{
+    const char* p_debug_msg = "unknown";
+    switch( i_query )
+    {
+        case DEMUX_GET_POSITION:            p_debug_msg = "DEMUX_GET_POSITION"; break;
+        case DEMUX_SET_POSITION:            p_debug_msg = "DEMUX_SET_POSITION"; break;
+        case DEMUX_GET_LENGTH:              p_debug_msg = "DEMUX_GET_LENGTH"; break;
+        case DEMUX_GET_TIME:                p_debug_msg = "DEMUX_GET_TIME"; break;
+        case DEMUX_SET_TIME:                p_debug_msg = "DEMUX_SET_TIME"; break;
+        case DEMUX_GET_TITLE_INFO:          p_debug_msg = "DEMUX_GET_TITLE_INFO"; break;
+        case DEMUX_SET_TITLE:               p_debug_msg = "DEMUX_SET_TITLE"; break;
+        case DEMUX_SET_SEEKPOINT:           p_debug_msg = "DEMUX_SET_SEEKPOINT"; break;
+        case DEMUX_SET_GROUP:               p_debug_msg = "DEMUX_SET_GROUP"; break;
+        case DEMUX_SET_NEXT_DEMUX_TIME:     p_debug_msg = "DEMUX_SET_NEXT_DEMUX_TIME"; break;
+        case DEMUX_GET_FPS:                 p_debug_msg = "DEMUX_GET_FPS"; break;
+        case DEMUX_GET_META:                p_debug_msg = "DEMUX_GET_META"; break;
+        case DEMUX_HAS_UNSUPPORTED_META:    p_debug_msg = "DEMUX_HAS_UNSUPPORTED_META"; break;
+        case DEMUX_GET_ATTACHMENTS:         p_debug_msg = "DEMUX_GET_ATTACHMENTS"; break;
+        case DEMUX_CAN_RECORD:              p_debug_msg = "DEMUX_CAN_RECORD"; break;
+        case DEMUX_SET_RECORD_STATE:        p_debug_msg = "DEMUX_SET_RECORD_STATE"; break;
+        case DEMUX_CAN_PAUSE:               p_debug_msg = "DEMUX_CAN_PAUSE"; break;
+        case DEMUX_SET_PAUSE_STATE:         p_debug_msg = "DEMUX_SET_PAUSE_STATE"; break;
+        case DEMUX_GET_PTS_DELAY:           p_debug_msg = "DEMUX_GET_PTS_DELAY"; break;
+        case DEMUX_CAN_CONTROL_PACE:        p_debug_msg = "DEMUX_CAN_CONTROL_PACE"; break;
+        case DEMUX_CAN_CONTROL_RATE:        p_debug_msg = "DEMUX_CAN_CONTROL_RATE"; break;
+        case DEMUX_SET_RATE:                p_debug_msg = "DEMUX_SET_RATE"; break;
+        case DEMUX_CAN_SEEK:                p_debug_msg = "DEMUX_CAN_SEEK"; break;
+        case DEMUX_GET_SIGNAL:              p_debug_msg = "DEMUX_GET_SIGNAL"; break;
+    }
+
+    msg_VslDebug( p_demux, "vsl:Control:%s", p_debug_msg );
+}
+#endif
+
+static int vsl_FindSegmentByTime( demux_t *p_demux, int64_t i_time )
+{
+    if( i_time <= 0 )
+        return 0;
+
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys );
+
+    vsl_index_t *p_index = p_sys->p_index;
+    assert( p_index );
+
+    vlc_array_t *p_segment_array = p_index->p_segment_array;
+    assert( p_segment_array );
+
+    int count = vlc_array_count( p_segment_array );
+    if( 0 == count )
+        return 0;
+
+    for( int i = 0; i < count; ++i )
+    {
+        vsl_segment_t *p_segment = vlc_array_item_at_index( p_segment_array, i );
+        assert( p_segment );
+
+        if( i_time < p_segment->i_start_time_micro + p_segment->i_duration_micro )
+            return i;
+    }
+
+    /* not found, return last segment */
+    return count - 1;
+}
+
+static int vsl_ControlGetDuration( demux_t *p_demux, int64_t *p_duration )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+
+    *p_duration = (int64_t) p_sys->p_index->i_total_duration_micro;
+    return VLC_SUCCESS;
+}
+
+static int vsl_ControlGetTime( demux_t *p_demux, int64_t *p_time )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+
+    vsl_segment_t *p_segment = p_sys->p_segment;
+    if( !p_segment || !p_segment->p_demux )
+        return VLC_EGENERIC;
+
+    int rc = demux_Control( p_segment->p_demux, DEMUX_GET_TIME, p_time );
+    if( rc != VLC_SUCCESS )
+        return rc;
+
+    *p_time += p_segment->i_start_time_micro;
+    return rc;
+}
+
+static int vsl_ControlSetTime( demux_t *p_demux, int64_t i_time )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+    msg_Info( p_demux, "vsl seek %"PRId64, i_time );
+
+    int i_seek_to_segment = vsl_FindSegmentByTime( p_demux, i_time );
+    msg_Info( p_demux, "vsl seek to segment %d", i_seek_to_segment );
+
+    int i_ret = vsl_AssureOpenSegment( p_demux, i_seek_to_segment );
+    if( i_ret != VLC_SUCCESS )
+        return i_ret;
+
+    vsl_segment_t *p_segment = p_sys->p_segment;
+    if( !p_segment || !p_segment->p_demux )
+        return VLC_EGENERIC;
+
+    assert( i_time >= p_sys->p_segment->i_start_time_micro );
+    if( i_time < p_sys->p_segment->i_start_time_micro )
+    {
+        msg_Warn( p_demux, "vsl seek time: %"PRId64" less than segment start time: %"PRId64,
+                 i_time,
+                 p_sys->p_segment->i_start_time_micro );
+        i_time = p_sys->p_segment->i_start_time_micro;
+    }
+
+    int64_t i_segment_duration_micro = 0;
+    int rc = demux_Control( p_segment->p_demux, DEMUX_GET_TIME, &i_segment_duration_micro );
+    if( rc != VLC_SUCCESS )
+    {
+        msg_Info( p_demux, "vsl unable to get duration of segment %d", i_seek_to_segment );
+        return rc;
+    }
+
+    msg_Info( p_demux, "vsl segment seek to %"PRId64" of %"PRId64,
+              i_time - p_sys->p_segment->i_start_time_micro,
+              i_segment_duration_micro );
+    rc = demux_Control( p_segment->p_demux,
+                        DEMUX_SET_TIME,
+                        i_time - p_sys->p_segment->i_start_time_micro );
+    if( rc != VLC_SUCCESS )
+        return rc;
+
+    return rc;
+}
+
+static int vsl_ControlGetPosition( demux_t *p_demux, double *p_position )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+
+    int64_t i_total_duration = 0;
+    int rc = vsl_ControlGetDuration( p_demux, &i_total_duration );
+    if( rc != VLC_SUCCESS )
+        return rc;
+
+    if( i_total_duration <= 0 )
+        return VLC_EGENERIC;
+
+    int64_t i_playing_time = 0;
+    rc = vsl_ControlGetTime( p_demux, &i_playing_time );
+    if( rc != VLC_SUCCESS )
+        return rc;
+
+    *p_position = (double) i_playing_time / i_total_duration;
+    return rc;
+}
+
+static int vsl_ControlSetPosition( demux_t *p_demux, double d_position )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+
+    int64_t i_total_duration = 0;
+    int rc = vsl_ControlGetDuration( p_demux, &i_total_duration );
+    if( rc != VLC_SUCCESS )
+        return rc;
+
+    if( i_total_duration <= 0 )
+        return VLC_EGENERIC;
+
+    int64_t i_segment_playing_time = i_total_duration * d_position;
+    return vsl_ControlSetTime( p_demux, i_segment_playing_time );
+}
+
+static void vsl_ControlSetPauseState( demux_t *p_demux, bool b_pause_state )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+
+    vsl_segment_t *p_segment = p_sys->p_segment;
+    if( !p_segment || !p_segment->p_demux )
+        return;
+
+    if( p_segment->p_demux )
+        demux_Control( p_segment->p_demux, DEMUX_SET_PAUSE_STATE, b_pause_state );
+}
+
+static int Control( demux_t *p_demux, int i_query, va_list args )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+    assert( p_sys);
+    assert( p_sys->p_segment );
+
+    if( !p_sys->p_segment->p_demux )
+    {
+        msg_Err( p_demux, "vsl Control, null segment demux " );
+        return VLC_EGENERIC;
+    }
+
+    switch( i_query )
+    {
+        case DEMUX_GET_POSITION:
+        {
+            double *p_position = (double *) va_arg( args, double * );
+            return vsl_ControlGetPosition( p_demux, p_position );
+        }
+        case DEMUX_SET_POSITION:
+        {
+            double d_position = (double) va_arg( args, double );
+            return vsl_ControlSetPosition( p_demux, d_position );
+        }
+        case DEMUX_GET_TIME:
+        {
+            int64_t *p_time = (int64_t *) va_arg( args, int64_t * );
+            return vsl_ControlGetTime( p_demux, p_time );
+        }
+        case DEMUX_SET_TIME:
+        {
+            int64_t i_time = (int64_t) va_arg( args, int64_t );
+            return vsl_ControlSetTime( p_demux, i_time );
+        }
+        case DEMUX_GET_LENGTH:
+        {
+            int64_t *p_duration = (int64_t *) va_arg( args, int64_t * );
+            return vsl_ControlGetDuration( p_demux, p_duration );
+        }
+        case DEMUX_CAN_PAUSE:
+        case DEMUX_CAN_SEEK:
+        case DEMUX_CAN_CONTROL_PACE:
+        {
+            *va_arg( args, bool * ) = true;
+            return VLC_SUCCESS;
+        }
+        case DEMUX_CAN_CONTROL_RATE:
+        {
+            *va_arg( args, bool * ) = false;
+            return VLC_SUCCESS;
+        }
+        case DEMUX_SET_PAUSE_STATE:
+        {
+            bool b_pause_state = va_arg( args, int );
+            vsl_ControlSetPauseState( p_demux, b_pause_state );
+            return VLC_SUCCESS;
+        }
+        case DEMUX_GET_PTS_DELAY:
+        {
+            int64_t *p_pts_delay = va_arg( args, int64_t * );
+            *p_pts_delay = INT64_C(1000) * var_InheritInteger( p_demux, "network-caching" );
+
+            return VLC_SUCCESS;
+        }
+        default:
+        {
+            if( p_sys->p_segment && p_sys->p_segment->p_demux )
+                return demux_vaControl( p_sys->p_segment->p_demux, i_query, args );
+
+            return VLC_EGENERIC;
+        }
+    }
+
+    return VLC_EGENERIC;
+}
\ No newline at end of file
diff --git a/modules/access/vsl/segment.c b/modules/access/vsl/segment.c
new file mode 100644
index 0000000..1f0e8f5
--- /dev/null
+++ b/modules/access/vsl/segment.c
@@ -0,0 +1,814 @@
+/*****************************************************************************
+ * segment.c: video segment list segment access
+ *****************************************************************************
+ *
+ * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_access.h>
+#include <vlc_stream.h>
+
+#include <ctype.h>
+#include <assert.h>
+
+#include "vsl.h"
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+static int  Open ( vlc_object_t * );
+static void Close( vlc_object_t * );
+
+vlc_module_begin ()
+    set_shortname( N_("vslsegment") )
+    set_description( N_("video segment list segment access demux") )
+    set_category( CAT_INPUT )
+    set_subcategory( SUBCAT_INPUT_ACCESS )
+    set_capability( "access", 1 )
+    add_shortcut( ACCESS_VSL_SEGMENT, ACCESS_SINA_SEGMENT,
+                  ACCESS_YOUKU_SEGMENT, ACCESS_CNTV_SEGMENT,
+                  ACCESS_SOHU_SEGMENT )
+    set_callbacks( Open, Close )
+vlc_module_end ()
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+
+#pragma pack(push)
+#pragma pack(1)
+
+/* http://osflash.org/flv */
+typedef struct
+{
+    uint8_t     signature[3];   /* Always “FLV” */
+    uint8_t     version;        /* Currently 1 for known FLV files */
+    uint8_t     bitmask;        /* “\x05” (5, audio+video)	 Bitmask: 4 is audio, 1 is video */
+    uint32_t    be_offset;      /* BE, Total size of header (always 9 for known FLV files) */
+    /* followed by uint32_t BE */
+    /* uint32_t header_size BE */
+} flv_header_t;
+
+#define FLV_TAG_AUDIO   0x08
+#define FLV_TAG_VIDEO   0x09
+#define FLV_TAG_META    0x12
+typedef struct
+{
+    uint8_t     type;               /* Determines the layout of Body, see below for tag types */
+    uint8_t     be_body_length[3];  /* BE, Size of Body (total tag size - 11) */
+    uint8_t     be_timestamp[3];    /* BE, Timestamp of tag (in milliseconds) */
+    uint8_t     timestamp_extended; /* Timestamp extension to form a uint32_be. This field has the upper 8 bits. */
+    uint8_t     be_stream_id[3];    /* BE, Always 0 */
+    /* followed by uint8_t[body_length] and uint32_t BE */
+    /* uint32_t tag_size BE */
+} flv_tag_t;
+
+#define SINA_FLV_FRONT_MIN_SIZE 94
+
+#pragma pack(pop)
+
+typedef stream_t *(*new_seeked_stream_cb)( access_t* p_access, uint64_t i_pos );
+
+struct access_sys_t
+{
+    vsl_cb_t    cb;
+    int         i_order;
+    int64_t     i_duration_milli;
+    int64_t     i_bytes_per_second;
+
+    bool        b_seekable;
+
+    char        *psz_url;
+
+    stream_t    *p_stream;
+
+    new_seeked_stream_cb pfn_new_seekd_stream;
+};
+
+/* */
+static ssize_t Read( access_t *, uint8_t *, size_t );
+static int Seek( access_t *, uint64_t );
+static int Control( access_t *, int, va_list );
+
+static stream_t *stream_vslNewSeek( access_t* p_access, uint64_t i_pos );
+static stream_t *stream_vslNewSinaSeek( access_t* p_access, uint64_t i_pos );
+static stream_t *stream_vslNewYoukuSeek( access_t* p_access, uint64_t i_pos );
+
+/*****************************************************************************
+ * Open/Close
+ *****************************************************************************/
+static int Open( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys = NULL;
+
+    msg_Dbg( p_access, "Open:check access: %s", p_access->psz_access );
+    if( !p_access->psz_access || !*p_access->psz_access )
+        goto EXIT_ERROR;
+
+    msg_Dbg( p_access, "Open:check location: %s", p_access->psz_location );
+    if( !p_access->psz_location || !*p_access->psz_location )
+        goto EXIT_ERROR;
+
+    if( !isdigit( *p_access->psz_location ) )
+    {
+        msg_Err( p_access, "vsl does not support location %s", p_access->psz_location );
+        goto EXIT_ERROR;
+    }
+
+    /* Set up p_access */
+    STANDARD_READ_ACCESS_INIT;
+    memset( p_sys, 0, sizeof(access_sys_t) );
+    p_access->info.i_size = 0;
+    p_access->info.i_pos  = 0;
+    p_access->info.b_eof  = false;
+
+    p_sys->i_order = atoi( p_access->psz_location );
+    if( p_sys->i_order < 0 )
+    {
+        msg_Err( p_access, "vsl invalid order %s", p_access->psz_location );
+        goto EXIT_ERROR;
+    }
+
+    if( VLC_SUCCESS != vsl_cbGetCallbacks( VLC_OBJECT( p_access ), &p_sys->cb ) )
+        goto EXIT_ERROR;
+
+    int i_count = vsl_cbGetCount( &p_sys->cb );
+    if( p_sys->i_order >= i_count )
+    {
+        msg_Err( p_access, "vsl order %d is out of range %d", p_sys->i_order, i_count );
+        goto EXIT_ERROR;
+    }
+
+    p_sys->psz_url = vsl_cbGetUrl( &p_sys->cb, p_sys->i_order );
+    if( !p_sys->psz_url || !*p_sys->psz_url )
+    {
+        msg_Err( p_access, "vsl empty url for segment %d", p_sys->i_order );
+        goto EXIT_ERROR;
+    }
+    p_sys->i_duration_milli = vsl_cbGetDuration( &p_sys->cb, p_sys->i_order );
+
+    var_Create( p_access, "http-continuous", VLC_VAR_BOOL );
+    var_SetBool( p_access, "http-continuous", true );
+
+    p_sys->p_stream = stream_UrlNew( p_access, p_sys->psz_url );
+    if( !p_sys->p_stream )
+        goto EXIT_ERROR;
+
+    p_access->info.i_size = stream_Size( p_sys->p_stream );
+    if( p_access->info.i_size <= 0 )
+    {
+        msg_Warn( p_access, "segment: stream_Size <= 0, try cbGetBytes" );
+        p_access->info.i_size = vsl_cbGetBytes( &p_sys->cb, p_sys->i_order );
+        if( p_access->info.i_size <= 0 )
+        {
+            msg_Warn( p_access, "segment: vsl_cbGetBytes <= 0, unknown size" );
+            goto EXIT_ERROR;
+        }
+    }
+
+    if( p_sys->i_duration_milli > 0 )
+    {
+        p_sys->i_bytes_per_second = p_access->info.i_size / ( p_sys->i_duration_milli / 1000 );
+    }
+
+    /* at least 25KBps ~= 200kbps */
+    if( p_sys->i_bytes_per_second < 25000 )
+        p_sys->i_bytes_per_second = 25000;
+    msg_Info( p_access, "segment: %"PRId64"KB/s = %"PRId64"KB / %"PRId64" sec",
+              (int64_t)p_sys->i_bytes_per_second / 1000,
+               p_access->info.i_size / 1000,
+               p_sys->i_duration_milli / 1000 );
+
+    p_sys->b_seekable = true;
+    if( 0 == strcmp( p_access->psz_access, ACCESS_SINA_SEGMENT ) )
+    {
+        msg_Dbg( p_access, "segment: sina seek" );
+        p_sys->pfn_new_seekd_stream = stream_vslNewSinaSeek;
+    }
+    else if( 0 == strcmp( p_access->psz_access, ACCESS_YOUKU_SEGMENT ) )
+    {
+        msg_Dbg( p_access, "segment: youku seek" );
+        p_sys->pfn_new_seekd_stream = stream_vslNewYoukuSeek;
+    }
+    else if( 0 == strcmp( p_access->psz_access, ACCESS_CNTV_SEGMENT ) )
+    {
+        // cntv is similar to youku
+        msg_Dbg( p_access, "segment: cntv not seekable" );
+        p_sys->pfn_new_seekd_stream = stream_vslNewYoukuSeek;
+        p_sys->b_seekable = false;
+    }
+    else if( 0 == strcmp( p_access->psz_access, ACCESS_SOHU_SEGMENT ) )
+    {
+        msg_Dbg( p_access, "segment: vsl seek (sohu) " );
+        p_sys->pfn_new_seekd_stream = stream_vslNewSeek;
+    }
+    else {
+        msg_Dbg( p_access, "segment: vsl seek" );
+        p_sys->pfn_new_seekd_stream = stream_vslNewSeek;
+    }
+
+    return VLC_SUCCESS;
+
+EXIT_ERROR:
+    free( p_sys->psz_url );
+    p_sys->psz_url = NULL;
+
+    if( p_sys->p_stream )
+    {
+        stream_Delete( p_sys->p_stream );
+        p_sys->p_stream = NULL;
+    }
+
+    return VLC_EGENERIC;
+}
+
+static void Close( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys = p_access->p_sys;
+
+    if( p_sys->p_stream )
+    {
+        stream_Delete( p_sys->p_stream );
+        p_sys->p_stream = NULL;
+    }
+
+    free( p_sys->psz_url );
+    p_sys->psz_url = NULL;
+}
+
+static ssize_t Read( access_t *p_access, uint8_t *p_buffer, size_t i_len )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    stream_t     *p_stream = p_sys->p_stream;
+    int          i_read_ret = -1;
+
+    //msg_Err( p_stream, "Read %d", i_len );
+
+    if( !p_stream )
+        goto EXIT_FAIL;
+
+    if( p_access->info.i_size != 0 )
+    {
+        /* Remaining bytes in the file */
+        uint64_t i_remaining = p_access->info.i_size - p_access->info.i_pos;
+        if( i_remaining < i_len )
+            i_len = i_remaining;
+    }
+    if( i_len <= 0 )
+    {
+        i_read_ret = 0;
+        goto EXIT_FAIL;
+    }
+
+    i_read_ret = stream_Read( p_stream, p_buffer, i_len );
+    if( i_read_ret <= 0 )
+        goto EXIT_FAIL;
+
+    assert( i_read_ret > 0 );
+    assert( p_access->info.i_pos <= p_access->info.i_size );
+    assert( p_access->info.i_pos + i_read_ret <= p_access->info.i_size );
+    p_access->info.i_pos += i_read_ret;
+
+    //msg_Err( p_stream, "Read ok %d", i_read_ret );
+    return i_read_ret;
+
+EXIT_FAIL:
+    //msg_Err( p_stream, "Read failed %d", i_read_ret );
+
+    assert( i_read_ret <= 0 );
+    if( i_read_ret <= 0 )
+        p_access->info.b_eof = true;
+
+    return i_read_ret;
+}
+
+static int stream_ReadSeek( stream_t *p_stream, uint64_t i_seek_forward_bytes ) {
+    int i_skipped = 0;
+
+    while( (uint64_t) i_skipped < i_seek_forward_bytes )
+    {
+        char buf[4096];
+        int i_to_read = sizeof( buf );
+        int64_t i_unread = i_seek_forward_bytes - i_skipped;
+        if( i_to_read > i_unread )
+            i_to_read = i_unread;
+
+        int i_skip_ret = stream_Read( p_stream, buf, i_to_read );
+        if( i_skip_ret <= 0 )
+            return -1;
+
+        i_skipped += i_skip_ret;
+    }
+
+    return i_skipped;
+}
+
+static int SkipSeekedUnknownHeader( access_t *p_access, stream_t *p_stream, uint64_t i_seek_pos )
+{
+    if( i_seek_pos > p_access->info.i_size )
+        return -1;
+
+    if( i_seek_pos == p_access->info.i_size )
+        return 0;
+
+    int64_t i_stream_len = stream_Size( p_stream );
+    if( i_stream_len < 0 )
+        return -1;
+
+    int64_t i_whole_remain = p_access->info.i_size - i_seek_pos;
+    if( i_stream_len < i_whole_remain )
+    {
+        msg_Err( p_access, "flvhead: too small seeked size: %"PRId64" < %"PRId64,
+                 i_stream_len,
+                 i_whole_remain);
+        return -1;
+    }
+
+    int64_t i_align_diff = i_stream_len - i_whole_remain;
+    msg_Dbg( p_access, "flvhead: align diff %"PRId64, i_align_diff );
+
+    int64_t i_skipped = 0;
+    while( i_skipped < i_align_diff )
+    {
+        int i_skip_ret = stream_ReadSeek( p_stream, i_align_diff - i_skipped );
+        if( i_skip_ret <= 0 )
+            return -1;
+
+        i_skipped += i_skip_ret;
+    }
+
+    return i_skipped;
+}
+
+/* return skipped bytes */
+static int SkipSeekedFlvHeader( access_t *p_access, stream_t *p_stream, uint64_t i_seek_pos )
+{
+    if( i_seek_pos >= p_access->info.i_size )
+        return -1;
+
+    uint64_t i_stream_len = stream_Size( p_stream );
+    if( i_stream_len < sizeof( flv_header_t ) + 4 )
+        return -1;
+
+    /* Simple align with header check */
+#if 1
+#endif
+
+    int i_peek = ( i_stream_len < 1024 ) ? (int) i_stream_len : 1024;
+    const uint8_t *p_peek = NULL;
+    int i_peek_ret = stream_Peek( p_stream, &p_peek, i_peek );
+    if( i_peek_ret < i_peek )
+        return -1;
+
+    /* Look for flv tag */
+    flv_header_t* p_header = (flv_header_t *) p_peek;
+    if( 0 != memcmp( p_header->signature, "FLV", 3 ) )
+    {
+        msg_Warn( p_access, "flvhead: not a valid flv stream" );
+        return -1;
+    }
+
+    uint64_t i_whole_remain = p_access->info.i_size - i_seek_pos;
+    if( i_stream_len < i_whole_remain )
+    {
+        msg_Err( p_access, "flvhead: too small seeked size: %"PRId64" < %"PRId64,
+                i_stream_len,
+                i_whole_remain);
+        return -1;
+    }
+
+    uint64_t i_align_diff = i_stream_len - i_whole_remain;
+    msg_Dbg( p_access, "flvhead: align diff %"PRId64, i_align_diff );
+
+    uint64_t i_skipped = 0;
+    while( i_skipped < i_align_diff )
+    {
+        int i_skip_ret = stream_ReadSeek( p_stream, i_align_diff - i_skipped );
+        if( i_skip_ret <= 0 )
+            return -1;
+
+        i_skipped += i_skip_ret;
+    }
+
+    return i_skipped;
+#if 0
+    /* TODO: reliable header check */
+
+    int i_peek = ( i_stream_len < 1024 ) ? (int) i_stream_len : 1024;
+    const uint8_t *p_peek = NULL;
+    int i_peek_ret = stream_Peek( p_stream, &p_peek, i_peek );
+    if( i_peek_ret < i_peek )
+        return -1;
+
+    /* Look for flv tag */
+    flv_header_t* p_header = (flv_header_t *) p_peek;
+    if( 0 != memcmp( p_header->signature, "FLV", 3 ) )
+    {
+        msg_Warn( p_access, "flvhead: not a valid flv stream" );
+        return -1;
+    }
+
+    /* TODO: more check for flv header */
+
+    /* Look for flv tag */
+    bool b_audio_tag_skipped = false;
+    bool b_video_tag_skipped = false;
+    bool b_meta_tag_skipped = false;
+    int i_scan = sizeof( flv_header_t ) + 4;
+    msg_Dbg( p_access, "flvhead: skip flv_header %d", i_scan );
+    for( int i = 0; i < 2; ++i )
+    {
+        flv_tag_t* p_tag = (flv_tag_t *) ( p_peek + i_scan );
+        if( p_tag->type == FLV_TAG_AUDIO)
+        {
+            b_audio_tag_skipped = true;
+            msg_Dbg( p_access, "flvhead: seeked audio tag skipped");
+        }
+        else if( p_tag->type == FLV_TAG_VIDEO )
+        {
+            b_video_tag_skipped = true;
+            msg_Dbg( p_access, "flvhead: seeked video tag skipped");
+        }
+        else if( p_tag->type == FLV_TAG_META )
+        {
+            b_meta_tag_skipped = true;
+            msg_Dbg( p_access, "flvhead: seeked meta tag skipped");
+        }
+        else
+        {
+            msg_Dbg( p_access, "flvhead: seeked unknown tag %x", (int) p_tag->type);
+            break;
+        }
+
+        int i_body_len =
+        ( ( (uint32_t) p_tag->be_body_length[0] ) << 16 ) |
+        ( ( (uint32_t) p_tag->be_body_length[1] ) << 8 ) |
+        ( ( (uint32_t) p_tag->be_body_length[2] ) );
+
+        const uint8_t *p_previous_tag_size = p_peek + i_scan + sizeof( flv_tag_t ) + i_body_len;
+        int i_previous_tag_size =
+        ( ( (uint32_t) p_previous_tag_size[0] ) << 24 ) |
+        ( ( (uint32_t) p_previous_tag_size[1] ) << 16 ) |
+        ( ( (uint32_t) p_previous_tag_size[2] ) << 8 ) |
+        ( ( (uint32_t) p_previous_tag_size[3] ) );
+
+        int tag_size = sizeof( flv_tag_t ) + i_body_len + 4;
+        msg_Dbg( p_access, "flvhead: skip flv_tag %d=%d+%d+4, (%d) now at %d",
+                tag_size, (int) sizeof( flv_tag_t ), i_body_len,
+                i_previous_tag_size,
+                i_scan + tag_size );
+        if( i_scan + tag_size >= i_peek_ret )
+            break;
+
+        i_scan += tag_size;
+    }
+
+    if( !b_audio_tag_skipped )
+        msg_Dbg( p_access, "flvhead: seeked audio tag not found");
+
+    if( !b_audio_tag_skipped )
+        msg_Dbg( p_access, "flvhead: seeked audio tag not found");
+
+    if( !b_audio_tag_skipped )
+        msg_Dbg( p_access, "flvhead: seeked audio tag not found");
+
+    msg_Dbg( p_access, "flvhead: skip %d bytes", i_scan );
+    int i_skip_ret = stream_ReadSeek( p_stream, i_scan );
+    return i_skip_ret;
+#endif
+}
+
+static stream_t *stream_vslNewSinaSeek( access_t* p_access, uint64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    char* p_seek_url = NULL;
+    stream_t *p_stream = NULL;
+
+    msg_Info( p_access, "segment: sina: seek to %"PRId64, i_pos );
+
+    /* */
+    const char* p_prefix = strchr( p_sys->psz_url, '?' ) ? "&" : "?";
+    if( asprintf( &p_seek_url, "%s%sstart=%"PRId64, p_sys->psz_url, p_prefix, i_pos ) < 0)
+        goto EXIT_FAIL;
+
+    p_stream = stream_UrlNew( p_access, p_seek_url );
+    if( !p_stream )
+    {
+        msg_Err( p_access, "segment: sina: seek: failed to open stream %s", p_seek_url );
+        goto EXIT_FAIL;
+    }
+
+    /* Sina add extra flv header and flv tag after seeked */
+    int i_skip_ret = SkipSeekedFlvHeader( p_access, p_stream, i_pos );
+    if( i_skip_ret <= 0 )
+    {
+        msg_Err( p_access, "segment: sina: seek: failed to skip flv header" );
+        goto EXIT_FAIL;
+    }
+
+    return p_stream;
+
+EXIT_FAIL:
+    if( p_stream != NULL )
+    {
+        stream_Delete( p_stream );
+        p_stream = NULL;
+    }
+
+    VSL_SAFE_FREE( p_seek_url );
+
+    return NULL;
+}
+
+static stream_t *stream_vslNewYoukuSeek( access_t* p_access, uint64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    char* p_seek_url = NULL;
+    stream_t *p_stream = NULL;
+    bool b_seeked_forward = false;
+
+    int64_t i_seek_to_second = 0;
+    int64_t i_last_backward_seeked_second = p_sys->i_duration_milli / 1000;
+
+    msg_Info( p_access, "segment: youku: seek to %"PRId64, i_pos );
+    if( p_access->info.i_size <= 0 )
+    {
+        msg_Err( p_access, "segment: youku: seek: invalid info.i_size < 0" );
+        goto EXIT_FAIL;
+    }
+
+    i_seek_to_second = i_pos / p_sys->i_bytes_per_second;
+    if( i_seek_to_second >= 15 )
+        i_seek_to_second -= 15;
+    else
+        i_seek_to_second = 0;
+
+    do {
+        if( p_stream != NULL )
+        {
+            stream_Delete( p_stream );
+            p_stream = NULL;
+        }
+        VSL_SAFE_FREE( p_seek_url );
+
+        /* */
+        msg_Info( p_access, "segment: youku: seek to %"PRId64" seconds", i_seek_to_second );
+        const char* p_prefix = strchr( p_sys->psz_url, '?' ) ? "&" : "?";
+        if( i_seek_to_second > 0 )
+        {
+            if( asprintf( &p_seek_url, "%s%sstart=%"PRId64, p_sys->psz_url, p_prefix, i_seek_to_second ) < 0)
+                goto EXIT_FAIL;
+        }
+        else
+        {
+            p_seek_url = strdup( p_sys->psz_url );
+        }
+
+        p_stream = stream_UrlNew( p_access, p_seek_url );
+        if( !p_stream )
+        {
+            msg_Err( p_access, "segment: youku: seek: failed to open stream %s", p_seek_url );
+            goto EXIT_FAIL;
+        }
+
+        uint64_t i_stream_len = stream_Size( p_stream );
+        if( i_stream_len <= 0 )
+        {
+            msg_Err( p_access, "segment: youku: seek: invalid stream size" );
+            goto EXIT_FAIL;
+        }
+
+        int64_t i_seeked = p_access->info.i_size - i_stream_len;
+        if( i_seeked < 0 )
+        {
+            msg_Err( p_access, "segment: youku: seek: seeked before stream start?" );
+            goto EXIT_FAIL;
+        }
+        else if( i_seeked > (int64_t) i_pos )
+        {
+            int64_t i_diff_bytes = i_seeked - i_pos;
+            msg_Warn( p_access, "segment: youku: seek: after seeking pos %"PRId64" > %"PRId64", need reseeking",
+                    i_seeked,
+                    i_pos);
+            int64_t i_diff_seconds = i_diff_bytes / p_sys->i_bytes_per_second;
+
+            /* seek to 5 seconds before guessed seek point */
+            if( i_seek_to_second > i_diff_seconds )
+                i_seek_to_second = i_seek_to_second - i_diff_seconds - 5;
+            else
+                i_seek_to_second = 0;
+
+            i_last_backward_seeked_second = i_seek_to_second;
+            continue;
+        }
+        else if( !b_seeked_forward && i_seeked + 1000 * 1000 > (int64_t) i_pos )
+        {
+            int64_t i_diff_bytes = i_pos - i_seeked;
+            msg_Warn( p_access, "segment: youku: seeked too far before seeking pos %"PRId64" < %"PRId64", need reseeking",
+                     i_seeked,
+                     i_pos);
+            int64_t i_diff_seconds = ( i_diff_bytes - 500 * 1000 ) / p_sys->i_bytes_per_second;
+            if( i_seek_to_second + i_diff_seconds > i_last_backward_seeked_second )
+            {
+                /* there is no sense to seek after last seeked second */
+                break;
+            }
+
+            i_seek_to_second += i_diff_seconds;
+        }
+
+        break;
+    } while( i_seek_to_second > 5 );
+
+    if( !p_stream )
+        goto EXIT_FAIL;
+
+    /* Youku seeked by seconds, should align to stream seek position */
+    int i_skip_ret = SkipSeekedUnknownHeader( p_access, p_stream, i_pos );
+    if( i_skip_ret < 0 )
+    {
+        msg_Err( p_access, "segment: youku: seek: failed to skip unknown header" );
+        goto EXIT_FAIL;
+    }
+
+    VSL_SAFE_FREE( p_seek_url );
+    return p_stream;
+
+EXIT_FAIL:
+    if( p_stream != NULL )
+    {
+        stream_Delete( p_stream );
+        p_stream = NULL;
+    }
+
+    VSL_SAFE_FREE( p_seek_url );
+    return NULL;
+}
+
+static stream_t *stream_vslNewSeek( access_t* p_access, uint64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+
+    msg_Info( p_access, "segment: vsk: seek to %"PRId64, i_pos );
+    stream_t *p_stream = stream_UrlNew( p_access, p_sys->psz_url);
+    if( !p_stream )
+    {
+        msg_Err( p_access, "segment: failed to open stream %s", p_sys->psz_url );
+        goto EXIT_FAIL;
+    }
+
+    int i_ret = stream_Seek( p_stream, i_pos );
+    if( i_ret < 0 )
+    {
+        msg_Err( p_access, "segment: failed to seek" );
+        goto EXIT_FAIL;
+    }
+
+    return p_stream;
+
+EXIT_FAIL:
+    if( p_stream != NULL )
+    {
+        stream_Delete( p_stream );
+        p_stream = NULL;
+    }
+
+    return NULL;
+}
+
+static int Seek( access_t *p_access, uint64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    stream_t *p_stream = NULL;
+
+    msg_Info( p_access, "segment: seek %"PRId64"/%"PRId64, i_pos, p_access->info.i_size );
+
+    if( i_pos > p_access->info.i_size )
+        goto EXIT_FAIL;
+
+    if( i_pos == p_access->info.i_size )
+    {
+        p_access->info.i_pos = i_pos;
+        p_access->info.b_eof = true;
+        return VLC_SUCCESS;
+    }
+
+    if( i_pos == p_access->info.i_pos )
+        return VLC_SUCCESS;
+
+    /* optimize short seek */
+    if( i_pos > p_access->info.i_pos &&
+        i_pos < p_access->info.i_pos + 128 * 1024 )
+    {
+        int i_seek_forward = p_access->info.i_pos - i_pos;
+        int i_seek_ret = stream_ReadSeek( p_sys->p_stream, i_seek_forward );
+        if( i_seek_ret <= 0 )
+            goto EXIT_FAIL;
+
+        p_access->info.i_pos += i_seek_ret;
+        p_access->info.b_eof = ( p_access->info.i_pos >= p_access->info.i_size );
+        return VLC_SUCCESS;
+    }
+
+    /* close previous stream first */
+    if( p_sys->p_stream )
+    {
+        stream_Delete( p_sys->p_stream );
+        p_sys->p_stream = NULL;
+    }
+
+    /* */
+    p_stream = p_sys->pfn_new_seekd_stream( p_access, i_pos );
+    if( !p_stream )
+    {
+        msg_Err( p_access, "segment: failed to open seeked stream %s", p_sys->psz_url );
+        goto EXIT_FAIL;
+    }
+
+    p_sys->p_stream = p_stream;
+
+    p_access->info.i_pos = i_pos;
+    p_access->info.b_eof = ( i_pos >= p_access->info.i_size );
+
+    return VLC_SUCCESS;
+
+EXIT_FAIL:
+    if( p_stream )
+        stream_Delete( p_stream );
+
+    return VLC_EGENERIC;
+}
+
+static int Control( access_t *p_access, int i_query, va_list args )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    stream_t     *p_stream = p_sys->p_stream;
+
+    switch( i_query )
+    {
+            /* */
+        case ACCESS_CAN_SEEK:
+            *(bool*)va_arg( args, bool* ) = p_sys->b_seekable;
+            return VLC_SUCCESS;
+
+        case ACCESS_CAN_FASTSEEK:
+            *(bool*)va_arg( args, bool* ) = false;
+            return VLC_SUCCESS;
+
+        case ACCESS_CAN_PAUSE:
+        case ACCESS_CAN_CONTROL_PACE:
+            *(bool*)va_arg( args, bool* ) = true;
+            return VLC_SUCCESS;
+
+            /* */
+        case ACCESS_GET_PTS_DELAY:
+        {
+            int64_t *pi_64 = (int64_t*)va_arg( args, int64_t * );
+            *pi_64 = INT64_C(1000)
+            * var_InheritInteger( p_access, "network-caching" );
+            return VLC_SUCCESS;
+        }
+
+            /* */
+        case ACCESS_SET_PAUSE_STATE:
+            return VLC_SUCCESS;
+
+        case ACCESS_GET_CONTENT_TYPE:
+            return stream_vaControl( p_stream, STREAM_GET_CONTENT_TYPE, args );
+
+        case ACCESS_GET_TITLE_INFO:
+        case ACCESS_SET_TITLE:
+        case ACCESS_SET_SEEKPOINT:
+        case ACCESS_SET_PRIVATE_ID_STATE:
+            return VLC_EGENERIC;
+
+        default:
+            msg_Warn( p_access, "unimplemented query in control" );
+            return VLC_EGENERIC;
+    }
+}
\ No newline at end of file
diff --git a/modules/access/vsl/vsl.c b/modules/access/vsl/vsl.c
index aca9b01..58fa855 100644
--- a/modules/access/vsl/vsl.c
+++ b/modules/access/vsl/vsl.c
@@ -1,22 +1,23 @@
 /*****************************************************************************
  * vsl.c: video segment list access
  *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
  *
- * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
  *****************************************************************************/
 
 /*****************************************************************************
@@ -33,127 +34,77 @@
 
 #include "vsl.h"
 
-static vsl_info_t *alloc_VslInfo()
+int vsl_cbGetCallbacks( vlc_object_t *p_this, vsl_cb_t *p_vsl_cb )
 {
-    vsl_info_t *p_vsl_info = (vsl_info_t *) malloc( sizeof(vsl_info_t) );
-    memset( p_vsl_info, 0, sizeof(vsl_info_t) );
-
-    p_vsl_info->i_order = -1;
+    p_vsl_cb->p_cb_data = var_InheritAddress( p_this, "vsl-data" );
+    p_vsl_cb->pfn_load = var_InheritAddress( p_this, "vsl-load" );
+    p_vsl_cb->pfn_get_count = var_InheritAddress( p_this, "vsl-get-count" );
+    p_vsl_cb->pfn_get_mrl = var_InheritAddress( p_this, "vsl-get-mrl" );
+    p_vsl_cb->pfn_get_url = var_InheritAddress( p_this, "vsl-get-url" );
+    p_vsl_cb->pfn_get_duration = var_InheritAddress( p_this, "vsl-get-duration" );
+    p_vsl_cb->pfn_get_bytes = var_InheritAddress( p_this, "vsl-get-bytes" );
+    if( !p_vsl_cb->p_cb_data ||
+        !p_vsl_cb->pfn_load ||
+        !p_vsl_cb->pfn_get_count ||
+        !p_vsl_cb->pfn_get_mrl ||
+        !p_vsl_cb->pfn_get_url ||
+        !p_vsl_cb->pfn_get_duration ||
+        !p_vsl_cb->pfn_get_bytes )
+    {
+        msg_Err( p_this, "vsl callback not set %p, %p, %p, %p, %p, %p, %p",
+                 p_vsl_cb->p_cb_data,
+                 p_vsl_cb->pfn_load,
+                 p_vsl_cb->pfn_get_count,
+                 p_vsl_cb->pfn_get_mrl,
+                 p_vsl_cb->pfn_get_url,
+                 p_vsl_cb->pfn_get_duration,
+                 p_vsl_cb->pfn_get_bytes );
+        goto EXIT_ERROR;
+    }
 
-    return p_vsl_info;
+    return VLC_SUCCESS;
+EXIT_ERROR:
+    return VLC_EGENERIC;
 }
 
-void free_VslInfo( vsl_info_t *p_vsl_info )
+int vsl_cbLoad( vsl_cb_t *p_vsl_cb, bool b_force_reload )
 {
-    if( p_vsl_info == NULL )
-        return;
-
-    VSL_SAFE_FREE( p_vsl_info->p_index_url );
-    VSL_SAFE_FREE( p_vsl_info->p_pseudo_segment_access );
-
-    VSL_SAFE_FREE( p_vsl_info->p_real_access );
-    VSL_SAFE_FREE( p_vsl_info->p_real_access_tag );
-
-    VSL_SAFE_FREE( p_vsl_info );
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_load );
+    return p_vsl_cb->pfn_load( p_vsl_cb->p_cb_data, b_force_reload );
 }
 
-vsl_info_t *vsl_ResolveInfo( demux_t *p_demux )
+int vsl_cbGetCount( vsl_cb_t *p_vsl_cb )
 {
-    char        *p_find_real_access_tag = NULL;
-    char        *p_find_segment_order = NULL;
-    vsl_info_t  *p_vsl_info = NULL;
-
-    msg_Dbg( p_demux, "vsl check access: %s", p_demux->psz_access );
-    if( !p_demux->psz_access || !*p_demux->psz_access )
-        goto EXIT_ERROR;
-
-    msg_Dbg( p_demux, "vsl check p_demux: %s", p_demux->psz_demux );
-    if( !p_demux->psz_demux || !*p_demux->psz_demux )
-        goto EXIT_ERROR;
-
-    msg_Dbg( p_demux, "vsl check location: %s", p_demux->psz_location );
-    if( !p_demux->psz_location || !*p_demux->psz_location )
-        goto EXIT_ERROR;
-
-    p_vsl_info = alloc_VslInfo();
-    if( !p_vsl_info )
-        goto EXIT_ERROR;
-
-    p_vsl_info->pfn_resolve = var_GetAddress( p_demux, "segment-list-resolve" );
-    if( !p_vsl_info->pfn_resolve )
-    {
-        msg_Err( p_demux, "segment-list-resolve not set" );
-        goto EXIT_ERROR;
-    }
-
-    p_vsl_info->pfn_release = var_GetAddress( p_demux, "segment-list-release" );
-    if( !p_vsl_info->pfn_release )
-    {
-        msg_Err( p_demux, "segment-list-release not set" );
-        goto EXIT_ERROR;
-    }
-
-    /* parse pseudo access/demux */
-    if( 0 == strcmp( p_demux->psz_access, ACCESS_VSL_INDEX ) )
-        p_vsl_info->p_pseudo_segment_access = strdup( ACCESS_VSL_SEGMENT );
-    else if( 0 == strcmp( p_demux->psz_access, ACCESS_SINA_INDEX ) )
-        p_vsl_info->p_pseudo_segment_access = strdup( ACCESS_SINA_SEGMENT );
-    else if( 0 == strcmp( p_demux->psz_access, ACCESS_YOUKU_INDEX ) )
-        p_vsl_info->p_pseudo_segment_access = strdup( ACCESS_YOUKU_SEGMENT );
-    else
-    {
-        msg_Err( p_demux, "vsl unknown pseudo access %s", p_demux->psz_access );
-        goto EXIT_ERROR;
-    }
-
-    /* parse real access/tag/order */
-    p_find_real_access_tag = strchr( p_demux->psz_demux, '-' );
-    if( !p_find_real_access_tag || !*p_find_real_access_tag )
-    {
-        msg_Err( p_demux, "vsl can not find real access tag in %s",
-                 p_demux->psz_demux );
-        goto EXIT_ERROR;
-    }
-
-    p_vsl_info->p_real_access = strndup( p_demux->psz_demux,
-                                         p_find_real_access_tag - p_demux->psz_demux );
-    p_vsl_info->p_real_access_tag = strdup( p_find_real_access_tag + 1 );
-
-    p_find_segment_order = strchr( p_find_real_access_tag + 1, '-' );
-    if( p_find_segment_order && *p_find_segment_order )
-    {
-        p_vsl_info->i_order = atol( p_find_segment_order + 1 );
-        msg_Dbg( p_demux, "vsl segment order %d", p_vsl_info->i_order );
-    }
-
-    /* save index mrl */
-    if( 0 > asprintf( &p_vsl_info->p_index_mrl, "%s:/%s/%s",
-                      p_demux->psz_access,
-                      p_demux->psz_demux,
-                      p_demux->psz_location ) )
-    {
-        msg_Warn( p_demux, "failed to build vsl mrl" );
-        goto EXIT_ERROR;
-    }
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_get_count );
+    return p_vsl_cb->pfn_get_count( p_vsl_cb->p_cb_data );
+}
 
-    /* save index url */
-    if( 0 > asprintf( &p_vsl_info->p_index_url, "%s://%s",
-                      p_vsl_info->p_real_access,
-                      p_demux->psz_location ) )
-    {
-        msg_Warn( p_demux, "failed to build vsl url" );
-        goto EXIT_ERROR;
-    }
+char *vsl_cbGetMrl( vsl_cb_t *p_vsl_cb, int i_order )
+{
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_get_mrl );
+    return p_vsl_cb->pfn_get_mrl( p_vsl_cb->p_cb_data, i_order );
+}
 
-    return p_vsl_info;
-EXIT_ERROR:
-    free_VslInfo( p_vsl_info );
-    p_vsl_info = NULL;
+char *vsl_cbGetUrl( vsl_cb_t *p_vsl_cb, int i_order )
+{
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_get_url );
+    return p_vsl_cb->pfn_get_url( p_vsl_cb->p_cb_data, i_order );
+}
 
-    return NULL;
+int vsl_cbGetDuration( vsl_cb_t *p_vsl_cb, int i_order )
+{
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_get_duration );
+    return p_vsl_cb->pfn_get_duration( p_vsl_cb->p_cb_data, i_order );
 }
 
-libvlc_segment_list_t *vsl_ResolveSegmentList( demux_t *p_demux, vsl_info_t *p_vsl_info )
+int64_t vsl_cbGetBytes( vsl_cb_t *p_vsl_cb, int i_order )
 {
-    return NULL;
-}
\ No newline at end of file
+    assert( p_vsl_cb->p_cb_data );
+    assert( p_vsl_cb->pfn_get_bytes );
+    return p_vsl_cb->pfn_get_bytes( p_vsl_cb->p_cb_data, i_order );
+}
diff --git a/modules/access/vsl/vsl.h b/modules/access/vsl/vsl.h
index de188ac..3605fb6 100644
--- a/modules/access/vsl/vsl.h
+++ b/modules/access/vsl/vsl.h
@@ -1,22 +1,23 @@
 /*****************************************************************************
  * vsl.h: video segment list access
  *****************************************************************************
+ * Copyright (C) 2012 Rui Zhang
  *
- * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ * Author: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
  *****************************************************************************/
 
 /*****************************************************************************
@@ -35,28 +36,37 @@
 #define ACCESS_YOUKU_INDEX      "youkuindex"
 #define ACCESS_YOUKU_SEGMENT    "youkusegment"
 
-#define VSL_SAFE_FREE( x__ ) do { free( x__ ); ( x__ ) = NULL; } while( 0 )
-
-typedef libvlc_segment_list_t *(*libvlc_segment_list_resolve_cb)( const char *p_mrl );
-typedef void (*libvlc_segment_list_release_cb)( libvlc_segment_list_t *p_segment_lst );
-
-typedef struct {
-    char    *p_index_mrl;
-    char    *p_index_url;
-    char    *p_pseudo_segment_access;       /* vslsegment */
+#define ACCESS_CNTV_INDEX       "cntvindex"
+#define ACCESS_CNTV_SEGMENT     "cntvsegment"
 
-    char    *p_real_access;                 /* http */
-    char    *p_real_access_tag;             /* mp4 */
+#define ACCESS_SOHU_INDEX       "sohuindex"
+#define ACCESS_SOHU_SEGMENT     "sohusegment"
 
-    int     i_order;                        /* -1 for index */
+#define VSL_SAFE_FREE( x__ ) do { free( x__ ); ( x__ ) = NULL; } while( 0 )
 
-    libvlc_segment_list_resolve_cb  pfn_resolve;
-    libvlc_segment_list_release_cb  pfn_release;
-} vsl_info_t;
+typedef int (*libvlc_vsl_load_cb)( void *p_cb_data, bool b_force_reload );
+typedef int (*libvlc_vsl_get_count_cb)( void *p_cb_data );
+typedef char *(*libvlc_vsl_get_mrl_cb)( void *p_cb_data, int i_order );
+typedef char *(*libvlc_vsl_get_url_cb)( void *p_cb_data, int i_order );
+typedef int (*libvlc_vsl_get_duration_cb)( void *p_cb_data, int i_order );
+typedef int64_t (*libvlc_vsl_get_bytes_cb)( void *p_cb_data, int i_order );
 
-void free_VslInfo( vsl_info_t *p_index_info );
-vsl_info_t *vsl_ResolveInfo( demux_t *p_demux );
+typedef struct {
+    void                        *p_cb_data;
+    libvlc_vsl_load_cb          pfn_load;
+    libvlc_vsl_get_count_cb     pfn_get_count;
+    libvlc_vsl_get_mrl_cb       pfn_get_mrl;
+    libvlc_vsl_get_url_cb       pfn_get_url;
+    libvlc_vsl_get_duration_cb  pfn_get_duration;
+    libvlc_vsl_get_bytes_cb     pfn_get_bytes;
+} vsl_cb_t;
 
-libvlc_segment_list_t *vsl_ResolveSegmentList( demux_t *p_demux, vsl_info_t *p_vsl_info );
+int vsl_cbGetCallbacks( vlc_object_t *p_this, vsl_cb_t *p_vsl_cb );
+int vsl_cbLoad( vsl_cb_t *p_vsl_cb, bool b_force_reload );
+int vsl_cbGetCount( vsl_cb_t *p_vsl_cb );
+char *vsl_cbGetMrl( vsl_cb_t *p_vsl_cb, int i_order );
+char *vsl_cbGetUrl( vsl_cb_t *p_vsl_cb, int i_order );
+int vsl_cbGetDuration( vsl_cb_t *p_vsl_cb, int i_order );
+int64_t vsl_cbGetBytes( vsl_cb_t *p_vsl_cb, int i_order );
 
-#endif
\ No newline at end of file
+#endif
-- 
1.7.10.4

