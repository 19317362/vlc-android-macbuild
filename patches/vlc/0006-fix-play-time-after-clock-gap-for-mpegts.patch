From b136cd80fe00334c6fd32bb1938794e32f0516f3 Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Mon, 7 May 2012 23:55:29 +0800
Subject: [PATCH 6/7] fix play time after clock gap for mpegts

---
 include/vlc_stream.h             |    3 ++
 modules/demux/ts.c               |   28 ++++++++++++++--
 modules/stream_filter/httplive.c |   68 ++++++++++++++++++++++++++++++++------
 3 个文件被修改，插入 86 行(+)，删除 13 行(-)

diff --git a/include/vlc_stream.h b/include/vlc_stream.h
index c929836..3f4a1b2 100644
--- a/include/vlc_stream.h
+++ b/include/vlc_stream.h
@@ -111,6 +111,9 @@ enum stream_query_e
 
     /* XXX only data read through stream_Read/Block will be recorded */
     STREAM_SET_RECORD_STATE,     /**< arg1=bool, arg2=const char *psz_ext (if arg1 is true)  res=can fail */
+
+    /* for clock gap in youku httplive/mpeg2ts */
+    STREAM_HTTPLIVE_GET_SEGMENT_START,
 };
 
 VLC_API int stream_Read( stream_t *s, void *p_read, int i_read );
diff --git a/modules/demux/ts.c b/modules/demux/ts.c
index 0cf0630..ce19257 100644
--- a/modules/demux/ts.c
+++ b/modules/demux/ts.c
@@ -1981,6 +1981,8 @@ static void PCRHandle( demux_t *p_demux, ts_pid_t *pid, block_t *p_bk )
     if( i_pcr < 0 )
         return;
 
+    mtime_t i_prev_pcr = p_sys->i_current_pcr;
+
     /* handle first PCR if not obtain in Open() */
     if( p_sys->i_pid_ref_pcr == -1 )
     {
@@ -1991,11 +1993,33 @@ static void PCRHandle( demux_t *p_demux, ts_pid_t *pid, block_t *p_bk )
 
     if( p_sys->i_pid_ref_pcr == pid->i_pid )
     {
+        if( i_prev_pcr > 0 && i_prev_pcr > i_pcr )
+        {
+            p_sys->b_need_resync_pcr = true;
+        }
+        else
         /* reset PCR if discontinuitied */
         if( p_sys->b_need_resync_pcr )
         {
-            p_sys->i_segment_start_time = var_InheritInteger( p_demux->s, "httplive-segment-start-time" );
-            p_sys->i_resync_first_pcr = i_pcr;
+            int64_t i_segment_start = 0;
+            if( VLC_SUCCESS == stream_Control(p_demux->s, STREAM_HTTPLIVE_GET_SEGMENT_START, &i_segment_start ) &&
+               i_segment_start >= 0) {
+                char buf[256];
+                sprintf( buf, "pcr gap %lld => %lld, resync reference start from %lld to %lld",
+                        i_prev_pcr, i_pcr,
+                        p_sys->i_segment_start_time,
+                        i_segment_start);
+                msg_Warn( p_demux, buf );
+                p_sys->i_segment_start_time = i_segment_start;
+                p_sys->i_resync_first_pcr = i_pcr;
+            }
+            else
+            {
+                msg_Err( p_demux, "failed to resync" );
+                p_sys->i_segment_start_time = var_InheritInteger( p_demux->s, "httplive-segment-start-time" );
+                p_sys->i_resync_first_pcr = i_pcr;
+            }
+
             p_sys->b_need_resync_pcr = false;
         }
 
diff --git a/modules/stream_filter/httplive.c b/modules/stream_filter/httplive.c
index fb916b2..6df1535 100644
--- a/modules/stream_filter/httplive.c
+++ b/modules/stream_filter/httplive.c
@@ -64,6 +64,7 @@ vlc_module_end()
 typedef struct segment_s
 {
     int         sequence;   /* unique sequence number */
+    int         start_time; /* segment start time (seconds) */
     int         duration;   /* segment duration (seconds) */
     uint64_t    size;       /* segment size in bytes */
     uint64_t    bandwidth;  /* bandwidth usage of segments (bits per second)*/
@@ -360,12 +361,13 @@ static uint64_t hls_GetStreamSize(hls_stream_t *hls)
 }
 
 /* Segment */
-static segment_t *segment_New(hls_stream_t* hls, const int duration, const char *uri)
+static segment_t *segment_New(hls_stream_t* hls, const int start_time, const int duration, const char *uri)
 {
     segment_t *segment = (segment_t *)malloc(sizeof(segment_t));
     if (segment == NULL)
         return NULL;
 
+    segment->start_time = start_time; /* seconds */
     segment->duration = duration; /* seconds */
     segment->size = 0; /* bytes */
     segment->sequence = 0;
@@ -607,7 +609,7 @@ static int parse_SegmentInformation(hls_stream_t *hls, char *p_read, int *durati
     return VLC_SUCCESS;
 }
 
-static int parse_AddSegment(hls_stream_t *hls, const int duration, const char *uri)
+static int parse_AddSegment(hls_stream_t *hls, const int start_time, const int duration, const char *uri)
 {
     assert(hls);
     assert(uri);
@@ -617,7 +619,7 @@ static int parse_AddSegment(hls_stream_t *hls, const int duration, const char *u
 
     char *psz_uri = relative_URI(hls->url, uri);
 
-    segment_t *segment = segment_New(hls, duration, psz_uri ? psz_uri : uri);
+    segment_t *segment = segment_New(hls, start_time, duration, psz_uri ? psz_uri : uri);
     if (segment)
         segment->sequence = hls->sequence + vlc_array_count(hls->segments) - 1;
     free(psz_uri);
@@ -1047,7 +1049,7 @@ static int parse_M3U8(stream_t *s, vlc_array_t *streams, uint8_t *buffer, const
 
         /* */
         int segment_duration = -1;
-        int total_duration_secs = 0;
+        int next_start_time = 0;
         do
         {
             /* Next line */
@@ -1060,10 +1062,6 @@ static int parse_M3U8(stream_t *s, vlc_array_t *streams, uint8_t *buffer, const
             {
                 segment_duration = 0;
                 err = parse_SegmentInformation(hls, line, &segment_duration);
-                if (err == VLC_SUCCESS && segment_duration > 0)
-                {
-                    total_duration_secs += segment_duration;
-                }
             }
             else if (strncmp(line, "#EXT-X-TARGETDURATION", 21) == 0)
                 err = parse_TargetDuration(s, hls, line);
@@ -1083,7 +1081,9 @@ static int parse_M3U8(stream_t *s, vlc_array_t *streams, uint8_t *buffer, const
                 err = parse_EndList(s, hls);
             else if ((strncmp(line, "#", 1) != 0) && (*line != '\0') )
             {
-                err = parse_AddSegment(hls, segment_duration, line);
+                err = parse_AddSegment(hls, next_start_time, segment_duration, line);
+                if (segment_duration > 0)
+                    next_start_time += segment_duration;
                 segment_duration = -1; /* reset duration */
             }
 
@@ -1095,10 +1095,10 @@ static int parse_M3U8(stream_t *s, vlc_array_t *streams, uint8_t *buffer, const
 
         } while (err == VLC_SUCCESS);
 
-        if (err == VLC_SUCCESS && total_duration_secs > 0)
+        if (err == VLC_SUCCESS && next_start_time > 0)
         {
             var_Create(s, "httplive-total-duration", VLC_VAR_INTEGER);
-            var_SetInteger(s, "httplive-total-duration", ((int64_t)total_duration_secs) * 1000 * 1000);
+            var_SetInteger(s, "httplive-total-duration", ((int64_t)next_start_time) * 1000 * 1000);
         }
 
         free(line);
@@ -2455,6 +2455,41 @@ static int segment_Seek(stream_t *s, const uint64_t pos)
     return b_found ? VLC_SUCCESS : VLC_EGENERIC;
 }
 
+static int hls_GetCurrentSegmentStartTime(stream_t *s, int64_t* p_segment_start_time)
+{
+    stream_sys_t *p_sys = s->p_sys;
+
+    hls_stream_t *hls = hls_Get(p_sys->hls_stream, p_sys->playback.stream);
+    if (hls == NULL)
+    {
+        msg_Err (s, "failed to hls_Get");
+        return VLC_EGENERIC;
+    }
+
+    vlc_mutex_lock(&hls->lock);
+
+
+    segment_t *segment = segment_GetSegment(hls, p_sys->playback.segment);
+    if (segment == NULL)
+    {
+        msg_Err (s, "failed to segment_GetSegment");
+        vlc_mutex_unlock(&hls->lock);
+        return VLC_EGENERIC;
+    }
+
+    vlc_mutex_lock(&segment->lock);
+    *p_segment_start_time = ((int64_t)segment->start_time) * 1000 * 1000;
+    if (*p_segment_start_time < 0)
+    {
+        msg_Err (s, "*p_segment_start_time < 0");
+    }
+    vlc_mutex_unlock(&segment->lock);
+
+    vlc_mutex_unlock(&hls->lock);
+
+    return VLC_SUCCESS;
+}
+
 static int Control(stream_t *s, int i_query, va_list args)
 {
     stream_sys_t *p_sys = s->p_sys;
@@ -2481,6 +2516,17 @@ static int Control(stream_t *s, int i_query, va_list args)
         case STREAM_GET_SIZE:
             *(va_arg (args, uint64_t *)) = GetStreamSize(s);
             break;
+        case STREAM_HTTPLIVE_GET_SEGMENT_START:
+            {
+                msg_Warn(s, "STREAM_HTTPLIVE_GET_SEGMENT_START");
+                int64_t segment_start = 0;
+                if (VLC_SUCCESS == hls_GetCurrentSegmentStartTime(s, &segment_start) && segment_start >= 0)
+                {
+                    *(va_arg (args, int64_t *)) = segment_start;
+                    return VLC_SUCCESS;
+                }
+            }
+            return VLC_EGENERIC;
         default:
             return VLC_EGENERIC;
     }
-- 
1.7.10.2

