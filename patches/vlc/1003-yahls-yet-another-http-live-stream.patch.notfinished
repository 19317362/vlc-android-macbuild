From 84fff7de240382e37054cacc492ef5671651b807 Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Wed, 25 Jul 2012 11:36:39 +0800
Subject: [PATCH 1003/1003] yahls: yet another http live stream

---
 modules/access/yahls/m3u8parser.c |  796 +++++++++++++++++++++++++++++++++++++
 modules/access/yahls/m3u8parser.h |  200 ++++++++++
 modules/access/yahls/yahls.c      |   24 ++
 3 个文件被修改，插入 1020 行(+)
 create mode 100644 modules/access/yahls/m3u8parser.c
 create mode 100644 modules/access/yahls/m3u8parser.h
 create mode 100644 modules/access/yahls/yahls.c

diff --git a/modules/access/yahls/m3u8parser.c b/modules/access/yahls/m3u8parser.c
new file mode 100644
index 0000000..d18de2c
--- /dev/null
+++ b/modules/access/yahls/m3u8parser.c
@@ -0,0 +1,796 @@
+/*****************************************************************************
+ * m3u8parser.c
+ *****************************************************************************
+ *
+ * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *  Version 1:
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-00
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-01
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-02
+ *  Version 2:
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-03
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-04
+ *  Version 3:
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-05
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-06
+ *  Version 4:
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-07
+ *      http://tools.ietf.org/html/draft-pantos-http-live-streaming-08
+ *
+ *  meta
+ *
+ *      #EXT-X-VERSION:[version]
+ *
+ *      #EXT-X-STREAM-INF:[attribute=value][,attribute=value]*
+ *      <URI>
+ *          v1 attrs
+ *              BANDWIDTH=<n>
+ *              PROGRAM-ID=<i>
+ *              CODECS="[format][,format]*"
+ *          v2 attrs
+ *              RESOLUTION=<N>x<M>
+ *          v4 attrs
+ *              AUDIO=""        EXT-X-MEDIA[TYPE=AUDIO][GROUP-ID]
+ *              VIDEO=""        EXT-X-MEDIA[TYPE=VIDEO][GROUP-ID]
+ *
+ *  play list
+ *
+ *      #EXTINF:<duration>,<title>
+ *      
+ *
+ *****************************************************************************/
+
+#include "m3u8parser.h"
+
+#include <vlc_memory.h>
+
+#include <assert.h>
+
+#define M3U8_MAX_PEEK_SIZE 100
+
+/* Read M3U8 file */
+static ssize_t m3u8_ReadAllFromStream( stream_t *p_stream, uint8_t **pp_buffer )
+{
+    int64_t i_total_bytes = 0;
+    int64_t i_total_allocated = 0;
+    uint8_t *p_buffer = NULL;
+
+    while (1)
+    {
+        char buf[4096];
+        int64_t i_bytes;
+
+        i_bytes = stream_Read( p_stream, buf, sizeof( buf ) );
+        if (i_bytes == 0)
+            break;      /* EOF ? */
+        else if (i_bytes < 0)
+            return i_bytes;
+
+        if ( (i_total_bytes + i_bytes + 1) > i_total_allocated )
+        {
+            if (i_total_allocated)
+                i_total_allocated *= 2;
+            else
+                i_total_allocated = __MIN( (uint64_t)i_bytes + 1, sizeof( buf ) );
+
+            p_buffer = realloc_or_free( p_stream, i_total_allocated );
+            if (p_buffer == NULL)
+                return VLC_ENOMEM;
+        }
+
+        memcpy( p_buffer + i_total_bytes, p_buffer, i_bytes );
+        i_total_bytes += i_bytes;
+    }
+
+    if (i_total_allocated == 0)
+        return VLC_EGENERIC;
+
+    p_buffer[i_total_bytes] = '\0';
+    *pp_buffer = p_buffer;
+
+    return i_total_bytes;
+}
+
+/* */
+static bool m3u8_IsM3U8Data( const uint8_t *peek, int size )
+{
+    if( size < 7 )
+        return false;
+
+    if( memcmp( peek, "#EXTM3U", 7 ) != 0 )
+        return false;
+    
+    peek += 7;
+    size -= 7;
+    
+    /* Parse stream and search for
+     * EXT-X-TARGETDURATION or EXT-X-STREAM-INF tag, see
+     * http://tools.ietf.org/html/draft-pantos-http-live-streaming-08#page-8 */
+    while( size-- )
+    {
+        static const char *const ext[] = {
+            "TARGETDURATION",
+            "MEDIA-SEQUENCE",
+            "KEY",
+            "ALLOW-CACHE",
+            "ENDLIST",
+            "STREAM-INF",
+            "DISCONTINUITY",
+            "VERSION"
+        };
+        
+        if( *peek++ != '#' )
+            continue;
+        
+        if( size < 6 )
+            continue;
+        
+        if( memcmp( peek, "EXT-X-", 6 ) )
+            continue;
+        
+        peek += 6;
+        size -= 6;
+        
+        for( size_t i = 0; i < ARRAY_SIZE( ext ); i++ )
+        {
+            size_t len = strlen( ext[i] );
+            if ( size < 0 || (size_t)size < len )
+                continue;
+            if ( !memcmp( peek, ext[i], len ) )
+                return true;
+        }
+    }
+    
+    return false;
+}
+
+/* */
+inline static bool m3u8_IsM3U8Stream( stream_t *p_stream )
+{
+    const uint8_t *peek;
+
+    int size = stream_Peek( p_stream, &peek, M3U8_MAX_PEEK_SIZE );
+    
+    return m3u8_IsM3U8Data( peek, size );
+}
+
+/*****************************************************************************
+ * Tokenize
+ *****************************************************************************/
+
+/* */
+static char *m3u8_TokenizeLine( uint8_t *p_begin, uint8_t *p_end, uint8_t **pp_next_line )
+{
+    uint8_t *p = p_begin;
+    while( p < p_end )
+    {
+        if( ( *p == '\r' ) || ( *p == '\n') || ( *p == '\0' ) )
+            break;
+        p++;
+    }
+
+    assert( p < p_end );
+    uint8_t *p_line_end = p;
+
+    *pp_next_line = p;
+    while( p < p_end && ( ( *p == '\r' ) || ( *p == '\n' ) || ( *p == '\0' ) ) )
+    {
+        /* next pass start after \r and \n */
+        p++;
+        *pp_next_line = p;
+    }
+
+    *p_line_end = '\0';
+    return (char *) p_begin;
+}
+
+/* */
+static char *m3u8_TokenizeAttrList( char *p_attr_list, char **pp_save )
+{
+    char *p = NULL;
+
+    if( p_attr_list )
+    {
+        p = strchr( p_attr_list, ':' );
+        if( p )
+            ++p;
+    }
+    else if( pp_save )
+    {
+        p = *pp_save;
+    }
+
+    if( !p || !*p )
+        return NULL;
+
+    /* trim head */
+    char ch = *p;
+    while( ch )
+    {
+        if( ch != ',' )
+            break;
+
+        *p = '\0';
+        p++;
+        ch = *p;
+    }
+
+    /* tokenize */
+    char *p_attr_pair_begin = p;
+    bool b_quoted = false;
+    while( ch )
+    {
+        if( !b_quoted && ch == ',' )
+            break;
+
+        if( ch == '"' )
+            b_quoted = !b_quoted;
+
+        p++;
+        ch = *p;
+    }
+
+    /* trim tail */
+    while( ch )
+    {
+        if( ch != ',' )
+            break;
+        
+        *p = '\0';
+        p++;
+        ch = *p;
+    }
+
+    *pp_save = p;
+    return p_attr_pair_begin;
+}
+
+static char *m3u8_TokenizeAttr( char *p_attr, char **pp_value)
+{
+    *pp_value = NULL;
+
+    char *p = strchr( p_attr, '=' );
+    if( !p )
+        return p_attr;
+
+    *p = '\0';
+    *pp_value = p + 1;
+
+    char *p_value = *pp_value;
+    if( *p_value == '"' )
+    {
+        int i_value_len = strlen( p_value );
+        if( i_value_len >= 2 && p_value[ i_value_len - 1 ] == '"')
+        {
+            *pp_value = p_value + 1;
+            p_value[ i_value_len - 1 ] = '\0';
+        }
+    }
+
+    return p_attr;
+}
+
+/*****************************************************************************
+ * Tokenize play list
+ *****************************************************************************/
+/* */
+static int m3u8_TokenizeAttr_EXTINF( vlc_object_t *p_this,
+                                     m3u8_segmentinf_t *p_segmentinf,
+                                     char *p_line )
+{
+    p_segmentinf->i_duration_ms = 0;
+
+    char *p_save = NULL;
+    char *p_attr_pair = m3u8_TokenizeAttrList( p_line, &p_save );
+    if( p_attr_pair && *p_attr_pair )
+    {
+        p_segmentinf->i_duration_ms = (int) ( atof( p_attr_pair ) * 1000 );
+    }
+
+    /* TODO: parse attr <title> */
+
+    if( p_segmentinf->i_duration_ms == 0 )
+        msg_Warn( p_this, "#EXTINF:<0>" );
+
+    return VLC_SUCCESS;
+}
+
+/* */
+static int m3u8_TokenizeAttr_EXT_X_TARGETDURATION( vlc_object_t *p_this,
+                                                   m3u8_playlist_t *p_playlist,
+                                                   char *p_line )
+{
+    p_playlist->i_target_duration_ms = 0;
+
+    char *p_save = NULL;
+    char *p_attr_pair = m3u8_TokenizeAttrList( p_line, &p_save );
+    if( p_attr_pair && *p_attr_pair )
+    {
+        p_playlist->i_target_duration_ms = atol( p_attr_pair ) * 1000;
+    }
+
+    if( p_playlist->i_target_duration_ms == 0 )
+        msg_Warn( p_this, "#EXT-X-TARGETDURATION:<0>" );
+
+    return VLC_SUCCESS;
+}
+
+/* */
+static int m3u8_TokenizeAttr_EXT_X_MEDIA_SEQUENCE( vlc_object_t *p_this,
+                                                  m3u8_playlist_t *p_playlist,
+                                                  char *p_line )
+{
+    p_playlist->i_media_sequence = 0;
+
+    char *p_save = NULL;
+    char *p_attr_pair = m3u8_TokenizeAttrList( p_line, &p_save );
+    if( p_attr_pair && *p_attr_pair )
+    {
+        p_playlist->i_media_sequence = atoll( p_attr_pair );
+    }
+
+    if( p_playlist->i_media_sequence == 0 )
+        msg_Warn( p_this, "#EXT-X_MEDIA_SEQUENCE:<0>" );
+
+    return VLC_SUCCESS;
+}
+
+/* */
+static m3u8_playlist_t *m3u8_TokenizePlayList( vlc_object_t *p_this,
+                                               uint8_t *p_begin,
+                                               uint8_t *p_end )
+{
+    uint8_t *p_next_line = p_begin;
+
+    m3u8_playlist_t *p_playlist = m3u8_AllocPlayList();
+    m3u8_segmentinf_t *p_next_segmentinf = m3u8_AllocSegmentInf();
+    bool b_expecting_url = false;
+    while( true )
+    {
+        p_begin = p_next_line;
+        if( p_begin >= p_end )
+            break;
+
+        char *p_line = m3u8_TokenizeLine( p_begin, p_end, &p_next_line );
+        if( p_line == NULL )
+            break;
+
+        int i_order = vlc_array_count( &p_playlist->segment_array );
+        int i_ret = VLC_EGENERIC;
+        if( *p_line != '#' )
+        {
+            if( b_expecting_url )
+            {
+                b_expecting_url = false;
+
+                msg_Dbg( p_this, "segment[%d] url: %s", i_order, p_line );
+
+                /* TODO: resolve relative url */
+                p_next_segmentinf->p_url = strdup( p_line );
+                
+                vlc_array_append( &p_playlist->segment_array, p_next_segmentinf );
+                p_next_segmentinf = m3u8_AllocSegmentInf();
+                if( !p_next_segmentinf )
+                    break;
+                
+                i_ret = VLC_SUCCESS;
+            }
+            else
+            {
+                msg_Err( p_this, "unexpected line: %s", p_line );
+            }
+        }
+        else if( 0 != strncmp( p_line, "#EXT", 4 ) )
+        {
+            /* Comment */
+            i_ret = VLC_SUCCESS;
+        }
+        else if( b_expecting_url )
+        {
+            b_expecting_url = false;
+            msg_Err( p_this, "expecting url before next TAG" );
+
+            /* reparse this line */
+            p_next_line = (uint8_t *) p_line;
+        }
+        else if( strncmp( p_line, "#EXTINF", 7 ) == 0 )
+        {
+            i_ret = m3u8_TokenizeAttr_EXTINF( p_this, p_next_segmentinf, p_line );
+            b_expecting_url = true;
+        }
+        else if( strncmp( p_line, "#EXT-X-TARGETDURATION", 21 ) == 0 )
+        {
+            i_ret = m3u8_TokenizeAttr_EXT_X_TARGETDURATION( p_this, p_playlist, p_line );
+        }
+        else if( strncmp( p_line, "#EXT-X-MEDIA-SEQUENCE", 21 ) == 0 )
+        {
+            if( p_playlist->i_media_sequence == 0 )
+                i_ret = m3u8_TokenizeAttr_EXT_X_MEDIA_SEQUENCE( p_this, p_playlist, p_line );
+            else
+                msg_Warn( p_this, "unexpected #EXT-X-MEDIA-SEQUENCE for 2nd time" );
+        }
+        else if( strncmp( p_line, "#EXT-X-ENDLIST", 14 ) == 0 )
+        {
+            p_playlist->b_endlist = true;
+            i_ret = VLC_SUCCESS;
+        }
+        else if( strncmp( p_line, "#EXT-X-DISCONTINUITY", 20 ) == 0 )
+        {
+            p_next_segmentinf->b_discontinuity = true;
+            i_ret = VLC_SUCCESS;
+        }
+        else if( strncmp( p_line, "#EXT-X-ALLOW-CACHE", 18 ) == 0 )
+        {
+            msg_Dbg( p_this, "#EXT-X-ALLOW-CACHE:<not support>" );
+        }
+        else
+        {
+            msg_Warn( p_this, "unknown line %s", p_line );
+        }
+    }
+
+    int i_segment_count = vlc_array_count( &p_playlist->segment_array );
+    if( 0 ==  i_segment_count)
+    {
+        msg_Err( p_this, "No playable segment found in playlist");
+        m3u8_FreePlayList( p_playlist );
+        p_playlist = NULL;
+    }
+    else
+    {
+        msg_Dbg( p_this, "%d segments loaded", i_segment_count );
+    }
+
+    return p_playlist;
+}
+
+/* */
+static m3u8_playlist_t *m3u8_LoadPlayListStream( vlc_object_t *p_this,
+                                                 stream_t *p_stream )
+{
+    if( m3u8_IsM3U8Stream( p_stream ) )
+    {
+        msg_Err( p_this, "not valid m3u8" );
+        return NULL;
+    }
+
+    uint8_t *p_buffer = NULL;
+    ssize_t i_length = m3u8_ReadAllFromStream( p_stream, &p_buffer );
+    if( i_length <= 0 )
+        return NULL;
+
+    m3u8_playlist_t *p_play_list = m3u8_TokenizePlayList( p_this, p_buffer, p_buffer + i_length );
+
+    free( p_buffer );
+    p_buffer = NULL;
+
+    return p_play_list;    
+}
+
+/* */
+static m3u8_playlist_t *m3u8_LoadPlayListUrl( vlc_object_t *p_this,
+                                              const char *p_url )
+{
+    stream_t *p_stream = stream_UrlNew( p_this, p_url );
+    if( !p_stream )
+    {
+        msg_Err( p_this, "failed to connect to m3u8 server %s", p_url );
+        return NULL;
+    }
+
+    m3u8_playlist_t *p_play_list = m3u8_LoadPlayListStream( p_this, p_stream );
+    stream_Delete( p_stream );
+    p_stream = NULL;
+
+    return p_play_list;
+}
+
+/*****************************************************************************
+ * Tokenize meta list
+ *****************************************************************************/
+static int m3u8_TokenizeAttr_EXT_X_VERSION( vlc_object_t *p_this,
+                                            m3u8_metalist_t *p_metalist,
+                                            char *p_line )
+{
+    p_metalist->i_version = 0;
+
+    char *p_save = NULL;
+    char *p_attr = m3u8_TokenizeAttrList( p_line, &p_save );
+    if( p_attr && *p_attr )
+    {
+        p_metalist->i_version = atol( p_attr );
+    }
+
+    if( p_metalist->i_version == 0 )
+        msg_Warn( p_this, "#EXT-X-VERSION:<0>" );
+
+    msg_Dbg( p_this, "#EXT-X-VERSION:%d", p_metalist->i_version );
+    return VLC_SUCCESS;
+}
+
+static int m3u8_TokenizeAttr_EXT_X_STREAM_INF( vlc_object_t *p_this,
+                                               m3u8_streaminf_t *p_streaminf,
+                                               char *p_line )
+{
+    p_streaminf->i_program_id = 0;
+    p_streaminf->i_bandwidth = 0;
+
+    char *p_save = NULL;
+    char *p_attr = m3u8_TokenizeAttrList( p_line, &p_save );
+    while( p_attr )
+    {
+        if( !*p_attr )
+            continue;
+        
+        char *p_attr_value = NULL;
+        char *p_attr_name = m3u8_TokenizeAttr( p_attr, &p_attr_value );
+        if( !p_attr_name || !*p_attr_name )
+            continue;
+
+        if( !p_attr_value  || !*p_attr_value )
+        {
+            msg_Warn( p_this, "%s=<null>", p_attr_name );
+            continue;
+        }
+
+        if( 0 == strncasecmp( p_attr_name, "PROGRAM-ID", 10 ) )
+        {
+            p_streaminf->i_program_id = atol( p_attr_value );
+            msg_Dbg( p_this, "PROGRAM-ID=%d", p_streaminf->i_program_id );
+        }
+        else if( 0 == strncasecmp( p_attr_name, "BANDWIDTH", 9 ) )
+        {
+            p_streaminf->i_bandwidth = atoll( p_attr_value );            
+            msg_Dbg( p_this, "BANDWIDTH=%"PRId64, p_streaminf->i_bandwidth );
+        }
+        else if( 0 == strncasecmp( p_attr_name, "CODECS", 6 ) )
+        {
+            msg_Dbg( p_this, "CODECS=<not support>" );
+        }
+        else if( 0 == strncasecmp( p_attr_name, "RESOLUTION", 10 ) )
+        {
+            msg_Dbg( p_this, "RESOLUTION=<not support>" );           
+        }
+        else if( 0 == strncasecmp( p_attr_name, "AUDIO", 5 ) )
+        {
+            msg_Dbg( p_this, "AUDIO=<not support>" );
+        }
+        else if( 0 == strncasecmp( p_attr_name, "VIDEO", 5 ) )
+        {
+            msg_Dbg( p_this, "VIDEO=<not support>" );
+        }
+        else
+        {
+            msg_Warn( p_this, "%s=<unexpected>", p_attr_name );
+        }
+
+        p_attr = m3u8_TokenizeAttrList( NULL, &p_save );
+    }
+
+    if( p_streaminf->i_program_id == 0 )
+        msg_Err( p_this, "missing program-id" );
+
+    if( p_streaminf->i_bandwidth == 0 )
+        msg_Err( p_this, "missing bandwidth" );
+
+    msg_Dbg( p_this, "#EXT-X-STREAM-INF:program-id=%d,bandwidth=%"PRIu64")",
+              p_streaminf->i_program_id,
+              p_streaminf->i_bandwidth );
+    return VLC_SUCCESS;
+}
+
+/* */
+static m3u8_metalist_t *m3u8_TokenizeMetaList( vlc_object_t *p_this,
+                                               uint8_t *p_begin,
+                                               uint8_t *p_end )
+{
+    uint8_t *p_next_line = p_begin;
+
+    m3u8_metalist_t *p_metalist = m3u8_AllocMetaList();
+    m3u8_streaminf_t *p_next_streaminf = m3u8_AllocStreamInf();
+    bool b_expecting_url = false;
+    while( true )
+    {
+        p_begin = p_next_line;
+        if( p_begin >= p_end )
+            break;
+
+        char *p_line = m3u8_TokenizeLine( p_begin, p_end, &p_next_line );
+        if( p_line == NULL )
+            break;
+
+        int i_order = vlc_array_count( &p_metalist->stream_array );
+        int i_ret = VLC_EGENERIC;
+        if( *p_line != '#' )
+        {
+            if( b_expecting_url )
+            {
+                b_expecting_url = false;
+
+                msg_Dbg( p_this, "stream[%d] url: %s", i_order, p_line );
+
+                /* TODO: retry */
+                p_next_streaminf->p_playlist = m3u8_LoadPlayListUrl( p_this, p_line );
+                if( !p_next_streaminf->p_playlist )
+                {
+                    msg_Err( p_this, "stream[%d] failed to load: %s", i_order, p_line );
+                }
+
+                /* TODO: resolve relative url */
+                p_next_streaminf->p_url = strdup( p_line );
+
+                vlc_array_append( &p_metalist->stream_array, p_next_streaminf );
+                p_next_streaminf = m3u8_AllocStreamInf();
+                if( !p_next_streaminf )
+                    break;
+
+                i_ret = VLC_SUCCESS;
+            }
+            else
+            {
+                msg_Err( p_this, "unexpected line: %s", p_line );
+            }
+        }
+        else if( 0 != strncmp( p_line, "#EXT", 4 ) )
+        {
+            /* Comment */
+            i_ret = VLC_SUCCESS;
+        }
+        else if( b_expecting_url )
+        {
+            b_expecting_url = false;
+            msg_Err( p_this, "expecting url before next TAG" );
+            
+            /* reparse this line */
+            p_next_line = (uint8_t *) p_line;
+        }
+        else if( 0 == strncmp( p_line, "#EXT-X-STREAM-INF", 17 ) )
+        {
+            i_ret = m3u8_TokenizeAttr_EXT_X_STREAM_INF( p_this, p_next_streaminf, p_line );
+            b_expecting_url = true;
+        }
+        else if( 0 == strncmp( p_line, "#EXT-X-VERSION", 14 ) )
+        {
+            i_ret = m3u8_TokenizeAttr_EXT_X_VERSION( p_this, p_metalist, p_line );
+        }
+        else
+        {
+            msg_Warn( p_this, "unknown line %s", p_line );
+        }
+    }
+
+    if( p_next_streaminf )
+    {
+        m3u8_FreeStreamInf( p_next_streaminf );
+        p_next_streaminf = NULL;
+    }
+
+    int i_stream_count = vlc_array_count( &p_metalist->stream_array );
+    if( 0 ==  i_stream_count )
+    {
+        msg_Err( p_this, "No playable streams found in metalist");
+        m3u8_FreeMetaList( p_metalist );
+        p_metalist = NULL;
+    }
+    else
+    {
+        msg_Dbg( p_this, "%d stream loaded", i_stream_count );
+    }
+
+    return p_metalist;
+}
+
+/* */
+static m3u8_metalist_t *m3u8_Tokenize( vlc_object_t *p_this,
+                                       uint8_t *p_begin,
+                                       uint8_t *p_end )
+{
+    uint8_t *p_next_line = NULL;
+
+    char *p_line = m3u8_TokenizeLine(p_begin, p_end, &p_next_line);
+    if ( p_line == NULL )
+        return NULL;
+
+    if ( strncmp( p_line, "#EXTM3U", 7 ) != 0 )
+    {
+        msg_Err( p_this, "missing #EXTM3U tag .. aborting" );
+        return NULL;
+    }
+
+    m3u8_metalist_t *p_metalist = NULL;
+    const char* p_find_stream_info = strstr( (const char *)p_next_line,
+                                             "#EXT-X-STREAM-INF" );
+    if( p_find_stream_info )
+    {
+        /* playlist */
+        m3u8_streaminf_t *p_streaminf = NULL;
+
+        p_metalist = m3u8_AllocMetaList();
+        if( !p_metalist )
+            goto EXIT_FAIL;
+
+        p_streaminf = m3u8_AllocStreamInf();
+        if( !p_streaminf )
+            goto EXIT_FAIL;
+        vlc_array_append( &p_metalist->stream_array, p_streaminf );
+
+        p_streaminf->p_playlist = m3u8_TokenizePlayList( p_this, p_next_line, p_end );
+        if( !p_streaminf->p_playlist )
+            goto EXIT_FAIL;
+    }
+    else
+    {
+        /* metalist */
+        p_metalist = m3u8_TokenizeMetaList( p_this, p_next_line, p_end );        
+    }
+
+    return p_metalist;
+
+EXIT_FAIL:
+
+    if( p_metalist )
+    {
+        m3u8_FreeMetaList( p_metalist );
+        p_metalist = NULL;
+    }
+
+    return NULL;
+}
+
+/* */
+static m3u8_metalist_t *m3u8_LoadStream( vlc_object_t *p_this,
+                                         stream_t *p_stream )
+{
+    if( m3u8_IsM3U8Stream( p_stream ) )
+    {
+        msg_Err( p_this, "not valid m3u8" );
+        return NULL;
+    }
+
+    uint8_t *p_buffer = NULL;
+    ssize_t i_length = m3u8_ReadAllFromStream( p_stream, &p_buffer );
+    if( i_length <= 0 )
+        return NULL;
+
+    m3u8_metalist_t *p_meta_list = m3u8_Tokenize( p_this, p_buffer, p_buffer + i_length );
+
+    free( p_buffer );
+    p_buffer = NULL;
+
+    return p_meta_list;    
+}
+
+/* */
+static m3u8_metalist_t *m3u8_LoadUrl( vlc_object_t *p_this, const char *p_url )
+{
+    stream_t *p_stream = stream_UrlNew( p_this, p_url );
+    if( !p_stream )
+    {
+        msg_Err( p_this, "failed to connect to m3u8 server %s", p_url );
+        return NULL;
+    }
+
+    m3u8_metalist_t *p_meta_list = m3u8_LoadStream( p_this, p_stream );
+    stream_Delete( p_stream );
+    p_stream = NULL;
+
+    return p_meta_list;
+}
\ No newline at end of file
diff --git a/modules/access/yahls/m3u8parser.h b/modules/access/yahls/m3u8parser.h
new file mode 100644
index 0000000..28d05a0
--- /dev/null
+++ b/modules/access/yahls/m3u8parser.h
@@ -0,0 +1,200 @@
+/*****************************************************************************
+ * m3u8parser.h
+ *****************************************************************************
+ *
+ * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+
+#ifndef M3U8PARSER_H
+#define M3U8PARSER_H
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_stream.h>
+
+typedef struct
+{
+    char        *p_url;
+
+    bool        b_discontinuity;
+    int         i_duration_ms;          /* millisecond */
+} m3u8_segmentinf_t;
+
+typedef struct
+{
+    bool        b_endlist;
+
+    int         i_target_duration_ms;   /* millisecond */
+    int64_t     i_media_sequence;
+
+    vlc_array_t segment_array;
+} m3u8_playlist_t;
+
+typedef struct
+{
+    const char      *p_url;
+
+    /* v1 attrs */
+    int             i_program_id;
+    int64_t         i_bandwidth;
+
+    /* v2 attrs */
+    /* v3 attrs */
+    /* v4 attrs */
+
+    /* references */
+    m3u8_playlist_t *p_playlist;
+
+} m3u8_streaminf_t;
+
+typedef struct
+{
+    /* tags */
+    int         i_version;
+
+    vlc_array_t stream_array;
+} m3u8_metalist_t;
+
+
+static m3u8_metalist_t *m3u8_LoadUrl( vlc_object_t *p_this, const char *p_url );
+
+/* m3u8_segmentinf_t */
+inline static m3u8_segmentinf_t *m3u8_AllocSegmentInf()
+{
+    m3u8_segmentinf_t *p_segmentinf = (m3u8_segmentinf_t *) malloc( sizeof(m3u8_segmentinf_t) );
+    if( !p_segmentinf )
+        return NULL;
+
+    memset( p_segmentinf, 0, sizeof( m3u8_segmentinf_t ) );
+    return p_segmentinf;
+}
+
+inline static void m3u8_FreeSegmentInf( m3u8_segmentinf_t *p_segmentinf )
+{
+    if( !p_segmentinf )
+        return;
+
+    if( p_segmentinf->p_url )
+    {
+        free( p_segmentinf->p_url );
+        p_segmentinf->p_url = NULL;
+    }
+
+    free( p_segmentinf );
+}
+
+/* m3u8_playlist_t */
+inline static m3u8_playlist_t *m3u8_AllocPlayList()
+{
+    m3u8_playlist_t *p_playlist = (m3u8_playlist_t *) malloc( sizeof(m3u8_playlist_t) );
+    if( !p_playlist )
+        return NULL;
+    
+    memset( p_playlist, 0, sizeof( m3u8_playlist_t ) );
+
+    vlc_array_init( &p_playlist->segment_array );
+
+    return p_playlist;
+}
+
+inline static void m3u8_FreePlayList( m3u8_playlist_t *p_playlist )
+{
+    if( !p_playlist )
+        return;
+
+    int i_count = vlc_array_count( &p_playlist->segment_array );
+    for( int i = 0; i < i_count; ++i )
+    {
+        m3u8_segmentinf_t *p_segmentinf =
+        (m3u8_segmentinf_t *) vlc_array_item_at_index( &p_playlist->segment_array, i );
+        
+        if( p_segmentinf )
+            m3u8_FreeSegmentInf( p_segmentinf );
+    }
+
+    vlc_array_clear( &p_playlist->segment_array );
+
+    free( p_playlist );
+}
+
+/* m3u8_stream_t */
+inline static m3u8_streaminf_t *m3u8_AllocStreamInf()
+{
+    m3u8_streaminf_t *p_streaminf = (m3u8_streaminf_t *) malloc( sizeof(m3u8_streaminf_t) );
+    if( !p_streaminf )
+        return NULL;
+
+    memset( p_streaminf, 0, sizeof( m3u8_streaminf_t ) );
+    return p_streaminf;
+}
+
+inline static void m3u8_FreeStreamInf( m3u8_streaminf_t *p_streaminf )
+{
+    if( !p_streaminf )
+        return;
+
+    if( p_streaminf->p_playlist )
+    {
+        m3u8_FreePlayList( p_streaminf->p_playlist );
+        p_streaminf->p_playlist = NULL;
+    }
+
+    free( p_streaminf );
+}
+
+/* m3u8_metalist_t */
+inline static m3u8_metalist_t *m3u8_AllocMetaList()
+{
+    m3u8_metalist_t *p_metalist = (m3u8_metalist_t *) malloc( sizeof(m3u8_metalist_t) );
+    if( !p_metalist )
+        return NULL;
+
+    memset( p_metalist, 0, sizeof( m3u8_metalist_t ) );
+
+    vlc_array_init( &p_metalist->stream_array );
+
+    return p_metalist;
+}
+
+inline static void m3u8_FreeMetaList( m3u8_metalist_t *p_metalist )
+{
+    if( !p_metalist )
+        return;
+
+    int i_count = vlc_array_count( &p_metalist->stream_array );
+    for( int i = 0; i < i_count; ++i )
+    {
+        m3u8_streaminf_t *p_streaminf =
+            (m3u8_streaminf_t *) vlc_array_item_at_index( &p_metalist->stream_array, i );
+
+        if( p_streaminf )
+            m3u8_FreeStreamInf( p_streaminf );
+    }
+
+    vlc_array_clear( &p_metalist->stream_array );
+
+    free( p_metalist );
+}
+
+#endif
\ No newline at end of file
diff --git a/modules/access/yahls/yahls.c b/modules/access/yahls/yahls.c
new file mode 100644
index 0000000..c3a46f5
--- /dev/null
+++ b/modules/access/yahls/yahls.c
@@ -0,0 +1,24 @@
+/*****************************************************************************
+ * yahttplive.c: Yet another httplive
+ *****************************************************************************
+ *
+ * Authors: Rui Zhang <bbcallen _AT_ gmail _DOT_ com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
-- 
1.7.10.4

