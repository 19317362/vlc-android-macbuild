From 7eedc736330fc3c7b87fe78a09cea9bcf34a58ac Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Thu, 14 Jun 2012 16:44:57 +0800
Subject: [PATCH 14/27] httplive: skip failed segment for live stream

---
 modules/stream_filter/httplive.c |   85 +++++++++++++++++++++++++++++++++++++-
 1 个文件被修改，插入 83 行(+)，删除 2 行(-)

diff --git a/modules/stream_filter/httplive.c b/modules/stream_filter/httplive.c
index c643e57..926cbde 100644
--- a/modules/stream_filter/httplive.c
+++ b/modules/stream_filter/httplive.c
@@ -127,6 +127,10 @@ struct stream_sys_t
         int         stream;     /* current hls_stream  */
         int         segment;    /* current segment for playback */
         int         current_segment_start_time; /* (seconds) */
+
+        /* live only */
+        vlc_mutex_t lock_wait;  /* protect condition */
+        vlc_cond_t  wait;       /* wait download finished */
     } playback;
 
     /* Playlist */
@@ -144,6 +148,7 @@ struct stream_sys_t
     bool        b_error;    /* parsing error */
     bool        b_aesmsg;   /* only print one time that the media is encrypted */
 
+    volatile bool b_live_eof; /* end of live */
     volatile bool b_close;  /* true if Close called */
     vlc_mutex_t lock_close; /* for reload and download thread */
     vlc_cond_t  cond_close; /* for reload and download thread */
@@ -1634,8 +1639,9 @@ static void* hls_Thread(void *p_this)
         segment_t *segment = segment_GetSegment(hls, p_sys->download.segment);
         vlc_mutex_unlock(&hls->lock);
 
+        int download_ret = VLC_EGENERIC;
         if ((segment != NULL) &&
-            (hls_DownloadSegmentData(s, hls, segment, &p_sys->download.stream) != VLC_SUCCESS))
+            ((download_ret = hls_DownloadSegmentData(s, hls, segment, &p_sys->download.stream)) != VLC_SUCCESS))
         {
             if (!vlc_object_alive(s)) break;
 
@@ -1661,6 +1667,23 @@ static void* hls_Thread(void *p_this)
             p_sys->download.segment++;
         vlc_cond_signal(&p_sys->download.wait);
         vlc_mutex_unlock(&p_sys->download.lock_wait);
+
+        /* wake up playback thread (Read() thread) */
+        if (p_sys->b_live && download_ret == VLC_SUCCESS)
+        {
+            vlc_mutex_lock(&p_sys->playback.lock_wait);
+            vlc_cond_signal(&p_sys->playback.wait);
+            vlc_mutex_unlock(&p_sys->playback.lock_wait);
+        }
+    }
+
+    /* wake up playback thread (Read() thread) */
+    if (p_sys->b_live)
+    {
+        vlc_mutex_lock(&p_sys->playback.lock_wait);
+        vlc_cond_signal(&p_sys->playback.wait);
+        vlc_mutex_unlock(&p_sys->playback.lock_wait);
+        p_sys->b_live_eof = true;
     }
 
     vlc_restorecancel(canc);
@@ -1718,6 +1741,14 @@ static void* hls_Reload(void *p_this)
         vlc_mutex_unlock(&p_sys->lock_close);
     }
 
+    if (p_sys->b_live)
+    {
+        vlc_mutex_lock(&p_sys->playback.lock_wait);
+        vlc_cond_signal(&p_sys->playback.wait);
+        vlc_mutex_unlock(&p_sys->playback.lock_wait);
+        p_sys->b_live_eof = true;
+    }
+
     vlc_restorecancel(canc);
     return NULL;
 }
@@ -2064,6 +2095,9 @@ static int Open(vlc_object_t *p_this)
     vlc_mutex_init(&p_sys->lock_close);
     vlc_cond_init(&p_sys->cond_close);
 
+    vlc_mutex_init(&p_sys->playback.lock_wait);
+    vlc_cond_init(&p_sys->playback.wait);
+
     /* Initialize HLS live stream */
     if (p_sys->b_live)
     {
@@ -2126,6 +2160,10 @@ static void Close(vlc_object_t *p_this)
     vlc_cond_signal(&p_sys->cond_close);
     vlc_mutex_unlock(&p_sys->lock_close);
 
+    vlc_mutex_lock(&p_sys->playback.lock_wait);
+    vlc_cond_signal(&p_sys->playback.wait);
+    vlc_mutex_unlock(&p_sys->playback.lock_wait);
+
     /* */
     if (p_sys->b_live)
         vlc_join(p_sys->reload, NULL);
@@ -2263,12 +2301,52 @@ static ssize_t hls_Read(stream_t *s, uint8_t *p_read, unsigned int i_read)
 
     do
     {
+        /* Is there any downloaded segment to play? */
+        if (p_sys->b_live && !p_sys->b_live_eof)
+        {
+            hls_stream_t *hls = hls_Get(p_sys->hls_stream, p_sys->download.stream);
+            assert(hls);
+
+            vlc_mutex_lock(&hls->lock);
+            int count = vlc_array_count(hls->segments);
+            vlc_mutex_unlock(&hls->lock);
+
+            /* for live stream, we do not care about seek here */
+            if (p_sys->playback.segment >= p_sys->download.segment)
+            {
+                /* wait */
+                vlc_mutex_lock(&p_sys->playback.lock_wait);
+                while (p_sys->playback.segment >= p_sys->download.segment)
+                {
+                    msg_Warn(s, "may stalling, wait for segment downloading");
+                    vlc_cond_wait(&p_sys->download.wait, &p_sys->playback.lock_wait);
+                    if (!vlc_object_alive(s) || p_sys->b_close || p_sys->b_live_eof)
+                        break;
+                }
+                vlc_mutex_unlock(&p_sys->playback.lock_wait);
+            }
+
+            if (!vlc_object_alive(s) || p_sys->b_close || p_sys->b_live_eof)
+                break;
+        }
+
         /* Determine next segment to read. If this is a meta playlist and
          * bandwidth conditions changed, then the stream might have switched
          * to another bandwidth. */
         segment_t *segment = GetSegment(s);
         if (segment == NULL)
-            break;
+        {
+            if (!p_sys->b_live)
+                break;
+
+            if (!vlc_object_alive(s) || p_sys->b_close || p_sys->b_live_eof)
+                break;
+
+            /* for live stream, there is no EOF */
+            msg_Err(s, "NULL segment, try next segment");
+            p_sys->playback.segment++;
+            continue;
+        }
 
         vlc_mutex_lock(&segment->lock);
         if (segment->data->i_buffer == 0)
@@ -2315,6 +2393,9 @@ static ssize_t hls_Read(stream_t *s, uint8_t *p_read, unsigned int i_read)
 
     } while (i_read > 0);
 
+    if (used <= 0)
+        msg_Err(s, "httplive:hls_Read read %d bytes", (int)used);
+
     return used;
 }
 
-- 
1.7.10.4

