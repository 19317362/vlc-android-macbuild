From eae2eabac4b22a6f353695e446a8053af70b01cd Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Mon, 3 Sep 2012 12:09:42 +0800
Subject: [PATCH] libvlcjni: set/get

---
 vlc-android/jni/libvlcjni_danmaku.c                |  598 +++++++++++---------
 .../jni/libvlcjni_danmaku_event_callback.inc.c     |  108 ++++
 .../jni/libvlcjni_danmaku_nativeInitEx.inc.c       |   38 ++
 .../jni/libvlcjni_danmaku_readMediaEx.inc.c        |   76 +++
 4 个文件被修改，插入 564 行(+)，删除 256 行(-)
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_event_callback.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
 create mode 100644 vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c

diff --git a/vlc-android/jni/libvlcjni_danmaku.c b/vlc-android/jni/libvlcjni_danmaku.c
index a7bcdad..b10b71a 100644
--- a/vlc-android/jni/libvlcjni_danmaku.c
+++ b/vlc-android/jni/libvlcjni_danmaku.c
@@ -48,6 +48,82 @@
 #define AOUT_AUDIOTRACK_JAVA 1
 #define AOUT_OPENSLES        2
 
+static jint getInt(JNIEnv *env, jobject thiz, const char* field) {
+    jclass clazz = (*env)->GetObjectClass(env, thiz);
+    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
+                                          field, "I");
+    return (*env)->GetIntField(env, thiz, fieldMP);
+}
+static void setInt(JNIEnv *env, jobject item, const char* field, jint value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "I");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetIntField(env, item, fieldId, value);
+}
+
+static jlong getLong(JNIEnv *env, jobject thiz, const char* field) {
+    jclass clazz = (*env)->GetObjectClass(env, thiz);
+    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
+                                          field, "J");
+    return (*env)->GetLongField(env, thiz, fieldMP);
+}
+static void setLong(JNIEnv *env, jobject item, const char* field, jlong value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "J");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetLongField(env, item, fieldId, value);
+}
+
+static void setFloat(JNIEnv *env, jobject item, const char* field, jfloat value) {
+    jclass cls;
+    jfieldID fieldId;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "F");
+    if (fieldId == NULL)
+        return;
+
+    (*env)->SetFloatField(env, item, fieldId, value);
+}
+static void setString(JNIEnv *env, jobject item, const char* field, const char* text) {
+    jclass cls;
+    jfieldID fieldId;
+    jstring jstr;
+
+    /* Get a reference to item's class */
+    cls = (*env)->GetObjectClass(env, item);
+
+    /* Look for the instance field s in cls */
+    fieldId = (*env)->GetFieldID(env, cls, field, "Ljava/lang/String;");
+    if (fieldId == NULL)
+        return;
+
+    /* Create a new string and overwrite the instance field */
+    jstr = (*env)->NewStringUTF(env, text);
+    if (jstr == NULL)
+        return;
+    (*env)->SetObjectField(env, item, fieldId, jstr);
+}
+
 struct length_change_monitor {
     pthread_mutex_t doneMutex;
     pthread_cond_t doneCondVar;
@@ -63,7 +139,7 @@ static void length_changed_callback(const libvlc_event_t *ev, void *data)
     pthread_mutex_unlock(&monitor->doneMutex);
 }
 
-libvlc_media_t *new_media(jint instance, JNIEnv *env, jobject thiz, jstring fileLocation, bool noOmx, bool noVideo)
+libvlc_media_t *new_media(jlong instance, JNIEnv *env, jobject thiz, jstring fileLocation, bool noOmx, bool noVideo)
 {
     libvlc_instance_t *libvlc = (libvlc_instance_t*)instance;
     jboolean isCopy;
@@ -74,26 +150,52 @@ libvlc_media_t *new_media(jint instance, JNIEnv *env, jobject thiz, jstring file
         return NULL;
 
     if (!noOmx) {
+#if 0
+        jclass cls = (*env)->GetObjectClass(env, thiz);
+        jmethodID methodId = (*env)->GetMethodID(env, cls, "useIOMX", "()Z");
+        if ((*env)->CallBooleanMethod(env, thiz, methodId)) {
+            /*
+             * Set higher caching values if using iomx decoding, since some omx
+             * decoders have a very high latency, and if the preroll data isn't
+             * enough to make the decoder output a frame, the playback timing gets
+             * started too soon, and every decoded frame appears to be too late.
+             * On Nexus One, the decoder latency seems to be 25 input packets
+             * for 320x170 H.264, a few packets less on higher resolutions.
+             * On Nexus S, the decoder latency seems to be about 7 packets.
+             */
+            libvlc_media_add_option(p_md, ":file-caching=1500");
+            libvlc_media_add_option(p_md, ":network-caching=1500");
+            libvlc_media_add_option(p_md, ":codec=iomx,all");
+        }
+#endif
         if (noVideo)
             libvlc_media_add_option(p_md, ":no-video");
     }
     return p_md;
 }
 
+#if 0
+static libvlc_media_list_t *getMediaList(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_list_t*)getLong(env, thiz, "mMediaListInstance");
+}
+#endif
+
 static libvlc_media_player_t *getMediaPlayer(JNIEnv *env, jobject thiz)
 {
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
-                                          "mMediaPlayerInstance", "I");
-    return (libvlc_media_player_t*)(*env)->GetIntField(env, thiz, fieldMP);
+    return (libvlc_media_player_t*)getLong(env, thiz, "mInternalMediaPlayerInstance");
 }
 
+#if 0
+static libvlc_media_list_player_t *getMediaListPlayer(JNIEnv *env, jobject thiz)
+{
+    return (libvlc_media_list_player_t*)getLong(env, thiz, "mMediaListPlayerInstance");
+}
+#endif
+
 static void unsetMediaPlayer(JNIEnv *env, jobject thiz)
 {
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID fieldMP = (*env)->GetFieldID(env, clazz,
-                                          "mMediaPlayerInstance", "I");
-    (*env)->SetIntField(env, thiz, fieldMP, 0);
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)0);
 }
 
 static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
@@ -104,6 +206,7 @@ static void releaseMediaPlayer(JNIEnv *env, jobject thiz)
         libvlc_media_player_stop(mp);
         libvlc_media_player_release(mp);
         unsetMediaPlayer(env, thiz);
+        setLong(env, thiz, "mInternalMediaPlayerInstance", 0);
     }
 }
 
@@ -145,6 +248,8 @@ void jni_SetAndroidSurfaceSize(int width, int height)
     (*myVm)->DetachCurrentThread (myVm);
 }
 
+#include "libvlcjni_danmaku_event_callback.inc.c"
+#if 0
 static void vlc_event_callback(const libvlc_event_t *ev, void *data)
 {
     JNIEnv *env;
@@ -157,14 +262,56 @@ static void vlc_event_callback(const libvlc_event_t *ev, void *data)
 
     int status = (*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2);
     if (status < 0) {
-        //LOGD("vlc_event_callback: failed to get JNI environment, "
-        //     "assuming native thread");
+        LOGD("vlc_event_callback: failed to get JNI environment, "
+             "assuming native thread");
         status = (*myVm)->AttachCurrentThread(myVm, &env, NULL);
         if (status < 0)
             return;
         isAttached = true;
     }
 
+    /* Creating the bundle in C allows us to subscribe to more events
+     * and get better flexibility for each event. For example, we can
+     * have totally different types of data for each event, instead of,
+     * for example, only an integer and/or string.
+     */
+    jclass clsBundle = (*env)->FindClass(env, "android/os/Bundle");
+    jmethodID clsCtor = (*env)->GetMethodID(env, clsBundle, "<init>", "()V" );
+    jobject bundle = (*env)->NewObject(env, clsBundle, clsCtor);
+
+    jmethodID putInt = (*env)->GetMethodID(env, clsBundle, "putInt", "(Ljava/lang/String;I)V" );
+    jmethodID putString = (*env)->GetMethodID(env, clsBundle, "putString", "(Ljava/lang/String;Ljava/lang/String;)V" );
+
+    if(ev->type == libvlc_MediaPlayerVout) {
+        /* For determining the vout/ES track change */
+        jstring sData = (*env)->NewStringUTF(env, "data");
+        (*env)->CallVoidMethod(env, bundle, putInt, sData, ev->u.media_player_vout.new_count);
+        (*env)->DeleteLocalRef(env, sData);
+    } else if(ev->type == libvlc_MediaListItemAdded ||
+              ev->type == libvlc_MediaListItemDeleted ) {
+        jstring item_uri = (*env)->NewStringUTF(env, "item_uri");
+        jstring item_index = (*env)->NewStringUTF(env, "item_index");
+        char* mrl = libvlc_media_get_mrl(
+            ev->type == libvlc_MediaListItemAdded ?
+            ev->u.media_list_item_added.item :
+            ev->u.media_list_item_deleted.item
+            );
+        jstring item_uri_value = (*env)->NewStringUTF(env, mrl);
+        jint item_index_value;
+        if(ev->type == libvlc_MediaListItemAdded)
+            item_index_value = ev->u.media_list_item_added.index;
+        else
+            item_index_value = ev->u.media_list_item_deleted.index;
+
+        (*env)->CallVoidMethod(env, bundle, putString, item_uri, item_uri_value);
+        (*env)->CallVoidMethod(env, bundle, putInt, item_index, item_index_value);
+
+        (*env)->DeleteLocalRef(env, item_uri);
+        (*env)->DeleteLocalRef(env, item_uri_value);
+        (*env)->DeleteLocalRef(env, item_index);
+        free(mrl);
+    }
+
     /* Get the object class */
     jclass cls = (*env)->GetObjectClass(env, eventManagerInstance);
     if (!cls) {
@@ -172,74 +319,19 @@ static void vlc_event_callback(const libvlc_event_t *ev, void *data)
         goto end;
     }
 
-    jobject eventObject = NULL;
-
     /* Find the callback ID */
-    jmethodID methodObtain = (*env)->GetMethodID(env, cls, "obtainEventObject", "()Lorg/videolan/vlc/LibVlcEvent;");
-    if (methodObtain) {
-        eventObject = (*env)->CallObjectMethod(env, eventManagerInstance, methodObtain);
-        if (eventObject == NULL) {
-            LOGE("EventManager: failed to obtainEventObject");
-            goto end;
-        }
-    } else {
-        LOGE("EventManager: failed to get the obtainEventObject method");
-        goto end;
-    }
-
-    setInt(env, eventObject, "mEventType", (int)ev->type);
-
-    switch (ev->type) {
-    case libvlc_MediaPlayerBuffering: {
-        float cache = ev->u.media_player_buffering.new_cache;
-        vlc_event_set_float(env, eventObject, cache);
-        break;
-    }
-    case libvlc_MediaPlayerSeekableChanged: {
-        int seekable = ev->u.media_player_seekable_changed.new_seekable;
-        vlc_event_set_int(env, eventObject, seekable);
-        break;
-    }
-    case libvlc_MediaPlayerPausableChanged: {
-        int pausable = ev->u.media_player_pausable_changed.new_pausable;
-        vlc_event_set_int(env, eventObject, pausable);
-        break;
-    }
-    case libvlc_MediaPlayerBufferingTotal: {
-        float cache = ev->u.media_player_buffering_total.new_cache_total;
-        vlc_event_set_float(env, eventObject, cache);
-        break;
-    }
-    case libvlc_MediaPlayerModuleChanged: {
-        char *p_module_list = NULL;
-        asprintf(&p_module_list,
-                 "video-decoder=%s;audio-decoder=%s;video-decoder-impl=%s;audio-decoder-impl=%s",
-                 ev->u.media_player_module_changed.psz_video_decoder ? ev->u.media_player_module_changed.psz_video_decoder : "",
-                 ev->u.media_player_module_changed.psz_audio_decoder ? ev->u.media_player_module_changed.psz_audio_decoder : "",
-                 ev->u.media_player_module_changed.psz_video_decoder_impl ? ev->u.media_player_module_changed.psz_video_decoder_impl : "",
-                 ev->u.media_player_module_changed.psz_audio_decoder_impl ? ev->u.media_player_module_changed.psz_audio_decoder_impl : "");
-        vlc_event_set_string(env, eventObject, p_module_list);
-        free(p_module_list);
-        break;
-    }
-    }
-
-    /* Find the callback ID */
-    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILorg/videolan/vlc/LibVlcEvent;)V");
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback", "(ILandroid/os/Bundle;)V");
     if (methodID) {
-        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type, eventObject);
+        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type, bundle);
     } else {
         LOGE("EventManager: failed to get the callback method");
-        goto end;
     }
 
 end:
-    if (eventObject)
-        (*env)->DeleteLocalRef(env, eventObject);
-
     if (isAttached)
         (*myVm)->DetachCurrentThread(myVm);
 }
+#endif
 
 jint JNI_OnLoad(JavaVM *vm, void *reserved)
 {
@@ -319,6 +411,8 @@ void Java_org_videolan_vlc_LibVLC_changeVerbosity(JNIEnv *env, jobject thiz, jbo
     libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
 }
 
+#include "libvlcjni_danmaku_nativeInitEx.inc.c"
+#if 0
 void Java_org_videolan_vlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz, jboolean verbose)
 {
     //only use OpenSLES if java side says we can
@@ -326,6 +420,9 @@ void Java_org_videolan_vlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz, jboolean
     jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
     bool use_opensles = (*env)->CallIntMethod(env, thiz, methodId) == AOUT_OPENSLES;
 
+    methodId = (*env)->GetMethodID(env, cls, "timeStretchingEnabled", "()Z");
+    bool enable_time_stretch = (*env)->CallBooleanMethod(env, thiz, methodId);
+
     verbosity = verbose;
     libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
 
@@ -338,13 +435,12 @@ void Java_org_videolan_vlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz, jboolean
         "--no-plugins-cache",
         "--no-drop-late-frames",
         "--avcodec-fast",
+        enable_time_stretch ? "--audio-time-stretch" : "--no-audio-time-stretch",
         use_opensles ? "--aout=opensles" : "--aout=android_audiotrack",
     };
     libvlc_instance_t *instance = libvlc_new(sizeof(argv) / sizeof(*argv), argv);
 
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID field = (*env)->GetFieldID(env, clazz, "mLibVlcInstance", "I");
-    (*env)->SetIntField(env, thiz, field, (jint) instance);
+    setLong(env, thiz, "mLibVlcInstance", (jlong) instance);
 
     if (!instance)
     {
@@ -353,48 +449,27 @@ void Java_org_videolan_vlc_LibVLC_nativeInit(JNIEnv *env, jobject thiz, jboolean
     }
 
     LOGI("LibVLC initialized: %p", instance);
-}
 
-void Java_org_videolan_vlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jboolean verbose, jarray arguments)
-{
-    libvlc_instance_t *instance = NULL;
-    if (arguments == NULL) {
-        Java_org_videolan_vlc_LibVLC_nativeInit(env, thiz, false);
+    /* Initialize media list (a.k.a. playlist/history) */
+    libvlc_media_list_t* pointer = libvlc_media_list_new( instance );
+    if(!pointer) {
+        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to create LibVLC media list");
         return;
     }
 
-    verbosity = verbose;
-    libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
-
-    int user_argc = (*env)->GetArrayLength(env, arguments);
-    char **user_argv = (char **) calloc(user_argc, sizeof(char *));
-    int i = 0;
-    for (i = 0; i < user_argc; i++)
-    {
-        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
-        if (argument)
-            user_argv[i] = (char *) (*env)->GetStringUTFChars(env, argument, NULL);
-    }
-    instance = libvlc_new(user_argc, (const char **) user_argv);
-    for (i = 0; i < user_argc; i++)
-    {
-        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
-        if (argument)
-            (*env)->ReleaseStringUTFChars(env, argument, user_argv[i]);
-    }
-
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID field = (*env)->GetFieldID(env, clazz, "mLibVlcInstance", "I");
-    (*env)->SetIntField(env, thiz, field, (jint) instance);
-
-    if (!instance)
-    {
-        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
-        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
-    }
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_list_event_manager(pointer);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaListItemAdded,
+        libvlc_MediaListItemDeleted,
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
 
-    LOGI("LibVLC initialized: %p", instance);
+    setLong(env, thiz, "mMediaListInstance", (jlong)pointer);
 }
+#endif
 
 jstring Java_org_videolan_vlc_LibVLC_nativeToURI(JNIEnv *env, jobject thiz, jstring path)
 {
@@ -402,7 +477,11 @@ jstring Java_org_videolan_vlc_LibVLC_nativeToURI(JNIEnv *env, jobject thiz, jstr
     /* Get C string */
     const char* psz_path = (*env)->GetStringUTFChars(env, path, &isCopy);
     /* Convert the path to URI */
-    char* psz_location = make_URI(psz_path, "file");
+    char* psz_location;
+    if(unlikely( strstr( psz_path, "://" ) ))
+        psz_location = strdup(psz_path);
+    else
+        psz_location = vlc_path2uri(psz_path, "file");
     /* Box into jstring */
     jstring t = (*env)->NewStringUTF(env, psz_location);
     /* Clean up */
@@ -414,9 +493,7 @@ jstring Java_org_videolan_vlc_LibVLC_nativeToURI(JNIEnv *env, jobject thiz, jstr
 void Java_org_videolan_vlc_LibVLC_nativeDestroy(JNIEnv *env, jobject thiz)
 {
     releaseMediaPlayer(env, thiz);
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID field = (*env)->GetFieldID(env, clazz, "mLibVlcInstance", "I");
-    jint libVlcInstance = (*env)->GetIntField(env, thiz, field);
+    jlong libVlcInstance = getLong(env, thiz, "mLibVlcInstance");
     if (!libVlcInstance)
         return; // Already destroyed
 
@@ -424,7 +501,7 @@ void Java_org_videolan_vlc_LibVLC_nativeDestroy(JNIEnv *env, jobject thiz)
     libvlc_release(instance);
     libvlc_log_unsubscribe(&debug_subscriber);
 
-    (*env)->SetIntField(env, thiz, field, 0);
+    setLong(env, thiz, "mLibVlcInstance", 0);
 }
 
 void Java_org_videolan_vlc_LibVLC_detachEventManager(JNIEnv *env, jobject thiz)
@@ -457,77 +534,9 @@ void Java_org_videolan_vlc_LibVLC_setEventManager(JNIEnv *env, jobject thiz, job
     eventManagerInstance = (*env)->NewGlobalRef(env, eventManager);
 }
 
-void setInt(JNIEnv *env, jobject item, const char* field, int value)
-{
-    jclass cls;
-    jfieldID fieldId;
-
-    /* Get a reference to item's class */
-    cls = (*env)->GetObjectClass(env, item);
-
-    /* Look for the instance field s in cls */
-    fieldId = (*env)->GetFieldID(env, cls, field, "I");
-    if (fieldId == NULL)
-        return;
-
-    (*env)->SetIntField(env, item, fieldId, value);
-}
-
-void setLong(JNIEnv *env, jobject item, const char* field, long value)
-{
-    jclass cls;
-    jfieldID fieldId;
-
-    /* Get a reference to item's class */
-    cls = (*env)->GetObjectClass(env, item);
-
-    /* Look for the instance field s in cls */
-    fieldId = (*env)->GetFieldID(env, cls, field, "J");
-    if (fieldId == NULL)
-        return;
-
-    (*env)->SetLongField(env, item, fieldId, value);
-}
-
-void SetFloat(JNIEnv *env, jobject item, const char* field, float value)
-{
-    jclass cls;
-    jfieldID fieldId;
-
-    /* Get a reference to item's class */
-    cls = (*env)->GetObjectClass(env, item);
-
-    /* Look for the instance field s in cls */
-    fieldId = (*env)->GetFieldID(env, cls, field, "F");
-    if (fieldId == NULL)
-        return;
-
-    (*env)->SetFloatField(env, item, fieldId, value);
-}
-
-void setString(JNIEnv *env, jobject item, const char* field, const char* text)
-{
-    jclass cls;
-    jfieldID fieldId;
-    jstring jstr;
-
-    /* Get a reference to item's class */
-    cls = (*env)->GetObjectClass(env, item);
-
-    /* Look for the instance field s in cls */
-    fieldId = (*env)->GetFieldID(env, cls, field, "Ljava/lang/String;");
-    if (fieldId == NULL)
-        return;
-
-    /* Create a new string and overwrite the instance field */
-    jstr = (*env)->NewStringUTF(env, text);
-    if (jstr == NULL)
-        return;
-    (*env)->SetObjectField(env, item, fieldId, jstr);
-}
-
+#if 0
 jobjectArray Java_org_videolan_vlc_LibVLC_readMediaMeta(JNIEnv *env,
-                                                        jobject thiz, jint instance, jstring mrl)
+                                                        jobject thiz, jlong instance, jstring mrl)
 {
     jobjectArray array = (*env)->NewObjectArray(env, 8,
             (*env)->FindClass(env, "java/lang/String"),
@@ -567,89 +576,123 @@ jobjectArray Java_org_videolan_vlc_LibVLC_readMediaMeta(JNIEnv *env,
    libvlc_media_release(m);
    return array;
 }
+#endif
 
-void Java_org_videolan_vlc_LibVLC_readMediaEx(JNIEnv *env, jobject thiz,
-                                            jint instance, jstring mrl, jarray options)
-{
+#include "libvlcjni_danmaku_readMediaEx.inc.c"
+#if 0
+static void create_player_and_play(JNIEnv* env, jobject thiz,
+                                   jlong instance, int position) {
     /* Release previous media player, if any */
     releaseMediaPlayer(env, thiz);
 
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_list_player_t* p_mlp = libvlc_media_list_player_new((libvlc_instance_t*)instance);
+    libvlc_media_player_t *mp = libvlc_media_player_new((libvlc_instance_t*)instance);
+
     jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
 
+    //if AOUT_AUDIOTRACK_JAVA, we use amem
+    jclass cls = (*env)->GetObjectClass(env, thiz);
+    jmethodID methodId = (*env)->GetMethodID(env, cls, "getAout", "()I");
+    if ( (*env)->CallIntMethod(env, thiz, methodId) == AOUT_AUDIOTRACK_JAVA )
+    {
+        libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL, NULL, NULL,
+                                   (void*) myJavaLibVLC);
+        libvlc_audio_set_format_callbacks(mp, aout_open, aout_close);
+    }
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    static const libvlc_event_type_t mp_events[] = {
+        libvlc_MediaPlayerPlaying,
+        libvlc_MediaPlayerPaused,
+        libvlc_MediaPlayerEndReached,
+        libvlc_MediaPlayerStopped,
+        libvlc_MediaPlayerVout,
+    };
+    for(int i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); i++)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    libvlc_media_list_player_set_media_list(p_mlp, p_mlist);
+    libvlc_media_list_player_set_media_player(p_mlp, mp);
+
+    /* Keep a pointer to this media player */
+    setLong(env, thiz, "mMediaListPlayerInstance", (jlong)p_mlp);
+    setLong(env, thiz, "mInternalMediaPlayerInstance", (jlong)mp);
+
+    libvlc_media_list_player_play_item_at_index(p_mlp, position);
+}
+
+void Java_org_videolan_vlc_LibVLC_readMedia(JNIEnv *env, jobject thiz,
+                                            jlong instance, jstring mrl, jboolean novideo)
+{
     /* Create a new item */
-    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, false);
+    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, novideo);
     if (!m)
     {
         LOGE("readMedia: Could not create the media!");
         return;
     }
 
-    /* Create a media player playing environment */
-    libvlc_media_player_t *mp = libvlc_media_player_new((libvlc_instance_t*)instance);
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
 
-    int user_argc = (*env)->GetArrayLength(env, options);
-    int i = 0;
-    LOGD("libvlc_media_add_option");
-    for (i = 0; i < user_argc; i++)
-    {
-        jstring opt = (*env)->GetObjectArrayElement(env, options, i);
-        if (opt) {
-            const char* optString = (char *) (*env)->GetStringUTFChars(env, opt, NULL);
-            if (optString) {
-                LOGD("  %s", optString);
-                if (!strncmp(optString, ":aout=", 6)) {
-                    // seems ":aout" does not effect libvlc_media_add_option()
-                    const char* aout_name = optString + 6;
-                    if (!strncmp(aout_name, "audiotrack_java", 15))
-                    {
-                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
-                        libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL, NULL, NULL,
-                                                   (void*) myJavaLibVLC);
-                        libvlc_audio_set_format_callbacks(mp, aout_open, aout_close);
-                    }
-                    else
-                    {
-                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
-                        libvlc_audio_output_set(mp, aout_name);
-                    }
-                } else {
-                    libvlc_media_add_option(m, optString);
-                }
-
-                (*env)->ReleaseStringUTFChars(env, opt, optString);
-            }
-        }
+    libvlc_media_list_lock(p_mlist);
+    if(libvlc_media_list_add_media(p_mlist, m) != 0) {
+        LOGE("readMedia: Could not add to the media list!");
+        libvlc_media_list_unlock(p_mlist);
+        libvlc_media_release(m);
+        return;
     }
-
-    libvlc_media_player_set_media(mp, m);
+    int position = libvlc_media_list_index_of_item(p_mlist, m);
+    libvlc_media_list_unlock(p_mlist);
 
     /* No need to keep the media now */
     libvlc_media_release(m);
 
-    /* Connect the event manager */
-    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
-    for (i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
-        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+    create_player_and_play(env, thiz, instance, position);
+}
 
-    libvlc_media_t *md = libvlc_media_player_get_media(mp);
-    if (md) {
-        ev = libvlc_media_event_manager(md);
-        for (i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
-            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
-        }
+void Java_org_videolan_vlc_LibVLC_playIndex(JNIEnv *env, jobject thiz,
+                                            jlong instance, int position) {
+    create_player_and_play(env, thiz, instance, position);
+}
+
+void Java_org_videolan_vlc_LibVLC_getMediaListItems(
+                JNIEnv *env, jobject thiz, jobject arrayList) {
+    jclass arrayClass = (*env)->FindClass(env, "java/util/ArrayList");
+    jmethodID methodID = (*env)->GetMethodID(env, arrayClass, "add", "(Ljava/lang/Object;)Z");
+    jstring str;
+
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+    libvlc_media_list_lock( p_mlist );
+    for(int i = 0; i < libvlc_media_list_count( p_mlist ); i++) {
+        char* mrl = libvlc_media_get_mrl( libvlc_media_list_item_at_index( p_mlist, i ) );
+        str = (*env)->NewStringUTF(env, mrl);
+        (*env)->CallBooleanMethod(env, arrayList, methodID, str);
+        (*env)->DeleteLocalRef(env, str);
+        free(mrl);
     }
+    libvlc_media_list_unlock( p_mlist );
+}
 
-    /* Keep a pointer to this media player */
-    jclass clazz = (*env)->GetObjectClass(env, thiz);
-    jfieldID field = (*env)->GetFieldID(env, clazz,
-                                        "mMediaPlayerInstance", "I");
-    (*env)->SetIntField(env, thiz, field, (jint) mp);
+jfloat Java_org_videolan_vlc_LibVLC_getRate(JNIEnv *env, jobject thiz) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        return libvlc_media_player_get_rate(mp);
+    else
+        return 1.00;
+}
 
-    libvlc_media_player_play(mp);
+void Java_org_videolan_vlc_LibVLC_setRate(JNIEnv *env, jobject thiz, jfloat rate) {
+    libvlc_media_player_t* mp = getMediaPlayer(env, thiz);
+    if(mp)
+        libvlc_media_player_set_rate(mp, rate);
 }
 
 jboolean Java_org_videolan_vlc_LibVLC_hasVideoTrack(JNIEnv *env, jobject thiz,
-                                                    jint i_instance, jstring fileLocation)
+                                                    jlong i_instance, jstring fileLocation)
 {
     /* Create a new item and assign it to the media player. */
     libvlc_media_t *p_m = new_media(i_instance, env, thiz, fileLocation, false, false);
@@ -714,8 +757,7 @@ jboolean Java_org_videolan_vlc_LibVLC_hasVideoTrack(JNIEnv *env, jobject thiz,
         return JNI_FALSE;
 }
 
-jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject thiz,
-                                                         jint instance, jstring mrl)
+jobjectArray read_track_info_internal(JNIEnv *env, jobject thiz, libvlc_media_t* p_m)
 {
     /* get java class */
     jclass cls = (*env)->FindClass( env, "org/videolan/vlc/TrackInfo" );
@@ -733,17 +775,8 @@ jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject th
         return NULL;
     }
 
-    /* Create a new item and assign it to the media player. */
-    libvlc_media_t *p_m = new_media(instance, env, thiz, mrl, false, false);
-    if (p_m == NULL)
-    {
-        LOGE("Could not create the media!");
-        return NULL;
-    }
-
     /* Get the tracks information of the media. */
     libvlc_media_track_info_t *p_tracks;
-    libvlc_media_parse(p_m);
 
     int i_nbTracks = libvlc_media_get_tracks_info(p_m, &p_tracks);
     jobjectArray array = (*env)->NewObjectArray(env, i_nbTracks + 1, cls, NULL);
@@ -780,7 +813,7 @@ jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject th
             {
                 setInt(env, item, "Height", p_tracks[i].u.video.i_height);
                 setInt(env, item, "Width", p_tracks[i].u.video.i_width);
-                SetFloat(env, item, "Framerate", p_tracks[i].u.video.f_frame_rate);
+                setFloat(env, item, "Framerate", p_tracks[i].u.video.f_frame_rate);
             }
             if (p_tracks[i].i_type == libvlc_track_audio)
             {
@@ -791,12 +824,42 @@ jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject th
     }
 
     libvlc_media_tracks_info_release(p_tracks, i_nbTracks);
-    libvlc_media_release(p_m);
     return array;
 }
 
+
+jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfo(JNIEnv *env, jobject thiz,
+                                                         jlong instance, jstring mrl)
+{
+    /* Create a new item and assign it to the media player. */
+    libvlc_media_t *p_m = new_media(instance, env, thiz, mrl, false, false);
+    if (p_m == NULL)
+    {
+        LOGE("Could not create the media!");
+        return NULL;
+    }
+
+    libvlc_media_parse(p_m);
+    jobjectArray jar = read_track_info_internal(env, thiz, p_m);
+    libvlc_media_release(p_m);
+    return jar;
+}
+
+
+jobjectArray Java_org_videolan_vlc_LibVLC_readTracksInfoPosition(JNIEnv *env, jobject thiz,
+                                                         jint position)
+{
+    libvlc_media_list_t* p_mlist = getMediaList(env, thiz);
+    libvlc_media_t *p_m = libvlc_media_list_item_at_index( p_mlist, position );
+    if (p_m == NULL) {
+        LOGE("Could not load get media @ position %d!", position);
+        return NULL;
+    } else
+        return read_track_info_internal(env, thiz, p_m);
+}
+
 jlong Java_org_videolan_vlc_LibVLC_getLengthFromLocation(JNIEnv *env, jobject thiz,
-                                                     jint i_instance, jstring fileLocation)
+                                                     jlong i_instance, jstring fileLocation)
 {
     jlong length = 0;
     struct length_change_monitor *monitor;
@@ -840,6 +903,7 @@ end:
 
     return length;
 }
+#endif
 
 jboolean Java_org_videolan_vlc_LibVLC_hasMediaPlayer(JNIEnv *env, jobject thiz)
 {
@@ -851,7 +915,8 @@ jboolean Java_org_videolan_vlc_LibVLC_isPlaying(JNIEnv *env, jobject thiz)
     libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
     if (mp)
         return !!libvlc_media_player_is_playing(mp);
-    return 0;
+    else
+        return 0;
 }
 
 jboolean Java_org_videolan_vlc_LibVLC_isSeekable(JNIEnv *env, jobject thiz)
@@ -883,6 +948,21 @@ void Java_org_videolan_vlc_LibVLC_stop(JNIEnv *env, jobject thiz)
         libvlc_media_player_stop(mp);
 }
 
+#if 0
+void Java_org_videolan_vlc_LibVLC_previous(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_list_player_t *mp = getMediaListPlayer(env, thiz);
+    if (mp)
+        libvlc_media_list_player_previous(mp);
+}
+
+void Java_org_videolan_vlc_LibVLC_next(JNIEnv *env, jobject thiz)
+{
+    libvlc_media_list_player_t *mp = getMediaListPlayer(env, thiz);
+    if (mp)
+        libvlc_media_list_player_next(mp);
+}
+
 jint Java_org_videolan_vlc_LibVLC_getVolume(JNIEnv *env, jobject thiz)
 {
     libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
@@ -899,6 +979,7 @@ jint Java_org_videolan_vlc_LibVLC_setVolume(JNIEnv *env, jobject thiz, jint volu
         return (jint) libvlc_audio_set_volume(mp, (int) volume);
     return -1;
 }
+#endif
 
 jlong Java_org_videolan_vlc_LibVLC_getTime(JNIEnv *env, jobject thiz)
 {
@@ -953,6 +1034,7 @@ jstring Java_org_videolan_vlc_LibVLC_changeset(JNIEnv* env, jobject thiz)
     return (*env)->NewStringUTF(env, libvlc_get_changeset());
 }
 
+#if 0
 jint Java_org_videolan_vlc_LibVLC_getAudioTracksCount(JNIEnv *env, jobject thiz)
 {
     libvlc_media_player_t *mp = getMediaPlayer(env, thiz);
@@ -1074,6 +1156,7 @@ void Java_org_videolan_vlc_LibVLC_nativeReadDirectory(JNIEnv *env, jobject thiz,
     jmethodID methodID = (*env)->GetMethodID(env, arrayClass, "add", "(Ljava/lang/Object;)Z");
 
     struct dirent* p_dirent;
+    jstring str;
     while(1) {
         errno = 0;
         p_dirent = readdir(p_dir);
@@ -1083,7 +1166,9 @@ void Java_org_videolan_vlc_LibVLC_nativeReadDirectory(JNIEnv *env, jobject thiz,
             else if(errno == 0) /* end of stream */
                 break;
         }
-        (*env)->CallBooleanMethod(env, arrayList, methodID, (*env)->NewStringUTF(env, p_dirent->d_name));
+        str = (*env)->NewStringUTF(env, p_dirent->d_name);
+        (*env)->CallBooleanMethod(env, arrayList, methodID, str);
+        (*env)->DeleteLocalRef(env, str);
     }
     closedir(p_dir);
 }
@@ -1109,3 +1194,4 @@ jboolean Java_org_videolan_vlc_LibVLC_nativeIsPathDirectory(JNIEnv *env, jobject
     (*env)->ReleaseStringUTFChars(env, path, psz_path);
     return isDirectory;
 }
+#endif
diff --git a/vlc-android/jni/libvlcjni_danmaku_event_callback.inc.c b/vlc-android/jni/libvlcjni_danmaku_event_callback.inc.c
new file mode 100644
index 0000000..044f071
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_event_callback.inc.c
@@ -0,0 +1,108 @@
+static void vlc_event_callback(const libvlc_event_t *ev, void *data) {
+    JNIEnv *env;
+    JavaVM *myVm = data;
+
+    bool isAttached = false;
+
+    if (eventManagerInstance == NULL)
+        return;
+
+    int status = (*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2);
+    if (status < 0) {
+#if 0
+        LOGD("vlc_event_callback: failed to get JNI environment, "
+                "assuming native thread");
+#endif
+        status = (*myVm)->AttachCurrentThread(myVm, &env, NULL);
+        if (status < 0)
+            return;
+        isAttached = true;
+    }
+
+    /* Get the object class */
+    jclass cls = (*env)->GetObjectClass(env, eventManagerInstance);
+    if (!cls) {
+        LOGE("EventManager: failed to get class reference");
+        goto end;
+    }
+
+    jobject eventObject = NULL;
+
+    /* Find the callback ID */
+    jmethodID methodObtain = (*env)->GetMethodID(env, cls, "obtainEventObject",
+            "()Lorg/videolan/vlc/LibVlcEvent;");
+    if (methodObtain) {
+        eventObject = (*env)->CallObjectMethod(env, eventManagerInstance,
+                methodObtain);
+        if (eventObject == NULL) {
+            LOGE("EventManager: failed to obtainEventObject");
+            goto end;
+        }
+    } else {
+        LOGE("EventManager: failed to get the obtainEventObject method");
+        goto end;
+    }
+
+    setInt(env, eventObject, "mEventType", (int) ev->type);
+
+    switch (ev->type) {
+    case libvlc_MediaPlayerBuffering: {
+        float cache = ev->u.media_player_buffering.new_cache;
+        vlc_event_set_float(env, eventObject, cache);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        int seekable = ev->u.media_player_seekable_changed.new_seekable;
+        vlc_event_set_int(env, eventObject, seekable);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        int pausable = ev->u.media_player_pausable_changed.new_pausable;
+        vlc_event_set_int(env, eventObject, pausable);
+        break;
+    }
+    case libvlc_MediaPlayerBufferingTotal: {
+        float cache = ev->u.media_player_buffering_total.new_cache_total;
+        vlc_event_set_float(env, eventObject, cache);
+        break;
+    }
+    case libvlc_MediaPlayerModuleChanged: {
+        char *p_module_list = NULL;
+        asprintf(&p_module_list,
+                "video-decoder=%s;audio-decoder=%s;video-decoder-impl=%s;audio-decoder-impl=%s",
+                ev->u.media_player_module_changed.psz_video_decoder ?
+                        ev->u.media_player_module_changed.psz_video_decoder :
+                        "",
+                ev->u.media_player_module_changed.psz_audio_decoder ?
+                        ev->u.media_player_module_changed.psz_audio_decoder :
+                        "",
+                ev->u.media_player_module_changed.psz_video_decoder_impl ?
+                        ev->u.media_player_module_changed.psz_video_decoder_impl :
+                        "",
+                ev->u.media_player_module_changed.psz_audio_decoder_impl ?
+                        ev->u.media_player_module_changed.psz_audio_decoder_impl :
+                        "");
+        vlc_event_set_string(env, eventObject, p_module_list);
+        free(p_module_list);
+        break;
+    }
+    }
+
+    /* Find the callback ID */
+    jmethodID methodID = (*env)->GetMethodID(env, cls, "callback",
+            "(ILorg/videolan/vlc/LibVlcEvent;)V");
+    if (methodID) {
+        (*env)->CallVoidMethod(env, eventManagerInstance, methodID, ev->type,
+                eventObject);
+    } else {
+        LOGE("EventManager: failed to get the callback method");
+        goto end;
+    }
+
+    end: if (eventObject)
+        (*env)->DeleteLocalRef(env, eventObject);
+
+    if (isAttached)
+        (*myVm)->DetachCurrentThread(myVm);
+}
+
diff --git a/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
new file mode 100644
index 0000000..b1512f6
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_nativeInitEx.inc.c
@@ -0,0 +1,38 @@
+void Java_org_videolan_vlc_LibVLC_nativeInitEx(JNIEnv *env, jobject thiz, jboolean verbose, jarray arguments)
+{
+    libvlc_instance_t *instance = NULL;
+    if (arguments == NULL) {
+        Java_org_videolan_vlc_LibVLC_nativeInit(env, thiz, false);
+        return;
+    }
+
+    verbosity = verbose;
+    libvlc_log_subscribe(&debug_subscriber, debug_log, &verbosity);
+
+    int user_argc = (*env)->GetArrayLength(env, arguments);
+    char **user_argv = (char **) calloc(user_argc, sizeof(char *));
+    int i = 0;
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            user_argv[i] = (char *) (*env)->GetStringUTFChars(env, argument, NULL);
+    }
+    instance = libvlc_new(user_argc, (const char **) user_argv);
+    for (i = 0; i < user_argc; i++)
+    {
+        jstring argument = (*env)->GetObjectArrayElement(env, arguments, i);
+        if (argument)
+            (*env)->ReleaseStringUTFChars(env, argument, user_argv[i]);
+    }
+
+    setLong(env, thiz, "mLibVlcInstance", (jlong) instance);
+
+    if (!instance)
+    {
+        jclass exc = (*env)->FindClass(env, "org/videolan/vlc/LibVlcException");
+        (*env)->ThrowNew(env, exc, "Unable to instantiate LibVLC");
+    }
+
+    LOGI("LibVLC initialized: %p", instance);
+}
diff --git a/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c b/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c
new file mode 100644
index 0000000..000a630
--- /dev/null
+++ b/vlc-android/jni/libvlcjni_danmaku_readMediaEx.inc.c
@@ -0,0 +1,76 @@
+void Java_org_videolan_vlc_LibVLC_readMediaEx(JNIEnv *env, jobject thiz,
+        jint instance, jstring mrl, jarray options) {
+    /* Release previous media player, if any */
+    releaseMediaPlayer(env, thiz);
+
+    /* Create a new item */
+    libvlc_media_t *m = new_media(instance, env, thiz, mrl, false, false);
+    if (!m) {
+        LOGE("readMediaEx: Could not create the media!");
+        return;
+    }
+
+    jobject myJavaLibVLC = (*env)->NewGlobalRef(env, thiz);
+
+    /* Create a media player playing environment */
+    libvlc_media_player_t *mp = libvlc_media_player_new(
+            (libvlc_instance_t*) instance);
+
+    int user_argc = (*env)->GetArrayLength(env, options);
+    int i = 0;
+    LOGD("libvlc_media_add_option");
+    for (i = 0; i < user_argc; i++) {
+        jstring opt = (*env)->GetObjectArrayElement(env, options, i);
+        if (opt) {
+            const char* optString = (char *) (*env)->GetStringUTFChars(env, opt,
+                    NULL);
+            if (optString) {
+                LOGD("  %s", optString);
+                if (!strncmp(optString, ":aout=", 6)) {
+                    // seems ":aout" does not effect libvlc_media_add_option()
+                    const char* aout_name = optString + 6;
+                    if (!strncmp(aout_name, "audiotrack_java", 15)) {
+                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                        libvlc_audio_set_callbacks(mp, aout_play, NULL, NULL,
+                                NULL, NULL, (void*) myJavaLibVLC);
+                        libvlc_audio_set_format_callbacks(mp, aout_open,
+                                aout_close);
+                    } else {
+                        LOGD("    set libvlc_audio_output_set:%s", aout_name);
+                        libvlc_audio_output_set(mp, aout_name);
+                    }
+                } else {
+                    libvlc_media_add_option(m, optString);
+                }
+
+                (*env)->ReleaseStringUTFChars(env, opt, optString);
+            }
+        }
+    }
+
+    libvlc_media_player_set_media(mp, m);
+
+    /* No need to keep the media now */
+    libvlc_media_release(m);
+
+    /* Connect the event manager */
+    libvlc_event_manager_t *ev = libvlc_media_player_event_manager(mp);
+    for (i = 0; i < (sizeof(mp_events) / sizeof(*mp_events)); ++i)
+        libvlc_event_attach(ev, mp_events[i], vlc_event_callback, myVm);
+
+    libvlc_media_t *md = libvlc_media_player_get_media(mp);
+    if (md) {
+        ev = libvlc_media_event_manager(md);
+        for (i = 0; i < sizeof(md_events) / sizeof(*md_events); i++) {
+            libvlc_event_attach(ev, md_events[i], vlc_event_callback, myVm);
+        }
+    }
+
+    /* Keep a pointer to this media player */
+    jclass clazz = (*env)->GetObjectClass(env, thiz);
+    jfieldID field = (*env)->GetFieldID(env, clazz,
+            "mInternalMediaPlayerInstance", "I");
+    (*env)->SetIntField(env, thiz, field, (jint) mp);
+
+    libvlc_media_player_play(mp);
+}
-- 
1.7.10.4

