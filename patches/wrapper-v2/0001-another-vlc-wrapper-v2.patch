From 38c639bedb20614fba0f2849d5c828f7698ec3de Mon Sep 17 00:00:00 2001
From: bbcallen <bbcallen@gmail.com>
Date: Mon, 16 Apr 2012 17:32:21 +0800
Subject: [PATCH] another vlc wrapper v2

---
 vlc-android/jni/libdanmaku/libdanmaku_common.h     |   77 ++++++
 vlc-android/jni/libdanmaku/libdanmaku_jni.c        |   84 ++++++
 .../jni/libdanmaku/libdanmaku_mediaplayer.c        |  138 ++++++++++
 vlc-android/jni/libdanmaku/libdanmaku_surface.c    |   94 +++++++
 vlc-android/jni/libdanmaku/nativeLibVlcInstance.c  |   85 ++++++
 .../jni/libdanmaku/nativeLibVlcMediaPlayer.c       |  270 +++++++++++++++++++
 vlc-android/jni/libjnihelper/libjnihelper.h        |  219 +++++++++++++++
 .../videolan/vlc/gui/video/VlcTestActivity.java    |  129 +++++++++
 .../src/tv/danmaku/media/AbsMediaPlayer.java       |  141 ++++++++++
 .../tv/danmaku/media/AbsMediaPlayerException.java  |   38 +++
 .../src/tv/danmaku/media/LibVlcInstance.java       |  120 +++++++++
 .../src/tv/danmaku/media/LibVlcMediaException.java |   37 +++
 .../src/tv/danmaku/media/LibVlcMediaPlayer.java    |  125 +++++++++
 .../src/tv/danmaku/media/VlcMediaPlayer.java       |  145 ++++++++++
 vlc-android/src/tv/danmaku/util/AppBuild.java      |   74 +++++
 .../src/tv/danmaku/util/AppBuildConfig.java        |    6 +
 .../tv/danmaku/util/AppConnectivityManager.java    |   24 ++
 vlc-android/src/tv/danmaku/util/AppContext.java    |  115 ++++++++
 vlc-android/src/tv/danmaku/util/AppCpuInfo.java    |  282 ++++++++++++++++++++
 .../src/tv/danmaku/util/AppInputMethodManager.java |   17 ++
 .../src/tv/danmaku/util/AppPackageManager.java     |  107 ++++++++
 .../src/tv/danmaku/util/AppPowerManager.java       |   18 ++
 vlc-android/src/tv/danmaku/util/AppResources.java  |   43 +++
 vlc-android/src/tv/danmaku/util/AppToast.java      |   15 ++
 vlc-android/src/tv/danmaku/util/AppTypeFace.java   |   35 +++
 .../src/tv/danmaku/util/AppWindowManager.java      |   72 +++++
 vlc-android/src/tv/danmaku/util/Assure.java        |   23 ++
 .../src/tv/danmaku/util/CollectionHelper.java      |   13 +
 vlc-android/src/tv/danmaku/util/DebugLog.java      |   79 ++++++
 .../src/tv/danmaku/util/IdentityComparator.java    |   11 +
 vlc-android/src/tv/danmaku/util/IntRange.java      |   14 +
 vlc-android/src/tv/danmaku/util/PatternHelper.java |   38 +++
 vlc-android/src/tv/danmaku/util/StreamHelper.java  |   58 ++++
 vlc-android/src/tv/danmaku/util/UriHelper.java     |   16 ++
 vlc-android/src/tv/danmaku/util/ViewHelper.java    |  123 +++++++++
 vlc-android/src/tv/danmaku/util/WeakActivity.java  |   49 ++++
 vlc-android/src/tv/danmaku/util/WeakListeners.java |   31 +++
 37 files changed, 2965 insertions(+)
 create mode 100644 vlc-android/jni/libdanmaku/libdanmaku_common.h
 create mode 100644 vlc-android/jni/libdanmaku/libdanmaku_jni.c
 create mode 100644 vlc-android/jni/libdanmaku/libdanmaku_mediaplayer.c
 create mode 100644 vlc-android/jni/libdanmaku/libdanmaku_surface.c
 create mode 100644 vlc-android/jni/libdanmaku/nativeLibVlcInstance.c
 create mode 100644 vlc-android/jni/libdanmaku/nativeLibVlcMediaPlayer.c
 create mode 100644 vlc-android/jni/libjnihelper/libjnihelper.h
 create mode 100644 vlc-android/src/org/videolan/vlc/gui/video/VlcTestActivity.java
 create mode 100644 vlc-android/src/tv/danmaku/media/AbsMediaPlayer.java
 create mode 100644 vlc-android/src/tv/danmaku/media/AbsMediaPlayerException.java
 create mode 100644 vlc-android/src/tv/danmaku/media/LibVlcInstance.java
 create mode 100644 vlc-android/src/tv/danmaku/media/LibVlcMediaException.java
 create mode 100644 vlc-android/src/tv/danmaku/media/LibVlcMediaPlayer.java
 create mode 100644 vlc-android/src/tv/danmaku/media/VlcMediaPlayer.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppBuild.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppBuildConfig.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppConnectivityManager.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppContext.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppCpuInfo.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppInputMethodManager.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppPackageManager.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppPowerManager.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppResources.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppToast.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppTypeFace.java
 create mode 100644 vlc-android/src/tv/danmaku/util/AppWindowManager.java
 create mode 100644 vlc-android/src/tv/danmaku/util/Assure.java
 create mode 100644 vlc-android/src/tv/danmaku/util/CollectionHelper.java
 create mode 100644 vlc-android/src/tv/danmaku/util/DebugLog.java
 create mode 100644 vlc-android/src/tv/danmaku/util/IdentityComparator.java
 create mode 100644 vlc-android/src/tv/danmaku/util/IntRange.java
 create mode 100644 vlc-android/src/tv/danmaku/util/PatternHelper.java
 create mode 100644 vlc-android/src/tv/danmaku/util/StreamHelper.java
 create mode 100644 vlc-android/src/tv/danmaku/util/UriHelper.java
 create mode 100644 vlc-android/src/tv/danmaku/util/ViewHelper.java
 create mode 100644 vlc-android/src/tv/danmaku/util/WeakActivity.java
 create mode 100644 vlc-android/src/tv/danmaku/util/WeakListeners.java

diff --git a/vlc-android/jni/libdanmaku/libdanmaku_common.h b/vlc-android/jni/libdanmaku/libdanmaku_common.h
new file mode 100644
index 0000000..de5fd2d
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/libdanmaku_common.h
@@ -0,0 +1,77 @@
+/*****************************************************************************
+ * libdanmaku_common.h
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#ifndef LIBDANMAKU_COMMON_H_
+#define LIBDANMAKU_COMMON_H_
+
+#include <string.h>
+#include <stdbool.h>
+#include <pthread.h>
+
+#include <vlc/vlc.h>
+#include <vlc_common.h>
+#include <vlc_url.h>
+
+#include <jni.h>
+
+#include "libjnihelper/libjnihelper.h"
+#define LOG_TAG "VLC/JNI/libdanmaku"
+#include "log.h"
+
+#define CLAZZ_LIBVLC_EXCEPTION "tv/danmaku/media/LibVlcMediaException"
+#define CLAZZ_LIBVLC_INSTANCE "tv/danmaku/media/LibVlcInstance"
+#define CLAZZ_LIBVLC_MEDIA_PLAYER "tv/danmaku/media/LibVlcMediaPlayer"
+
+/* libdanmaku_jni.c */
+JavaVM *danmakuGetJavaVm();
+
+int danmakuThrowVlcException(JNIEnv *env, const char *msg);
+int danmakuThrowIllegalStateException(JNIEnv *env, const char *msg);
+
+const char **danmakuCopyStringArray(JNIEnv *env, jarray javaStringArray);
+void danmakuFreeStringArray(JNIEnv *env, int length, const char **stringArray);
+
+/* libdanmaku_surface.c */
+void danmakuInitAndroidSurface();
+void danmakuUninitAndroidSurface();
+
+void danmakuAttachSurface(JNIEnv *env, jobject thiz, jobject surf, jobject gui,
+        jint width, jint height);
+void danmakuDetachSurface(JNIEnv *env, jobject thiz);
+
+/* libdanmaku_mediaplayer.c */
+libvlc_media_t* danmakuCreateMedia(JNIEnv *env, libvlc_instance_t *instance,
+        const char *mrl, int argc, const char **argv);
+
+libvlc_media_player_t* danmakuCreateMediaPlayer(JNIEnv *env,
+        libvlc_instance_t *instance, int adkLevel, const char *mrl, int argc,
+        const char **argv, libvlc_callback_t callbackFunc, void *userData);
+
+void danmakuReleaseMediaPlayer(JNIEnv *env, libvlc_media_player_t *player,
+        libvlc_callback_t callbackFunc, void *userData);
+
+/* nativeLibVlcInstance.c */
+jint danmakuGetAdkLevel(JNIEnv *env);
+
+#endif /* LIBDANMAKU_COMMON_H_ */
diff --git a/vlc-android/jni/libdanmaku/libdanmaku_jni.c b/vlc-android/jni/libdanmaku/libdanmaku_jni.c
new file mode 100644
index 0000000..a5f0e43
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/libdanmaku_jni.c
@@ -0,0 +1,84 @@
+/*****************************************************************************
+ * libdanmaku_jni.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#include "libdanmaku_common.h"
+
+JavaVM *myVm;
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved) {
+    // Keep a reference on the Java VM.
+    myVm = vm;
+
+    danmakuInitAndroidSurface();
+
+    LOGD("JNI interface loaded.");
+    return JNI_VERSION_1_2;
+}
+
+void JNI_OnUnload(JavaVM *vm, void *reserved) {
+    danmakuUninitAndroidSurface();
+}
+
+JavaVM *danmakuGetJavaVm() {
+    return myVm;
+}
+
+int danmakuThrowVlcException(JNIEnv *env, const char *msg) {
+    LOGE(msg);
+    return jniThrowException(env, CLAZZ_LIBVLC_EXCEPTION, msg);
+}
+
+int danmakuThrowIllegalStateException(JNIEnv *env, const char *msg) {
+    LOGE(msg);
+    return jniThrowException(env, "java/lang/IllegalStateException", msg);
+}
+
+const char **danmakuCopyStringArray(JNIEnv *env, jarray javaStringArray) {
+    int length = (*env)->GetArrayLength(env, javaStringArray);
+    const char **stringArray = (const char **) calloc(length, sizeof(char *));
+
+    int i = 0;
+    for (i = 0; i < length; i++) {
+        jstring javaString = (*env)->GetObjectArrayElement(env, javaStringArray,
+                i);
+        if (javaString) {
+            stringArray[i] = (char *) (*env)->GetStringUTFChars(env,
+                    javaStringArray, NULL);
+        }
+    }
+
+    return stringArray;
+}
+
+void danmakuFreeStringArray(JNIEnv *env, int length, const char **stringArray) {
+    int i = 0;
+    for (i = 0; i < length; i++) {
+        jstring javaString = (*env)->GetObjectArrayElement(env, stringArray, i);
+        if (javaString) {
+            (*env)->ReleaseStringUTFChars(env, javaString, stringArray[i]);
+        }
+    }
+
+    free(stringArray);
+}
diff --git a/vlc-android/jni/libdanmaku/libdanmaku_mediaplayer.c b/vlc-android/jni/libdanmaku/libdanmaku_mediaplayer.c
new file mode 100644
index 0000000..6230495
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/libdanmaku_mediaplayer.c
@@ -0,0 +1,138 @@
+/*****************************************************************************
+ * libdanmaku_mediaplayer.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#include "libdanmaku_common.h"
+
+static const libvlc_event_type_t gMediaEvents[] = {
+//  libvlc_MediaMetaChanged,
+//  libvlc_MediaSubItemAdded,
+        libvlc_MediaDurationChanged, libvlc_MediaParsedChanged,
+//  libvlc_MediaFreed,
+        libvlc_MediaStateChanged, };
+
+static const libvlc_event_type_t gPlayerEvents[] = {
+//        libvlc_MediaPlayerMediaChanged,
+//        libvlc_MediaPlayerNothingSpecial,
+        libvlc_MediaPlayerOpening, libvlc_MediaPlayerBuffering,
+        libvlc_MediaPlayerPlaying, libvlc_MediaPlayerPaused,
+        libvlc_MediaPlayerStopped,
+//        libvlc_MediaPlayerForward,
+//        libvlc_MediaPlayerBackward,
+        libvlc_MediaPlayerEndReached, libvlc_MediaPlayerEncounteredError,
+//        libvlc_MediaPlayerTimeChanged,
+//        libvlc_MediaPlayerPositionChanged,
+        libvlc_MediaPlayerSeekableChanged, libvlc_MediaPlayerPausableChanged,
+//        libvlc_MediaPlayerTitleChanged,
+//        libvlc_MediaPlayerSnapshotTaken,
+//        libvlc_MediaPlayerLengthChanged,
+//        libvlc_MediaPlayerVout,
+        };
+
+libvlc_media_t* danmakuCreateMedia(JNIEnv *env, libvlc_instance_t *instance,
+        const char *mrl, int argc, const char **argv) {
+    libvlc_media_t *media = libvlc_media_new_location(instance, mrl);
+    if (media == NULL) {
+        LOGD("LibVlcMedia failed to call libvlc_media_new_location");
+        return NULL;
+    }
+
+    if (argc > 0 && argv != NULL) {
+        int i = 0;
+        for (i = 0; i < argc; ++i) {
+            libvlc_media_add_option(media, argv[i]);
+            LOGD("LibVlcMedia add option: %s", argv[i]);
+        }
+    }
+
+    return media;
+}
+
+libvlc_media_player_t* danmakuCreateMediaPlayer(JNIEnv *env,
+        libvlc_instance_t *instance, int adkLevel, const char *mrl, int argc,
+        const char **argv, libvlc_callback_t callbackFunc, void *userData) {
+    libvlc_media_t *media = danmakuCreateMedia(env, instance, mrl, argc, argv);
+    if (media == NULL) {
+        LOGD("LibVlcMedia failed to call danmakuCreateMedia");
+        return NULL;
+    }
+
+    /* Connect the media event manager */
+    int i = 0;
+    libvlc_event_manager_t *mediaEventManager = libvlc_media_event_manager(
+            media);
+    for (i = 0; i < (sizeof(gMediaEvents) / sizeof(*gMediaEvents)); ++i) {
+        libvlc_event_attach(mediaEventManager, gMediaEvents[i], callbackFunc,
+                userData);
+    }
+
+    libvlc_media_player_t *player = libvlc_media_player_new(instance);
+    if (player == NULL) {
+        LOGD("LibVlcMedia failed to call libvlc_media_player_new");
+        libvlc_media_release(media);
+        return NULL;
+    }
+
+    libvlc_media_player_set_media(player, media);
+
+    /* Connect the player event manager */
+    libvlc_event_manager_t *playerEventManager =
+            libvlc_media_player_event_manager(player);
+    for (i = 0; i < (sizeof(gPlayerEvents) / sizeof(*gPlayerEvents)); ++i) {
+        libvlc_event_attach(playerEventManager, gPlayerEvents[i], callbackFunc,
+                userData);
+    }
+
+    libvlc_media_release(media);
+
+    return player;
+}
+
+void danmakuReleaseMediaPlayer(JNIEnv *env, libvlc_media_player_t *player,
+        libvlc_callback_t callbackFunc, void *userData) {
+    int i = 0;
+    if (player) {
+        // detech media event is exists
+        libvlc_media_t *media = libvlc_media_player_get_media(player);
+        if (media) {
+            libvlc_event_manager_t *mediaEventManager =
+                    libvlc_media_event_manager(media);
+            for (i = 0; i < (sizeof(gMediaEvents) / sizeof(*gMediaEvents));
+                    ++i) {
+                libvlc_event_detach(mediaEventManager, gMediaEvents[i],
+                        callbackFunc, userData);
+            }
+        }
+
+        // detech player event is exists
+        libvlc_event_manager_t *playerEventManager =
+                libvlc_media_player_event_manager(player);
+        for (i = 0; i < (sizeof(gPlayerEvents) / sizeof(*gPlayerEvents)); ++i) {
+            libvlc_event_detach(playerEventManager, gPlayerEvents[i],
+                    callbackFunc, userData);
+        }
+
+        libvlc_media_player_stop(player);
+        libvlc_media_player_release(player);
+    }
+}
diff --git a/vlc-android/jni/libdanmaku/libdanmaku_surface.c b/vlc-android/jni/libdanmaku/libdanmaku_surface.c
new file mode 100644
index 0000000..d04e54c
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/libdanmaku_surface.c
@@ -0,0 +1,94 @@
+/*****************************************************************************
+ * libdanmaku_surface.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#include "libdanmaku_common.h"
+
+static pthread_mutex_t vout_android_lock;
+static void *vout_android_surf = NULL;
+static void *vout_android_gui = NULL;
+
+static JNISignature gMethod_setSurfaceSize = { "setSurfaceSize", "(II)V" };
+
+void danmakuInitAndroidSurface() {
+    pthread_mutex_init(&vout_android_lock, NULL);
+}
+
+void danmakuUninitAndroidSurface() {
+    pthread_mutex_destroy(&vout_android_lock);
+}
+
+void danmakuAttachSurface(JNIEnv *env, jobject thiz, jobject surf, jobject gui,
+        jint width, jint height) {
+    jclass clz;
+    jfieldID fid;
+
+    pthread_mutex_lock(&vout_android_lock);
+    clz = (*env)->GetObjectClass(env, surf);
+    fid = (*env)->GetFieldID(env, clz, "mSurface", "I");
+    if (fid == NULL) {
+        jthrowable exp = (*env)->ExceptionOccurred(env);
+        if (exp) {
+            (*env)->DeleteLocalRef(env, exp);
+            (*env)->ExceptionClear(env);
+        }
+        fid = (*env)->GetFieldID(env, clz, "mNativeSurface", "I");
+    }
+    vout_android_surf = (void*) (*env)->GetIntField(env, surf, fid);
+    (*env)->DeleteLocalRef(env, clz);
+
+    vout_android_gui = (*env)->NewGlobalRef(env, gui);
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+void danmakuDetachSurface(JNIEnv *env, jobject thiz) {
+    pthread_mutex_lock(&vout_android_lock);
+    vout_android_surf = NULL;
+    if (vout_android_gui != NULL)
+        (*env)->DeleteGlobalRef(env, vout_android_gui);
+    vout_android_gui = NULL;
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+void *jni_LockAndGetAndroidSurface() {
+    pthread_mutex_lock(&vout_android_lock);
+    return vout_android_surf;
+}
+
+void jni_UnlockAndroidSurface() {
+    pthread_mutex_unlock(&vout_android_lock);
+}
+
+void jni_SetAndroidSurfaceSize(int width, int height) {
+    if (vout_android_gui == NULL)
+        return;
+
+    JavaVM * myVm = danmakuGetJavaVm();
+    JNIEnv *env;
+    (*myVm)->AttachCurrentThread(myVm, &env, NULL);
+
+    jniCallVoidMethod(env, vout_android_gui, &gMethod_setSurfaceSize, width,
+            height);
+
+    (*myVm)->DetachCurrentThread(myVm);
+}
diff --git a/vlc-android/jni/libdanmaku/nativeLibVlcInstance.c b/vlc-android/jni/libdanmaku/nativeLibVlcInstance.c
new file mode 100644
index 0000000..b9eea4b
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/nativeLibVlcInstance.c
@@ -0,0 +1,85 @@
+/*****************************************************************************
+ * nativeLibVlcInstance.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#include "libdanmaku_common.h"
+
+#define FIELD_LIBVLC_INSTANCE "mNativeVlcInstance"
+
+static JNISignature gMethod_getAdkLevel = { "getAdkLevel", "()I" };
+
+jint danmakuGetAdkLevel(JNIEnv *env) {
+    return jniCallStaticIntMethod(env, CLAZZ_LIBVLC_INSTANCE,
+            &gMethod_getAdkLevel);
+}
+
+void Java_tv_danmaku_media_LibVlcInstance_nativeInit(JNIEnv *env, jobject thiz,
+        jarray arguments) {
+    libvlc_instance_t *instance = NULL;
+    if (arguments == NULL) {
+        danmakuThrowVlcException(env, "arguments can not be NULL");
+        return;
+    }
+
+    int argc = (*env)->GetArrayLength(env, arguments);
+    const char **argv = danmakuCopyStringArray(env, arguments);
+
+    instance = libvlc_new(argc, argv);
+
+    danmakuFreeStringArray(env, argc, argv);
+
+    jniSetIntField(env, thiz, FIELD_LIBVLC_INSTANCE, (jint) instance);
+
+    if (instance == NULL) {
+        danmakuThrowVlcException(env, "Unable to instantiate LibVLC");
+        return;
+    }
+
+    LOGI("LibVlc initialized: %p", instance);
+}
+
+void Java_tv_danmaku_media_LibVlcInstance_nativeDestroy(JNIEnv *env,
+        jobject thiz) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz,
+            FIELD_LIBVLC_INSTANCE);
+    libvlc_instance_t *instance = (libvlc_instance_t *) (*env)->GetIntField(env,
+            thiz, fieldHelper.fieldID);
+    if (instance == NULL)
+        return; // Already destroyed
+
+    libvlc_release(instance);
+    (*env)->SetIntField(env, thiz, fieldHelper.fieldID, 0);
+
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+}
+
+void Java_tv_danmaku_media_LibVlcInstance_nativeAttachSurface(JNIEnv *env,
+        jobject thiz, jobject surf, jobject gui, jint width, jint height) {
+    danmakuAttachSurface(env, thiz, surf, gui, width, height);
+}
+
+void Java_tv_danmaku_media_LibVlcInstance_nativeDetachSurface(JNIEnv *env,
+        jobject thiz) {
+    danmakuDetachSurface(env, thiz);
+}
+
diff --git a/vlc-android/jni/libdanmaku/nativeLibVlcMediaPlayer.c b/vlc-android/jni/libdanmaku/nativeLibVlcMediaPlayer.c
new file mode 100644
index 0000000..8e5beb5
--- /dev/null
+++ b/vlc-android/jni/libdanmaku/nativeLibVlcMediaPlayer.c
@@ -0,0 +1,270 @@
+/*****************************************************************************
+ * nativeLibVlcMediaPlayer.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen <bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#include "libdanmaku_common.h"
+
+#define FIELD_LIBVLC_MEDIAPLAYER "mNativeMediaPlayer"
+#define FIELD_LIBVLC_WEAKTHIS "mNativeWeakThis"
+
+static JNISignature gMethod_onNativeEvents = { "onNativeEvents",
+        "(Ljava/lang/Object;IIILjava/lang/Object;)V" };
+
+/* mNativeWeakThis is a WeakReference used for callback events */
+
+static void detachWeakThis(JNIEnv *env, jobject thiz) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz,
+            FIELD_LIBVLC_WEAKTHIS);
+
+    jobject weakThiz = (jobject*) (*env)->GetIntField(env, thiz,
+            fieldHelper.fieldID);
+    if (weakThiz != NULL) {
+        (*env)->DeleteGlobalRef(env, weakThiz);
+    }
+
+    (*env)->SetIntField(env, thiz, fieldHelper.fieldID, 0);
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+}
+
+static jobject attachWeakThis(JNIEnv *env, jobject thiz, jobject weakThiz) {
+    jobject globalRefWeakThiz = (*env)->NewGlobalRef(env, weakThiz);
+    jniSetIntField(env, thiz, FIELD_LIBVLC_WEAKTHIS, (jint) globalRefWeakThiz);
+    return globalRefWeakThiz;
+}
+
+static void vlcEventCallback(const libvlc_event_t *ev, void *data) {
+    JavaVM *myVm = danmakuGetJavaVm();
+    JNIEnv *env = NULL;
+    jobject weakThiz = data;
+
+    bool isAttached = false;
+    int status = (*myVm)->GetEnv(myVm, (void**) &env, JNI_VERSION_1_2);
+    if (status < 0) {
+        status = (*myVm)->AttachCurrentThread(myVm, &env, NULL);
+        if (status < 0) {
+            LOGE("vlcEventCallback failed to AttachCurrentThread");
+            return;
+        }
+        isAttached = true;
+    }
+
+    int what = ev->type;
+    int arg1 = 0;
+    int arg2 = 0;
+    switch (what) {
+    case libvlc_MediaPlayerBuffering: {
+        arg1 = (int) (ev->u.media_player_buffering.new_cache * 100);
+        break;
+    }
+    case libvlc_MediaPlayerSeekableChanged: {
+        arg1 = (int) (ev->u.media_player_seekable_changed.new_seekable * 100);
+        break;
+    }
+    case libvlc_MediaPlayerPausableChanged: {
+        arg1 = (int) (ev->u.media_player_pausable_changed.new_pausable * 100);
+        break;
+    }
+    }
+
+    jniCallStaticVoidMethod(env, CLAZZ_LIBVLC_MEDIA_PLAYER,
+            &gMethod_onNativeEvents, weakThiz, what, arg1, arg2, NULL);
+
+    if (isAttached)
+        (*myVm)->DetachCurrentThread(myVm);
+}
+
+/* */
+
+/* return NULL if player is NULL */
+static libvlc_media_player_t *getVlcMediaPlayer(JNIEnv *env, jobject thiz) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz,
+            FIELD_LIBVLC_MEDIAPLAYER);
+    libvlc_media_player_t *player =
+            (libvlc_media_player_t*) (*env)->GetIntField(env, thiz,
+                    fieldHelper.fieldID);
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+    return player;
+}
+
+/* throw IllegalStateException if player is NULL */
+static libvlc_media_player_t *getCheckedVlcMediaPlayer(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL) {
+        danmakuThrowIllegalStateException(env, "NULL media player");
+    }
+    return player;
+}
+
+static void resetMediaPlayer(JNIEnv *env, jobject thiz) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz,
+            FIELD_LIBVLC_MEDIAPLAYER);
+
+    libvlc_media_player_t *player =
+            (libvlc_media_player_t*) (*env)->GetIntField(env, thiz,
+                    fieldHelper.fieldID);
+    danmakuReleaseMediaPlayer(env, player, vlcEventCallback, thiz);
+    (*env)->SetIntField(env, thiz, fieldHelper.fieldID, 0);
+
+    detachWeakThis(env, thiz);
+
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+}
+
+/* native methods */
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativeSetupMediaPlayer(JNIEnv *env,
+        jobject thiz, jint instance, jobject weakThiz, jstring mrl,
+        jarray options) {
+    /* release previous media player if exists */
+    resetMediaPlayer(env, thiz);
+
+    int adkLevel = danmakuGetAdkLevel(env);
+
+    /* obtain strings */
+    int argc = (*env)->GetArrayLength(env, options);
+    const char **argv = danmakuCopyStringArray(env, options);
+    const char *mrlString = (char *) (*env)->GetStringUTFChars(env, mrl, NULL);
+
+    /* do setup media player */
+    libvlc_media_player_t *player = NULL;
+    if (mrlString != NULL && argv != NULL) {
+        jobject globalWeakThiz = attachWeakThis(env, thiz, weakThiz);
+        player = danmakuCreateMediaPlayer(env, (libvlc_instance_t*) instance,
+                adkLevel, mrlString, argc, argv, vlcEventCallback,
+                globalWeakThiz);
+    }
+
+    /* release strings */
+    if (mrlString != NULL) {
+        (*env)->ReleaseStringUTFChars(env, mrl, mrlString);
+    }
+    if (argv != NULL) {
+        danmakuFreeStringArray(env, argc, argv);
+    }
+
+    /* check setup */
+    if (player == NULL) {
+        danmakuThrowVlcException(env, "Failed to create media player;");
+        return;
+    }
+
+    /* Keep a pointer to this media player */
+    jniSetIntField(env, thiz, FIELD_LIBVLC_MEDIAPLAYER, (jint) player);
+    LOGI("LibVlcMediaPlayer initialized: %p", player);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativeReleaseMediaPlayer(
+        JNIEnv *env, jobject thiz) {
+    resetMediaPlayer(env, thiz);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativePlay(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getCheckedVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return;
+
+    libvlc_media_player_play(player);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativePause(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getCheckedVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return;
+
+    libvlc_media_player_pause(player);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativeStop(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getCheckedVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return;
+
+    libvlc_media_player_stop(player);
+}
+
+jlong Java_tv_danmaku_media_LibVlcMediaPlayer_nativeGetLength(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return -1;
+
+    return libvlc_media_player_get_length(player);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativeSetPosition(JNIEnv *env,
+        jobject thiz, jfloat position) {
+    libvlc_media_player_t *player = getCheckedVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return;
+
+    libvlc_media_player_set_position(player, position);
+}
+
+jfloat Java_tv_danmaku_media_LibVlcMediaPlayer_nativeGetPosition(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return -1.0f;
+
+    return libvlc_media_player_get_position(player);
+}
+
+void Java_tv_danmaku_media_LibVlcMediaPlayer_nativeSetTime(JNIEnv *env,
+        jobject thiz, jlong time) {
+    libvlc_media_player_t *player = getCheckedVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return;
+
+    libvlc_media_player_set_time(player, time);
+}
+
+jlong Java_tv_danmaku_media_LibVlcMediaPlayer_nativeGetTime(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return -1;
+
+    return libvlc_media_player_get_time(player);
+}
+
+jboolean Java_tv_danmaku_media_LibVlcMediaPlayer_nativeIsPlaying(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return JNI_FALSE;
+
+    return !!libvlc_media_player_is_playing(player);
+}
+
+jlong Java_tv_danmaku_media_LibVlcMediaPlayer_getLength(JNIEnv *env,
+        jobject thiz) {
+    libvlc_media_player_t *player = getVlcMediaPlayer(env, thiz);
+    if (player == NULL)
+        return 0;
+
+    return libvlc_media_player_get_length(player);
+}
diff --git a/vlc-android/jni/libjnihelper/libjnihelper.h b/vlc-android/jni/libjnihelper/libjnihelper.h
new file mode 100644
index 0000000..580abd7
--- /dev/null
+++ b/vlc-android/jni/libjnihelper/libjnihelper.h
@@ -0,0 +1,219 @@
+/*****************************************************************************
+ * libjnihelper.c
+ *
+ *  Created on: 2012-4-15
+ *      Author: bbcallen@gmail.com
+ *
+ *****************************************************************************
+ * Copyright © 2012 bbcallen<bbcallen@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+
+#ifndef LIBJNIHELPER_H_
+#define LIBJNIHELPER_H_
+
+/*****************************************************************************
+ * exception helper
+ *****************************************************************************/
+inline static int jniThrowException(JNIEnv *env, const char *classname,
+        const char *msg) {
+    jclass clazz = (*env)->FindClass(env, classname);
+    int ret = (*env)->ThrowNew(env, clazz, msg);
+
+    (*env)->DeleteLocalRef(env, clazz);
+    return ret;
+}
+
+inline static int jniThrowRuntimeException(JNIEnv *env, const char *msg) {
+    return jniThrowException(env, "java/lang/RuntimeException", msg);
+}
+
+/*****************************************************************************
+ * field helper
+ *****************************************************************************/
+typedef struct {
+    const char* name;
+    const char* signature;
+} JNISignature;
+
+typedef struct {
+    jclass clazz;
+    jfieldID fieldID;
+} JNIFieldIDHelper;
+
+inline static void jniReleaseFieldIDHelper(JNIEnv *env,
+        JNIFieldIDHelper *field) {
+    if (field->clazz != NULL)
+        (*env)->DeleteLocalRef(env, field->clazz);
+
+    field->clazz = NULL;
+    field->fieldID = NULL;
+}
+
+inline static JNIFieldIDHelper jniGetFieldID(JNIEnv *env, jobject thiz,
+        const char *name, const char *signature) {
+    JNIFieldIDHelper fieldHelper = { 0, 0 };
+    fieldHelper.clazz = (*env)->GetObjectClass(env, thiz);
+    if (!fieldHelper.clazz) {
+        jniThrowRuntimeException(env, "jnihelper: class not found");
+        return fieldHelper;
+    }
+
+    fieldHelper.fieldID = (*env)->GetFieldID(env, fieldHelper.clazz, name,
+            signature);
+    return fieldHelper;
+}
+
+inline static JNIFieldIDHelper jniGetIntFieldID(JNIEnv *env, jobject thiz,
+        const char *fieldname) {
+    return jniGetFieldID(env, thiz, fieldname, "I");
+}
+
+inline static jint jniGetIntField(JNIEnv *env, jobject thiz,
+        const char *fieldname) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz, fieldname);
+    if (!fieldHelper.fieldID) {
+        jniThrowRuntimeException(env, "jnihelper: field not found");
+        jniReleaseFieldIDHelper(env, &fieldHelper);
+        return 0;
+    }
+
+    jint value = (*env)->GetIntField(env, thiz, fieldHelper.fieldID);
+
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+    return value;
+}
+
+inline static void jniSetIntField(JNIEnv *env, jobject thiz,
+        const char *fieldname, jint value) {
+    JNIFieldIDHelper fieldHelper = jniGetIntFieldID(env, thiz, fieldname);
+    if (!fieldHelper.fieldID) {
+        jniThrowRuntimeException(env, "jnihelper: field not found");
+        return;
+    }
+
+    (*env)->SetIntField(env, thiz, fieldHelper.fieldID, value);
+
+    jniReleaseFieldIDHelper(env, &fieldHelper);
+}
+
+/*****************************************************************************
+ * method helper
+ *****************************************************************************/
+typedef struct {
+    jclass clazz;
+    jmethodID methodID;
+} JNIMethodIDHelper;
+
+inline static void jniReleaseMethodIDHelper(JNIEnv *env,
+        JNIMethodIDHelper *field) {
+    (*env)->DeleteLocalRef(env, field->clazz);
+    field->clazz = NULL;
+    field->methodID = NULL;
+}
+
+inline static JNIMethodIDHelper jniGetMethodID(JNIEnv *env, jobject thiz,
+        JNISignature *member) {
+    JNIMethodIDHelper methodHelper = { 0, 0 };
+
+    methodHelper.clazz = (*env)->GetObjectClass(env, thiz);
+    if (methodHelper.clazz == NULL) {
+        jniThrowRuntimeException(env, "jnihelper: class not found");
+        return methodHelper;
+    }
+
+    methodHelper.methodID = (*env)->GetMethodID(env, methodHelper.clazz,
+            member->name, member->signature);
+    return methodHelper;
+}
+
+inline static JNIMethodIDHelper jniGetStaticMethodID(JNIEnv *env,
+        const char* className, JNISignature *member) {
+    JNIMethodIDHelper methodHelper = { 0, 0 };
+
+    methodHelper.clazz = (*env)->FindClass(env, className);
+    if (methodHelper.clazz == NULL) {
+        jniThrowRuntimeException(env, "jnihelper: class not found");
+        return methodHelper;
+    }
+
+    methodHelper.methodID = (*env)->GetStaticMethodID(env, methodHelper.clazz,
+            member->name, member->signature);
+    return methodHelper;
+}
+
+inline static void jniCallVoidMethod(JNIEnv *env, jobject thiz,
+        JNISignature *method, ...) {
+    JNIMethodIDHelper methodHelper = jniGetMethodID(env, thiz, method);
+    if (methodHelper.clazz == NULL)
+        return;
+
+    if (methodHelper.methodID) {
+        va_list args;
+        va_start(args, method);
+        (*env)->CallVoidMethodV(env, thiz, methodHelper.methodID, args);
+        va_end(args);
+    } else {
+        jniThrowRuntimeException(env, "jnihelper: method not found");
+    }
+
+    jniReleaseMethodIDHelper(env, &methodHelper);
+}
+
+inline static void jniCallStaticVoidMethod(JNIEnv *env, const char *className,
+        JNISignature *method, ...) {
+    JNIMethodIDHelper methodHelper = jniGetStaticMethodID(env, className,
+            method);
+    if (methodHelper.clazz == NULL)
+        return;
+
+    if (methodHelper.methodID) {
+        va_list args;
+        va_start(args, method);
+        (*env)->CallStaticVoidMethodV(env, methodHelper.clazz,
+                methodHelper.methodID, args);
+        va_end(args);
+    } else {
+        jniThrowRuntimeException(env, "jnihelper: method not found");
+    }
+
+    jniReleaseMethodIDHelper(env, &methodHelper);
+}
+
+/* throw exception when failed, so function always return meaningful value */
+inline static jint jniCallStaticIntMethod(JNIEnv *env, const char *className,
+        JNISignature *method, ...) {
+    JNIMethodIDHelper methodHelper = jniGetStaticMethodID(env, className,
+            method);
+    if (methodHelper.clazz == NULL)
+        return 0;
+
+    jint ret = 0;
+    if (methodHelper.methodID) {
+        va_list args;
+        va_start(args, method);
+        ret = (*env)->CallStaticIntMethodV(env, methodHelper.clazz,
+                methodHelper.methodID, args);
+        va_end(args);
+    } else {
+        jniThrowRuntimeException(env, "jnihelper: method not found");
+    }
+
+    jniReleaseMethodIDHelper(env, &methodHelper);
+    return ret;
+}
+
+#endif /* LIBJNIHELPER_H_ */
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VlcTestActivity.java b/vlc-android/src/org/videolan/vlc/gui/video/VlcTestActivity.java
new file mode 100644
index 0000000..7b15bd7
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VlcTestActivity.java
@@ -0,0 +1,129 @@
+package org.videolan.vlc.gui.video;
+
+import org.videolan.vlc.R;
+
+import tv.danmaku.media.AbsMediaPlayerException;
+import tv.danmaku.media.LibVlcInstance;
+import tv.danmaku.media.LibVlcMediaException;
+import tv.danmaku.media.VlcMediaPlayer;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.graphics.PixelFormat;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.SurfaceHolder.Callback;
+import android.view.ViewGroup.LayoutParams;
+
+public class VlcTestActivity extends Activity {
+
+	private static final int FADE_OUT = 1;
+	private static final int SHOW_PROGRESS = 2;
+	private static final int SURFACE_SIZE = 3;
+	private static final int FADE_OUT_INFO = 4;
+
+	private SurfaceView mSurface;
+	private SurfaceHolder mSurfaceHolder;
+
+	private VlcMediaPlayer mMediaPlayer;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.player);
+
+		mSurface = (SurfaceView) findViewById(R.id.player_surface);
+		mSurfaceHolder = mSurface.getHolder();
+		mSurfaceHolder.setFormat(PixelFormat.RGBX_8888);
+		mSurfaceHolder.addCallback(mSurfaceCallback);
+
+		String location = new String("http://i27.v.iask.com/f/1/4b82540ca4ea3bd19c82feaae99b4b4474736607.mp4");
+		if (getIntent().getAction() != null
+				&& getIntent().getAction().equals(Intent.ACTION_VIEW)) {
+			/* Started from external application */
+			location = getIntent().getDataString();
+		} else {
+			/* Started from VideoListActivity */
+			location = getIntent().getExtras().getString("itemLocation");
+		}
+
+		try {
+			mMediaPlayer = VlcMediaPlayer.create(this, new String[0]);
+			mMediaPlayer.setDataSource(location);
+			mMediaPlayer.start();
+		} catch (LibVlcMediaException e) {
+			e.printStackTrace();
+		} catch (AbsMediaPlayerException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	protected void onDestroy() {
+		super.onDestroy();
+	}
+
+	private void changeSurfaceSize() {
+		// get screen size
+		int dw = getWindowManager().getDefaultDisplay().getWidth();
+		int dh = getWindowManager().getDefaultDisplay().getHeight();
+
+		int videoWidth = mMediaPlayer.getVideoWidth();
+		int videoHeight = mMediaPlayer.getVideoHeight();
+
+		// calculate aspect ratio
+		double ar = (double) videoWidth / (double) videoHeight;
+		// calculate display aspect ratio
+		double dar = (double) dw / (double) dh;
+
+		if (dar < ar)
+			dh = (int) (dw / ar);
+		else
+			dw = (int) (dh * ar);
+
+		mSurfaceHolder.setFixedSize(videoWidth, videoHeight);
+		LayoutParams lp = mSurface.getLayoutParams();
+		lp.width = dw;
+		lp.height = dh;
+		mSurface.setLayoutParams(lp);
+		mSurface.invalidate();
+	}
+
+	/**
+	 * Handle resize of the surface and the overlay
+	 */
+	private Handler mHandler = new Handler() {
+
+		@Override
+		public void handleMessage(Message msg) {
+			switch (msg.what) {
+			case SURFACE_SIZE:
+				changeSurfaceSize();
+				break;
+			}
+		}
+	};
+
+	/**
+	 * attach and disattach surface to the lib
+	 */
+	private SurfaceHolder.Callback mSurfaceCallback = new Callback() {
+		public void surfaceChanged(SurfaceHolder holder, int format, int width,
+				int height) {
+			LibVlcInstance.attachGlobalSurface(holder.getSurface(),
+					VlcTestActivity.this, width, height);
+		}
+
+		public void surfaceCreated(SurfaceHolder holder) {
+		}
+
+		public void surfaceDestroyed(SurfaceHolder holder) {
+			LibVlcInstance.detachGlobalSurface();
+		}
+	};
+
+}
diff --git a/vlc-android/src/tv/danmaku/media/AbsMediaPlayer.java b/vlc-android/src/tv/danmaku/media/AbsMediaPlayer.java
new file mode 100644
index 0000000..a7151e0
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/AbsMediaPlayer.java
@@ -0,0 +1,141 @@
+/*****************************************************************************
+ * AbsMediaPlayer.java
+ * http://blog.moenyan.net/?p=18
+ * 
+ * Modified:
+ *  - 2012-03-13 --bbcallen <bbcallen@gmail.com>
+ *      remove unused methods and fields
+ *****************************************************************************
+ * Copyright © 2011-2012 tewilove <tewilove@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *****************************************************************************/
+package tv.danmaku.media;
+
+import java.io.IOException;
+
+import android.media.MediaPlayer;
+import android.view.SurfaceHolder;
+
+public abstract class AbsMediaPlayer {
+
+	public static final String TAG = AbsMediaPlayer.class.getName();
+
+	public static final int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK;
+	public static final int MEDIA_ERROR_SERVER_DIED = MediaPlayer.MEDIA_ERROR_SERVER_DIED;
+	public static final int MEDIA_ERROR_UNKNOWN = MediaPlayer.MEDIA_ERROR_UNKNOWN;
+	
+	protected AbsMediaPlayer.OnBufferingUpdateListener mOnBufferingUpdateListener = null;
+	protected AbsMediaPlayer.OnCompletionListener mOnCompletionListener = null;
+	protected AbsMediaPlayer.OnErrorListener mOnErrorListener = null;
+	protected AbsMediaPlayer.OnInfoListener mOnInfoListener = null;
+	protected AbsMediaPlayer.OnPreparedListener mOnPreparedListener = null;
+	protected AbsMediaPlayer.OnVideoSizeChangedListener mOnVideoSizeChangedListener = null;
+	protected AbsMediaPlayer.OnSeekCompleteListener mOnSeekCompleteListener = null;
+
+	public interface OnBufferingUpdateListener {
+		public void onBufferingUpdate(AbsMediaPlayer mp, int percent);
+	}
+
+	public interface OnCompletionListener {
+		public void onCompletion(AbsMediaPlayer mp);
+	}
+
+	public interface OnErrorListener {
+		public boolean onError(AbsMediaPlayer mp, int what, int extra);
+	}
+
+	public interface OnInfoListener {
+		public boolean onInfo(AbsMediaPlayer mp, int what, int extra);
+	}
+
+	public interface OnPreparedListener {
+		public void onPrepared(AbsMediaPlayer mp);
+	}
+
+	public interface OnVideoSizeChangedListener {
+		public void onVideoSizeChanged(AbsMediaPlayer mp, int width, int height);
+	}
+
+	public interface OnSeekCompleteListener {
+		public abstract void onSeekComplete(AbsMediaPlayer mp);
+	}
+
+	public abstract int getCurrentPosition();
+
+	public abstract int getDuration();
+
+	public abstract int getVideoHeight();
+
+	public abstract int getVideoWidth();
+
+	public abstract boolean isPlaying();
+
+	public abstract void start() throws IllegalStateException;
+
+	public abstract void stop() throws IllegalStateException;
+
+	public abstract void pause() throws IllegalStateException;
+
+	public abstract void prepareAsync() throws IllegalStateException;
+
+	public abstract void release();
+
+	public abstract void reset();
+
+	public abstract void seekTo(int msec) throws IllegalStateException;
+
+	public abstract void setDataSource(String path)
+			throws AbsMediaPlayerException, IOException,
+			IllegalArgumentException, IllegalStateException;
+
+	public abstract void setDisplay(SurfaceHolder holder);
+
+	public abstract void setAudioStreamType(int streamMusic);
+
+	public abstract void setScreenOnWhilePlaying(boolean screenOn);
+
+	public void setOnBufferingUpdateListener(
+			AbsMediaPlayer.OnBufferingUpdateListener listener) {
+		mOnBufferingUpdateListener = listener;
+	}
+
+	public void setOnCompletionListener(
+			AbsMediaPlayer.OnCompletionListener listener) {
+		mOnCompletionListener = listener;
+	}
+
+	public void setOnErrorListener(AbsMediaPlayer.OnErrorListener listener) {
+		mOnErrorListener = listener;
+	}
+
+	public void setOnInfoListener(AbsMediaPlayer.OnInfoListener listener) {
+		mOnInfoListener = listener;
+	}
+
+	public void setOnPreparedListener(AbsMediaPlayer.OnPreparedListener listener) {
+		mOnPreparedListener = listener;
+	}
+
+	public void setOnVideoSizeChangedListener(
+			AbsMediaPlayer.OnVideoSizeChangedListener listener) {
+		mOnVideoSizeChangedListener = listener;
+	}
+
+	public void setOnSeekCompleteListener(
+			AbsMediaPlayer.OnSeekCompleteListener listener) {
+		mOnSeekCompleteListener = listener;
+	}
+}
\ No newline at end of file
diff --git a/vlc-android/src/tv/danmaku/media/AbsMediaPlayerException.java b/vlc-android/src/tv/danmaku/media/AbsMediaPlayerException.java
new file mode 100644
index 0000000..ca1e9ae
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/AbsMediaPlayerException.java
@@ -0,0 +1,38 @@
+package tv.danmaku.media;
+
+public class AbsMediaPlayerException extends Exception {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = -133634959026453664L;
+
+	/**
+	 * Create an empty error
+	 */
+	public AbsMediaPlayerException() {
+		super();
+	}
+
+	/**
+	 * @param detailMessage
+	 */
+	public AbsMediaPlayerException(String detailMessage) {
+		super(detailMessage);
+	}
+
+	/**
+	 * @param throwable
+	 */
+	public AbsMediaPlayerException(Throwable throwable) {
+		super(throwable);
+	}
+
+	/**
+	 * @param detailMessage
+	 * @param throwable
+	 */
+	public AbsMediaPlayerException(String detailMessage, Throwable throwable) {
+		super(detailMessage, throwable);
+	}
+}
diff --git a/vlc-android/src/tv/danmaku/media/LibVlcInstance.java b/vlc-android/src/tv/danmaku/media/LibVlcInstance.java
new file mode 100644
index 0000000..8d7be7b
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/LibVlcInstance.java
@@ -0,0 +1,120 @@
+package tv.danmaku.media;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+
+import tv.danmaku.util.AppBuildConfig;
+import tv.danmaku.util.CollectionHelper;
+
+import android.view.Surface;
+
+public class LibVlcInstance {
+	// default parameters
+	private static final String[] sDefaultParameters = new String[] { "--intf",
+			"dummy", "--no-osd", "--no-plugins-cache", "--no-drop-late-frames",
+			"--no-video-title-show", "--no-stats", "--ffmpeg-fast",
+			"--ts-seek-percent" };
+
+	// debug parameters
+	public static final String[] sDebugLogParameters = new String[] { "-vvv",
+			"--logmode", "android", "--control", "logger", };
+
+	private static LibVlcInstance sGlobalInstance;
+
+	private LibVlcInstance() {
+	}
+
+	public static LibVlcInstance getGlobalInstance()
+			throws LibVlcMediaException {
+		if (sGlobalInstance != null)
+			return sGlobalInstance;
+
+		ArrayList<String> parameters = new ArrayList<String>();
+
+		CollectionHelper.Append(parameters, sDefaultParameters);
+
+		if (AppBuildConfig.DEBUG)
+			CollectionHelper.Append(parameters, sDebugLogParameters);
+
+		LibVlcInstance newInstance = new LibVlcInstance();
+
+		String[] finalParams = new String[parameters.size()];
+		finalParams = parameters.toArray(finalParams);
+		newInstance.nativeInit(finalParams);
+
+		sGlobalInstance = newInstance;
+		return newInstance;
+	}
+
+	public static int getGlobalNativeInstance() throws LibVlcMediaException {
+		LibVlcInstance vlcInstance = getGlobalInstance();
+		if (vlcInstance == null)
+			return 0;
+
+		return sGlobalInstance.mNativeInstance;
+	}
+
+	public static void destroyGlobalInstance() {
+		if (sGlobalInstance == null)
+			return;
+
+		LibVlcInstance instance = sGlobalInstance;
+		sGlobalInstance = null;
+		instance.nativeDestroy();
+	}
+
+	public static void attachGlobalSurface(Surface surface, Object parentView,
+			int width, int height) {
+		if (sGlobalInstance == null)
+			return;
+
+		sGlobalInstance.attachSurface(surface, parentView, width, height);
+	}
+
+	public static void detachGlobalSurface() {
+		if (sGlobalInstance == null)
+			return;
+
+		sGlobalInstance.detachSurface();
+	}
+
+	// fields used by native
+	private int mNativeInstance;
+
+	// native methods
+	private native void nativeInit(String[] arguments)
+			throws LibVlcMediaException;
+
+	private native void nativeDestroy();
+
+	private native void attachSurface(Surface surface, Object parentView,
+			int width, int height);
+
+	private native void detachSurface();
+
+	// methods called from native
+
+	private static int sApiLevel = 0;
+
+	/**
+	 * Returns the current Android SDK version This function is called by the
+	 * native code. This is used to know if we should use the native audio
+	 * output, or the amem as a fallback.
+	 */
+	private static int getAdkLevel() {
+		if (sApiLevel > 0)
+			return sApiLevel;
+		if (android.os.Build.VERSION.SDK.equalsIgnoreCase("3")) {
+			sApiLevel = 3;
+		} else {
+			try {
+				final Field f = android.os.Build.VERSION.class
+						.getDeclaredField("SDK_INT");
+				sApiLevel = (Integer) f.get(null);
+			} catch (final Exception e) {
+				return 0;
+			}
+		}
+		return sApiLevel;
+	}
+}
\ No newline at end of file
diff --git a/vlc-android/src/tv/danmaku/media/LibVlcMediaException.java b/vlc-android/src/tv/danmaku/media/LibVlcMediaException.java
new file mode 100644
index 0000000..df46a6b
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/LibVlcMediaException.java
@@ -0,0 +1,37 @@
+package tv.danmaku.media;
+
+public class LibVlcMediaException extends AbsMediaPlayerException {
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = -4612293905769082540L;
+
+	/**
+	 * Create an empty error
+	 */
+	public LibVlcMediaException() {
+		super();
+	}
+
+	/**
+	 * @param detailMessage
+	 */
+	public LibVlcMediaException(String detailMessage) {
+		super(detailMessage);
+	}
+
+	/**
+	 * @param throwable
+	 */
+	public LibVlcMediaException(Throwable throwable) {
+		super(throwable);
+	}
+
+	/**
+	 * @param detailMessage
+	 * @param throwable
+	 */
+	public LibVlcMediaException(String detailMessage, Throwable throwable) {
+		super(detailMessage, throwable);
+	}
+}
diff --git a/vlc-android/src/tv/danmaku/media/LibVlcMediaPlayer.java b/vlc-android/src/tv/danmaku/media/LibVlcMediaPlayer.java
new file mode 100644
index 0000000..c8341e2
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/LibVlcMediaPlayer.java
@@ -0,0 +1,125 @@
+package tv.danmaku.media;
+
+import java.lang.ref.WeakReference;
+
+import tv.danmaku.util.DebugLog;
+import android.os.Handler;
+
+public class LibVlcMediaPlayer {
+	public static final String TAG = LibVlcMediaPlayer.class.getName();
+	
+	/*
+	 * Be sure to subscribe to events you need in the JNI too.
+	 */
+
+	// public static final int MediaMetaChanged = 0;
+	// public static final int MediaSubItemAdded = 1;
+	public static final int MediaDurationChanged = 2;
+	public static final int MediaParsedChanged = 3;
+	// public static final int MediaFreed = 4;
+	public static final int MediaStateChanged = 5;
+
+	// public static final int MediaPlayerMediaChanged = 0x100;
+	// public static final int MediaPlayerNothingSpecial = 0x101;
+	public static final int MediaPlayerOpening = 0x102;
+	public static final int MediaPlayerBuffering = 0x103;
+	public static final int MediaPlayerPlaying = 0x104;
+	public static final int MediaPlayerPaused = 0x105;
+	public static final int MediaPlayerStopped = 0x106;
+	// public static final int MediaPlayerForward = 0x107;
+	// public static final int MediaPlayerBackward = 0x108;
+	public static final int MediaPlayerEndReached = 0x109;
+	public static final int MediaPlayerEncounteredError = 0x10a;
+	// public static final int MediaPlayerTimeChanged = 0x10b;
+	// public static final int MediaPlayerPositionChanged = 0x10c;
+	public static final int MediaPlayerSeekableChanged = 0x10d;
+	public static final int MediaPlayerPausableChanged = 0x10e;
+
+	// public static final int MediaPlayerTitleChanged = 0x10f;
+	// public static final int MediaPlayerSnapshotTaken = 0x110;
+	// public static final int MediaPlayerLengthChanged = 0x111;
+
+	/* non-VLC message */
+
+	public static final int MSG_VIDEO_SIZE_CHANGED = 100000;
+    
+    public Handler mHandler;
+    public int mVideoWidth;
+    public int mVideoHeight;
+
+	public static LibVlcMediaPlayer create(int nativeVlcInstance, String mrl,
+			String[] options) throws LibVlcMediaException {
+		LibVlcMediaPlayer player = new LibVlcMediaPlayer();
+
+		player.nativeSetupMediaPlayer(nativeVlcInstance,
+				new WeakReference<LibVlcMediaPlayer>(player), mrl, options);
+
+		return player;
+	}
+
+	private LibVlcMediaPlayer() {
+	}
+	
+	public void setHandler(Handler handler) {
+		mHandler = handler;
+	}
+
+	// native methods
+	public native void nativeSetupMediaPlayer(int nativeVlcInstance,
+			WeakReference<LibVlcMediaPlayer> weakThis, String mrl,
+			String[] options) throws LibVlcMediaException;
+
+	public native void nativeReleaseMediaPlayer();
+
+	public native void nativePlay() throws IllegalStateException;
+
+	public native void nativeStop() throws IllegalStateException;
+
+	public native void nativePause() throws IllegalStateException;
+
+	public native boolean nativeIsPlaying();
+
+	/* in ms */
+	public native long nativeGetLength();
+
+	/* 0.0f ~ 1.0f */
+	public native void nativeSetPosition(float position)
+			throws IllegalStateException;
+
+	/* 0.0f ~ 1.0f */
+	public native float nativeGetPosition();
+
+	/* in ms */
+	public native void nativeSetTime(long time) throws IllegalStateException;
+
+	/* in ms */
+	public native long nativeGetTime();
+
+	// fields used by native
+
+	private int mNativeMediaPlayer;
+	private int mNativeWeakThis;
+
+	// methods called from native
+
+	// call from native
+	public void setSurfaceSize(int width, int height) {
+		DebugLog.v(TAG, "native setSurfaceSize");
+		mVideoWidth = width;
+		mVideoHeight = height;
+
+		mHandler.sendEmptyMessage(MSG_VIDEO_SIZE_CHANGED);
+	}
+
+	private static void onNativeEvents(Object weakThiz, int what, int arg1,
+			int arg2, Object obj) {
+		if (weakThiz == null)
+			return;
+
+		if (!(weakThiz instanceof WeakReference<?>))
+			return;
+
+		@SuppressWarnings("unchecked")
+		WeakReference<LibVlcMediaPlayer> weakMediaPlayer = (WeakReference<LibVlcMediaPlayer>) weakThiz;
+	}
+}
diff --git a/vlc-android/src/tv/danmaku/media/VlcMediaPlayer.java b/vlc-android/src/tv/danmaku/media/VlcMediaPlayer.java
new file mode 100644
index 0000000..aac9a6b
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/media/VlcMediaPlayer.java
@@ -0,0 +1,145 @@
+package tv.danmaku.media;
+
+import android.content.Context;
+import android.view.SurfaceHolder;
+
+public class VlcMediaPlayer extends AbsMediaPlayer {
+	// default options
+	private static final String[] sDefaultOptions = new String[] {};
+
+	private int mNativeVlcInstance;
+	private LibVlcMediaPlayer mNativePlayer;
+
+	public static VlcMediaPlayer create(Context context, String[] extraParams)
+			throws LibVlcMediaException {
+		int nativeVlcInstance = LibVlcInstance.getGlobalNativeInstance();
+		if (nativeVlcInstance == 0)
+			return null;
+
+		return new VlcMediaPlayer(nativeVlcInstance);
+	}
+
+	private VlcMediaPlayer(int nativeVlcInstance) {
+		mNativeVlcInstance = nativeVlcInstance;
+	}
+
+	@Override
+	public void setDataSource(String path) throws AbsMediaPlayerException {
+		reset();
+
+		mNativePlayer = LibVlcMediaPlayer.create(mNativeVlcInstance, path,
+				sDefaultOptions);
+	}
+
+	@Override
+	public int getCurrentPosition() {
+		if (mNativePlayer == null)
+			return 0;
+
+		return (int) mNativePlayer.nativeGetTime();
+	}
+
+	@Override
+	public int getDuration() {
+		if (mNativePlayer == null)
+			return 0;
+
+		return (int) mNativePlayer.nativeGetLength();
+	}
+
+	@Override
+	public int getVideoHeight() {
+		if (mNativePlayer == null)
+			return 0;
+		
+		return mNativePlayer.mVideoHeight;
+	}
+
+	@Override
+	public int getVideoWidth() {
+		if (mNativePlayer == null)
+			return 0;
+		
+		return mNativePlayer.mVideoWidth;
+	}
+
+	@Override
+	public boolean isPlaying() {
+		if (mNativePlayer == null)
+			return false;
+		
+		return mNativePlayer.nativeIsPlaying();
+	}
+
+	@Override
+	public void start() throws IllegalStateException {
+		if (mNativePlayer == null)
+			throw new IllegalStateException("player not init");
+		
+		mNativePlayer.nativePlay();
+	}
+
+	@Override
+	public void stop() {
+		if (mNativePlayer == null)
+			return;
+		
+		mNativePlayer.nativeStop();
+	}
+
+	@Override
+	public void pause() {
+		if (mNativePlayer == null)
+			return;
+		
+		mNativePlayer.nativePause();
+	}
+
+	@Override
+	public void prepareAsync() throws IllegalStateException {
+		if (mNativePlayer == null)
+			throw new IllegalStateException("player not init");
+		
+		mNativePlayer.nativePlay();
+	}
+
+	@Override
+	public void release() {
+		reset();
+	}
+
+	@Override
+	public void reset() {
+		if (mNativePlayer != null) {
+			mNativePlayer.nativeStop();
+			mNativePlayer.nativeReleaseMediaPlayer();
+			mNativePlayer = null;
+		}
+	}
+
+	@Override
+	public void seekTo(int msec) throws IllegalStateException {
+		if (mNativePlayer == null)
+			throw new IllegalStateException("player not init");
+		
+		mNativePlayer.nativeSetTime(msec);
+	}
+
+	@Override
+	public void setAudioStreamType(int streamMusic) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setScreenOnWhilePlaying(boolean screenOn) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setDisplay(SurfaceHolder holder) {
+		// TODO Auto-generated method stub
+
+	}
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppBuild.java b/vlc-android/src/tv/danmaku/util/AppBuild.java
new file mode 100644
index 0000000..1dea45b
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppBuild.java
@@ -0,0 +1,74 @@
+package tv.danmaku.util;
+
+import java.lang.reflect.Field;
+
+import android.os.Build;
+import android.text.TextUtils;
+
+public class AppBuild {
+    
+    public static final String ABI_ARMv7a = "armeabi-v7a";
+    public static final String ABI_ARM = "armeabi";
+
+    public static final int getSDKVersion() {
+        return Build.VERSION.SDK_INT;
+    }
+    
+    public static boolean supportARMv7a() {
+        return supportABI(ABI_ARMv7a);
+    }
+    
+    public static boolean supportABI(String requestAbi) {
+        String abi = get_CPU_ABI();
+        if (!TextUtils.isEmpty(abi) && abi.equalsIgnoreCase(requestAbi))
+            return true;
+        
+        String abi2 = get_CPU_ABI2();
+        if (!TextUtils.isEmpty(abi2) && abi.equalsIgnoreCase(requestAbi))
+            return true;
+        
+        return false;
+    }
+
+    public static final String getParsedCpuAbiInfo() {
+        StringBuilder cpuAbiInfo = new StringBuilder();
+        String cpuAbi = AppBuild.get_CPU_ABI();
+        if (!TextUtils.isEmpty(cpuAbi)) {
+            cpuAbiInfo.append("CPU ABI : ");
+            cpuAbiInfo.append(cpuAbi);
+            cpuAbiInfo.append("\n");
+        }
+
+        String cpuAbi2 = AppBuild.get_CPU_ABI2();
+        if (!TextUtils.isEmpty(cpuAbi)) {
+            cpuAbiInfo.append("CPU ABI2 : ");
+            cpuAbiInfo.append(cpuAbi2);
+            cpuAbiInfo.append("\n");
+        }
+
+        return cpuAbiInfo.toString();
+    }
+
+    public static final String get_CPU_ABI() {
+        return Build.CPU_ABI;
+    }
+
+    public static final String get_CPU_ABI2() {
+        try {
+            Field field = Build.class.getDeclaredField("CPU_ABI2");
+            if (field == null)
+                return null;
+
+            Object fieldValue = field.get(null);
+            if (field == null || !(fieldValue instanceof String)) {
+                return null;
+            }
+
+            return (String) fieldValue;
+        } catch (Exception e) {
+
+        }
+
+        return null;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppBuildConfig.java b/vlc-android/src/tv/danmaku/util/AppBuildConfig.java
new file mode 100644
index 0000000..a53286d
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppBuildConfig.java
@@ -0,0 +1,6 @@
+package tv.danmaku.util;
+
+// gen/BuildConfig is not reliable by now
+public final class AppBuildConfig {
+    public final static boolean DEBUG = true;
+}
\ No newline at end of file
diff --git a/vlc-android/src/tv/danmaku/util/AppConnectivityManager.java b/vlc-android/src/tv/danmaku/util/AppConnectivityManager.java
new file mode 100644
index 0000000..b6191d9
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppConnectivityManager.java
@@ -0,0 +1,24 @@
+package tv.danmaku.util;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+public class AppConnectivityManager {
+    
+    public static NetworkInfo getActivieNetworkInfo(Context context) {
+        ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        if (manager == null)
+            return null;
+
+        return manager.getActiveNetworkInfo();
+    }
+    
+    public static boolean isConnectedOrConnecting(Context context) {
+        NetworkInfo networkInfo = getActivieNetworkInfo(context);
+        if (networkInfo == null)
+            return false;
+
+        return networkInfo.isConnectedOrConnecting();
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppContext.java b/vlc-android/src/tv/danmaku/util/AppContext.java
new file mode 100644
index 0000000..cd7768b
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppContext.java
@@ -0,0 +1,115 @@
+package tv.danmaku.util;
+
+import java.io.File;
+import android.content.Context;
+import android.os.Environment;
+import android.text.TextUtils;
+
+public class AppContext {
+    private static final String THUMB_SUB_DIR_NAME = "thumb";
+
+    public static boolean isDebugMode() {
+        return true;
+    }
+
+    public static File getThumbCacheDir(Context context, int subDirId)
+            throws SecurityException {
+        String subDir = String.format("%s/%03d", THUMB_SUB_DIR_NAME, subDirId);
+        if (TextUtils.isEmpty(subDir))
+            return null;
+
+        // 优先使用SD卡
+        File externalCacheDir = getExternalCacheDir(context);
+        if (externalCacheDir != null) {
+
+            File externalThumbCacheDir = new File(externalCacheDir, subDir);
+            if (externalThumbCacheDir.isDirectory())
+                return externalThumbCacheDir;
+
+            externalThumbCacheDir.mkdirs();
+            if (externalThumbCacheDir.isDirectory())
+                return externalThumbCacheDir;
+        }
+
+        // 如果没有SD卡,则使用默认存储
+        File systemCacheDir = context.getCacheDir();
+        if (systemCacheDir != null) {
+
+            File systemThumbCacheDir = new File(systemCacheDir, subDir);
+            if (systemThumbCacheDir.isDirectory())
+                return systemThumbCacheDir;
+
+            systemThumbCacheDir.mkdirs();
+            if (systemThumbCacheDir.isDirectory())
+                return systemThumbCacheDir;
+        }
+
+        return null;
+    }
+
+    // for Android 2.3
+    // public static getExternalCacheDir() {
+    // Context context = getContext();
+    // if (context == null)
+    // return null;
+    //
+    // return context.getExternalCacheDir();
+    // }
+
+    // for Android 2.1
+    public static File getExternalCacheDir(Context context) {
+        StringBuilder relPath = new StringBuilder("Android/data");
+        relPath.append("/");
+        relPath.append(context.getPackageName());
+        relPath.append("/cache");
+
+        File extStorage = Environment.getExternalStorageDirectory();
+        return new File(extStorage, relPath.toString());
+    }
+
+    public static void clearThumbCacheDir(Context context) {
+        String subDir = String.format("%s", THUMB_SUB_DIR_NAME);
+        if (TextUtils.isEmpty(subDir))
+            return;
+
+        // 清除SD卡的缓存
+        File externalCacheDir = getExternalCacheDir(context);
+        if (externalCacheDir != null) {
+
+            File externalThumbCacheDir = new File(externalCacheDir, subDir);
+            if (externalThumbCacheDir.isDirectory())
+                doClearThumbCacheDir(externalThumbCacheDir);
+        }
+
+        // 清除默认存储的缓存
+        File systemCacheDir = context.getCacheDir();
+        if (systemCacheDir != null) {
+
+            File systemThumbCacheDir = new File(systemCacheDir, subDir);
+            if (systemThumbCacheDir.isDirectory())
+                doClearThumbCacheDir(systemThumbCacheDir);
+        }
+    }
+
+    private static void doClearThumbCacheDir(File thumbRootDir) {
+        if (thumbRootDir.isDirectory()) {
+            File[] subDirList = thumbRootDir.listFiles();
+            if (subDirList != null) {
+
+                for (File subDir : subDirList) {
+                    if (subDir.isDirectory()) {
+                        File[] thumbList = subDir.listFiles();
+                        if (thumbList != null) {
+
+                            for (File thumb : thumbList) {
+                                if (!thumb.isDirectory()) {
+                                    thumb.delete();
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppCpuInfo.java b/vlc-android/src/tv/danmaku/util/AppCpuInfo.java
new file mode 100644
index 0000000..fda2e14
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppCpuInfo.java
@@ -0,0 +1,282 @@
+package tv.danmaku.util;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import android.text.TextUtils;
+
+/* -
+ * Qualcomm CPU part list:
+ * 
+ * 0x00f
+ *  MSM8255, glacier, HTC
+ *  MSM8255, zeus, Sony Ericsson Xperia PLAY
+ *  MSM8255, mogami, Sony Ericsson Xperia neo V
+ *  
+ * 0x02d
+ *  QCT_MSM8X60_SURF
+ *  MSM8260, pyramid, HTC Sensation
+ *  MSM8X60, mione
+ *  MSM8260, doubleshot, HTC DoubleShot
+ */
+public class AppCpuInfo {
+
+    // #define ARM_CPUID_ARM1026 0x4106a262
+    // #define ARM_CPUID_ARM926 0x41069265
+    // #define ARM_CPUID_ARM946 0x41059461
+    // #define ARM_CPUID_TI915T 0x54029152
+    // #define ARM_CPUID_TI925T 0x54029252
+    // #define ARM_CPUID_SA1100 0x4401A11B
+    // #define ARM_CPUID_SA1110 0x6901B119
+    // #define ARM_CPUID_PXA250 0x69052100
+    // #define ARM_CPUID_PXA255 0x69052d00
+    // #define ARM_CPUID_PXA260 0x69052903
+    // #define ARM_CPUID_PXA261 0x69052d05
+    // #define ARM_CPUID_PXA262 0x69052d06
+    // #define ARM_CPUID_PXA270 0x69054110
+    // #define ARM_CPUID_PXA270_A0 0x69054110
+    // #define ARM_CPUID_PXA270_A1 0x69054111
+    // #define ARM_CPUID_PXA270_B0 0x69054112
+    // #define ARM_CPUID_PXA270_B1 0x69054113
+    // #define ARM_CPUID_PXA270_C0 0x69054114
+    // #define ARM_CPUID_PXA270_C5 0x69054117
+    // #define ARM_CPUID_ARM1136 0x4117b363
+    // #define ARM_CPUID_ARM1136_R2 0x4107b362
+    // #define ARM_CPUID_ARM1176 0x410fb767
+    // #define ARM_CPUID_ARM11MPCORE 0x410fb022
+    // #define ARM_CPUID_CORTEXA8 0x410fc080
+    // #define ARM_CPUID_CORTEXA8_R2 0x412fc083
+    // #define ARM_CPUID_CORTEXA9 0x410fc090
+    // #define ARM_CPUID_CORTEXM3 0x410fc231
+    
+    // CPU implementer
+    public static final int CPU_IMPL_ARM_LIMITED = 0x41;    // 'A'
+    public static final int CPU_IMPL_DEC = 0x44;            // 'D'
+    public static final int CPU_IMPL_MOTO = 0x4d;           // 'M'
+    public static final int CPU_IMPL_QUALCOMM = 0x51;       // 'Q'
+    public static final int CPU_IMPL_MARVELL = 0x56;        // 'V'
+    public static final int CPU_IMPL_INTEL = 0x69;          // 'i'
+
+    // CPU part:
+    public static final int CPU_PART_NONE = 0x000;
+    public static final int CPU_PART_CORTEX_A5 = 0xc05;
+    public static final int CPU_PART_CORTEX_A8 = 0xc08;
+    public static final int CPU_PART_CORTEX_A9 = 0xc09;
+    public static final int CPU_PART_CORTEX_A15 = 0xc0f;
+
+    public static final int CPU_PART_CORTEX_R4 = 0xc14;
+    public static final int CPU_PART_CORTEX_R5 = 0xc15;
+
+    public static final int CPU_PART_CORTEX_M3 = 0xc23;
+
+    public static final int CPU_PART_ARM926 = 0x926;
+    public static final int CPU_PART_ARM946 = 0x946;
+    public static final int CPU_PART_ARM1026 = 0xa26;
+    public static final int CPU_PART_ARM1136 = 0xb36;
+    public static final int CPU_PART_ARM1156 = 0xb56;
+    public static final int CPU_PART_ARM1176 = 0xb76;
+    public static final int CPU_PART_ARM11_MPCORE = 0xb02;
+
+    public static Map<Integer, String> sCpuPartMap = Collections
+            .unmodifiableMap(new HashMap<Integer, String>() {
+                private static final long serialVersionUID = 4195997904984256276L;
+
+                {
+                    put(CPU_PART_CORTEX_A5, "Cortex-A5");
+                    put(CPU_PART_CORTEX_A8, "Cortex-A8");
+                    put(CPU_PART_CORTEX_A9, "Cortex-A9");
+                    put(CPU_PART_CORTEX_A15, "Cortex-A15");
+                    put(CPU_PART_CORTEX_R4, "Cortex-R4");
+                    put(CPU_PART_CORTEX_R5, "Cortex-R5");
+                    put(CPU_PART_CORTEX_M3, "Cortex-M3");
+                    put(CPU_PART_ARM926, "ARM926");
+                    put(CPU_PART_ARM946, "ARM946");
+                    put(CPU_PART_ARM1026, "ARM1026");
+                    put(CPU_PART_ARM1136, "ARM1136");
+                    put(CPU_PART_ARM1156, "ARM1156");
+                    put(CPU_PART_ARM1176, "ARM1176");
+                    put(CPU_PART_ARM11_MPCORE, "ARM11-MPCore");
+                }
+            });
+
+    public String mRawCpuInfo = new String();
+    public TreeMap<String, String> mRawInfoMap = new TreeMap<String, String>();
+    public int mCpuPart;
+    public TreeSet<String> mFeatureSet = new TreeSet<String>();
+
+    public static String getRawCpuInfo() {
+        FileInputStream inputStream = null;
+        try {
+            inputStream = new FileInputStream("/proc/cpuinfo");
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        String text = StreamHelper.readStreamLineByLine(inputStream);
+        StreamHelper.closeStream(inputStream);
+
+        return text;
+    }
+
+    public String getParsedCpuInfo() {
+        StringBuilder parsedCpuInfo = new StringBuilder();
+
+        parsedCpuInfo.append("CPU part : ");
+        parsedCpuInfo.append(getCpuPartText());
+        parsedCpuInfo.append("\n");
+
+        parsedCpuInfo.append("NEON : ");
+        parsedCpuInfo.append(supportNeon() ? "Yes" : "No");
+        parsedCpuInfo.append("\n");
+
+        return parsedCpuInfo.toString();
+    }
+
+    public static AppCpuInfo parseCpuInfo() {
+        FileInputStream inputStream = null;
+        try {
+            inputStream = new FileInputStream("/proc/cpuinfo");
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        InputStreamReader reader = new InputStreamReader(inputStream);
+        BufferedReader buffReader = new BufferedReader(reader);
+
+        try {
+            inputStream = new FileInputStream("/proc/cpuinfo");
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        AppCpuInfo cpuInfo = new AppCpuInfo();
+
+        try {
+            StringBuilder infoBuilder = new StringBuilder();
+            String line;
+            while ((line = buffReader.readLine()) != null) {
+                cpuInfo.addCpuInfo(line);
+
+                infoBuilder.append(line);
+                infoBuilder.append('\n');
+            }
+
+            cpuInfo.mRawCpuInfo = infoBuilder.toString();
+        } catch (IOException e) {
+            e.printStackTrace();
+            cpuInfo = null;
+        } finally {
+            try {
+                buffReader.close();
+                reader.close();
+                inputStream.close();
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        return cpuInfo;
+    }
+
+    public void addCpuInfo(String line) {
+        String[] lineInfo = line.split(":", 2);
+        if (lineInfo.length >= 2) {
+            addCpuInfo(lineInfo[0], lineInfo[1]);
+        }
+    }
+
+    public void addCpuInfo(String key, String value) {
+        key = key.toLowerCase().trim();
+        value = value.trim();
+
+        mRawInfoMap.put(key, value);
+
+        if (key.equals("cpu part")) {
+            value = value.toLowerCase();
+            int pos = value.toLowerCase().indexOf('x');
+            if (-1 == pos) {
+                mCpuPart = Integer.parseInt(value);
+            } else {
+                mCpuPart = Integer.parseInt(value.substring(pos + 1), 16);
+            }
+        } else if (key.equals("features")) {
+            value = value.toLowerCase();
+
+            String[] features = value.split(" ");
+            for (String featureItem : features) {
+                mFeatureSet.add(featureItem.trim());
+            }
+        }
+    }
+
+    public String getCpuPartText() {
+        return parseCpuPartText(mCpuPart);
+    }
+
+    public boolean isKnownCpuId() {
+        return sCpuPartMap.containsKey(mCpuPart);
+    }
+
+    public String getCpuIdString() {
+        String hardware = mRawInfoMap.get("hardware");
+        String implementer = mRawInfoMap.get("cpu implementer");
+        String architecture = mRawInfoMap.get("cpu architecture");
+        String variant = mRawInfoMap.get("cpu variant");
+        String part = mRawInfoMap.get("cpu part");
+        String revision = mRawInfoMap.get("cpu revision");
+        String featureList = mRawInfoMap.get("features").replace(' ', '_');
+
+        StringBuilder sb = new StringBuilder();
+        sb.append(hardware.trim().replace(' ', '_'));
+        sb.append('.');
+        sb.append(implementer);
+        sb.append('.');
+        sb.append(architecture);
+        sb.append('.');
+        sb.append(variant);
+        sb.append('.');
+        sb.append(part);
+        sb.append('.');
+        sb.append(revision);
+        sb.append('.');
+        sb.append(featureList);
+
+        return sb.toString();
+    }
+
+    public boolean isCortexA8() {
+        return CPU_PART_CORTEX_A8 == mCpuPart;
+    }
+
+    public boolean isCortexA9() {
+        return CPU_PART_CORTEX_A9 == mCpuPart;
+    }
+
+    public boolean supportNeon() {
+        return mFeatureSet.contains("neon");
+    }
+
+    public boolean supportVfpv3D16() {
+        return mFeatureSet.contains("vfpv3-d16");
+    }
+
+    public static String parseCpuPartText(int cpuPart) {
+        String cpuPartText = sCpuPartMap.get(cpuPart);
+        if (TextUtils.isEmpty(cpuPartText)) {
+            return String.format("Unknown:0x%x", cpuPart);
+        }
+
+        return cpuPartText;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppInputMethodManager.java b/vlc-android/src/tv/danmaku/util/AppInputMethodManager.java
new file mode 100644
index 0000000..5451388
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppInputMethodManager.java
@@ -0,0 +1,17 @@
+package tv.danmaku.util;
+
+import android.content.Context;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+
+public class AppInputMethodManager {
+
+    public static void showSoftInput(Context context, View view, int flags) {
+        InputMethodManager manager = (InputMethodManager) context
+                .getSystemService(Context.INPUT_METHOD_SERVICE);
+        if (manager == null)
+            return;
+
+        manager.showSoftInput(view, flags);
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppPackageManager.java b/vlc-android/src/tv/danmaku/util/AppPackageManager.java
new file mode 100644
index 0000000..a3327a4
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppPackageManager.java
@@ -0,0 +1,107 @@
+package tv.danmaku.util;
+
+import java.util.List;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+
+public class AppPackageManager {
+
+    public static PackageInfo getPackageInfo(Context context, String packageName, int flag) {
+        PackageManager manager = context.getPackageManager();
+        if (manager == null)
+            return null;
+
+        try {
+            return manager.getPackageInfo(packageName, flag);
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public static ApplicationInfo getApplicationInfo(Context context, String packageName) {
+        PackageInfo pkgInfo = getPackageInfo(context, packageName, 0);
+        if (pkgInfo == null)
+            return null;
+
+        return pkgInfo.applicationInfo;
+    }
+
+    public static String getAppLabel(Context context, String packageName) {
+        PackageManager pkgManager = context.getPackageManager();
+        if (pkgManager == null)
+            return null;
+
+        PackageInfo pkgInfo;
+        try {
+            pkgInfo = pkgManager.getPackageInfo(packageName, 0);
+            if (pkgInfo == null)
+                return null;
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        ApplicationInfo appInfo = pkgInfo.applicationInfo;
+        if (appInfo == null)
+            return null;
+
+        CharSequence cs = appInfo.loadLabel(pkgManager);
+        if (cs == null)
+            return null;
+
+        return cs.toString();
+    }
+
+    public static String getActivityLabel(Context context, ComponentName name) {
+        PackageManager pkgManager = context.getPackageManager();
+        if (pkgManager == null)
+            return null;
+
+        ActivityInfo activityInfo;
+        try {
+            activityInfo = pkgManager.getActivityInfo(name, 0);
+            if (activityInfo == null)
+                return null;
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        CharSequence cs = activityInfo.loadLabel(pkgManager);
+        if (cs == null)
+            return null;
+
+        return cs.toString();
+    }
+
+    public static List<ResolveInfo> queryIntentActivities(Context context, Intent intent,
+            int flags) {
+
+        PackageManager manager = context.getPackageManager();
+        if (manager == null)
+            return null;
+
+        return manager.queryIntentActivities(intent, flags);
+    }
+    
+    public static String getVersion(Context context) {
+        try {
+            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(
+                    context.getPackageName(), 0);
+
+            return packageInfo.versionName;
+        } catch (PackageManager.NameNotFoundException e) {
+        }
+        
+        return null;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppPowerManager.java b/vlc-android/src/tv/danmaku/util/AppPowerManager.java
new file mode 100644
index 0000000..20e1a0c
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppPowerManager.java
@@ -0,0 +1,18 @@
+package tv.danmaku.util;
+
+import android.content.Context;
+import android.os.PowerManager;
+
+public class AppPowerManager {
+
+    public static PowerManager.WakeLock newWakeLock(Context context, int flags,
+            String tag) {
+        Object service = context.getSystemService(Context.POWER_SERVICE);
+        if (service == null)
+            return null;
+
+        PowerManager pw = (PowerManager) service;
+        return pw.newWakeLock(flags, tag);
+    }
+
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppResources.java b/vlc-android/src/tv/danmaku/util/AppResources.java
new file mode 100644
index 0000000..c11a61c
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppResources.java
@@ -0,0 +1,43 @@
+package tv.danmaku.util;
+
+import java.io.InputStream;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+
+public class AppResources {
+
+    public static Drawable getDrawable(Context context, int id) {
+        Resources resources = context.getResources();
+        if (resources == null)
+            return null;
+
+        return resources.getDrawable(id);
+    }
+
+    public static int getColor(Context context, int id) {
+        Resources resources = context.getResources();
+        if (resources == null)
+            return 0;
+
+        return resources.getColor(id);
+    }
+
+    public static ColorStateList getColorStateList(Context context, int id) {
+        Resources resources = context.getResources();
+        if (resources == null)
+            return null;
+
+        return resources.getColorStateList(id);
+    }
+
+    public static String getTextFile(Context context, int id) {
+        InputStream inputStream = context.getResources().openRawResource(id);
+        
+        String text = StreamHelper.readStreamLineByLine(inputStream);
+        StreamHelper.closeStream(inputStream);
+
+        return text;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppToast.java b/vlc-android/src/tv/danmaku/util/AppToast.java
new file mode 100644
index 0000000..040a3dd
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppToast.java
@@ -0,0 +1,15 @@
+package tv.danmaku.util;
+
+import android.content.Context;
+import android.widget.Toast;
+
+public class AppToast {
+    public static void showToast(Context context, int textResId, int duration) {
+        showToast(context, context.getString(textResId), duration);
+    }
+
+    public static void showToast(Context context, String text, int duration) {
+        Toast toast = Toast.makeText(context, text, duration);
+        toast.show();
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppTypeFace.java b/vlc-android/src/tv/danmaku/util/AppTypeFace.java
new file mode 100644
index 0000000..c407a51
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppTypeFace.java
@@ -0,0 +1,35 @@
+package tv.danmaku.util;
+
+import java.util.TreeMap;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.graphics.Typeface;
+
+public class AppTypeFace {
+
+    private static TreeMap<String, Typeface> mTypefaceCache = new TreeMap<String, Typeface>();  
+    
+    public static Typeface createDanmakuFontFromAsset(Context context) {
+        return createFromAsset(context, "fonts/danmaku.ttf");
+    }
+
+    public static Typeface createFromAsset(Context context, String path) {
+        Typeface tf = mTypefaceCache.get(path);
+        if (tf != null)
+            return tf;
+        
+        AssetManager am = context.getAssets();
+        if (am == null)
+            return null;
+        
+        try {
+            tf = Typeface.createFromAsset(am, path);
+            mTypefaceCache.put(path, tf);
+        } catch (RuntimeException e) {
+            mTypefaceCache.put(path, null);
+        }
+        
+        return tf;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/AppWindowManager.java b/vlc-android/src/tv/danmaku/util/AppWindowManager.java
new file mode 100644
index 0000000..b778a9e
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/AppWindowManager.java
@@ -0,0 +1,72 @@
+package tv.danmaku.util;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.view.Display;
+import android.view.WindowManager;
+
+public class AppWindowManager {
+    public static final String TAG = AppWindowManager.class.getName();
+
+    public enum AspectRadio {
+        RADIO_ADJUST_CONTENT,
+        RADIO_4_3,
+        RADIO_16_9,
+    };
+    
+    public static WindowManager getWindowManager(Context context) {
+        Object service = context.getSystemService(Context.WINDOW_SERVICE);
+        if (service == null)
+            return null;
+
+        return (WindowManager) service;
+    }
+
+    public static Display getDefaultDisplay (Context context) {
+        WindowManager wm = getWindowManager(context);
+        if (wm == null)
+            return null;
+        
+        return wm.getDefaultDisplay();
+    }
+    
+    public static Point GetClippedDisplaySize(Context context, AspectRadio aspectRadio) {
+        Display display = getDefaultDisplay(context);
+        if (display == null)
+            return null;
+
+        int displayHeight = display.getHeight();
+        int displayWidth = display.getWidth();
+        int clippedWidth = -1;
+        int clippedHeight = -1;
+        switch (aspectRadio) {
+        case RADIO_4_3:
+            clippedWidth = 4;
+            clippedHeight = 3;
+            break;
+        case RADIO_16_9:
+            clippedWidth = 16;
+            clippedHeight = 9;
+            break;
+        case RADIO_ADJUST_CONTENT:
+            // no break;
+        default:
+            //DebugLog.v(TAG, "adjust " + displayWidth + ":" + displayHeight);
+            return new Point(displayWidth, displayHeight);
+        }
+        
+        double displayRadio = (double) displayWidth / (double) displayHeight;
+        double clipRadio = (double) clippedWidth / (double) clippedHeight;
+
+        if (displayRadio > clipRadio) {
+            displayWidth = (int)Math.round(displayHeight * clipRadio);
+            displayWidth = Math.min(displayWidth, display.getWidth());
+        } else {
+            displayHeight = (int)Math.round(displayWidth / clipRadio);
+            displayHeight = Math.min(displayHeight, display.getHeight());
+        }
+        
+        //DebugLog.v(TAG, "adjust " + displayWidth + ":" + displayHeight);
+        return new Point(displayWidth, displayHeight);
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/Assure.java b/vlc-android/src/tv/danmaku/util/Assure.java
new file mode 100644
index 0000000..443e6e4
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/Assure.java
@@ -0,0 +1,23 @@
+package tv.danmaku.util;
+
+public class Assure {
+    public static void checkTrue(boolean value) {
+        if (!value)
+            throw new IllegalArgumentException("AssureTrue");
+    }
+    
+    public static void checkNotNull(Object obj) {
+        if (obj == null)
+            throw new IllegalArgumentException("AssureNotNull");
+    }
+    
+    public static void CheckNotEqual(int expectNot, int real) {
+        if (expectNot == real)
+            throw new IllegalArgumentException("AssureNotEqual");
+    }
+    
+    public static void CheckEqual(int expect, int real) {
+        if (expect != real)
+            throw new IllegalArgumentException("AssureEqual");
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/CollectionHelper.java b/vlc-android/src/tv/danmaku/util/CollectionHelper.java
new file mode 100644
index 0000000..13830ba
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/CollectionHelper.java
@@ -0,0 +1,13 @@
+package tv.danmaku.util;
+
+import java.util.Collection;
+
+public class CollectionHelper {
+    public static <T> void Append(Collection<T> collection, T[] array) {
+        if (collection != null && array != null && array.length > 0) {
+            for (T element : array) {
+                collection.add(element);
+            }
+        }
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/DebugLog.java b/vlc-android/src/tv/danmaku/util/DebugLog.java
new file mode 100644
index 0000000..93051ec
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/DebugLog.java
@@ -0,0 +1,79 @@
+package tv.danmaku.util;
+
+import android.util.Log;
+
+public class DebugLog {
+    
+    // 调试配置,发布时,将 DEBUG_ON 置为 false
+    public static final boolean DEBUG_ON = AppBuildConfig.DEBUG;
+    public static final boolean DEBUG_OFF = false;
+
+    public static boolean ENABLE_ERROR = DEBUG_ON;
+    public static boolean ENABLE_WARN = DEBUG_ON;
+    public static boolean ENABLE_DEBUG = DEBUG_ON;
+    public static boolean ENABLE_VERBOSE = DEBUG_ON;
+
+    public static int e(String tag, String msg) {
+        if (ENABLE_ERROR) {
+            return Log.e(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int e(String tag, String msg, Throwable tr) {
+        if (ENABLE_ERROR) {
+            return Log.e(tag, msg, tr);
+        }
+
+        return 0;
+    }
+    
+    public static int w(String tag, String msg) {
+        if (ENABLE_WARN) {
+            return Log.w(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int w(String tag, String msg, Throwable tr) {
+        if (ENABLE_WARN) {
+            return Log.w(tag, msg, tr);
+        }
+
+        return 0;
+    }
+
+    public static int d(String tag, String msg) {
+        if (ENABLE_DEBUG) {
+            return Log.d(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int d(String tag, String msg, Throwable tr) {
+        if (ENABLE_DEBUG) {
+            return Log.d(tag, msg, tr);
+        }
+
+        return 0;
+    }
+
+    public static int v(String tag, String msg) {
+        if (ENABLE_VERBOSE) {
+            return Log.v(tag, msg);
+        }
+
+        return 0;
+    }
+
+    public static int v(String tag, String msg, Throwable tr) {
+        if (ENABLE_VERBOSE) {
+            return Log.v(tag, msg, tr);
+        }
+
+        return 0;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/IdentityComparator.java b/vlc-android/src/tv/danmaku/util/IdentityComparator.java
new file mode 100644
index 0000000..25d573e
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/IdentityComparator.java
@@ -0,0 +1,11 @@
+package tv.danmaku.util;
+
+import java.util.Comparator;
+
+public class IdentityComparator<T> implements Comparator<T> {
+
+    public int compare(Object lhs, Object rhs) {
+        return 0;
+    }
+
+}
diff --git a/vlc-android/src/tv/danmaku/util/IntRange.java b/vlc-android/src/tv/danmaku/util/IntRange.java
new file mode 100644
index 0000000..e81b598
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/IntRange.java
@@ -0,0 +1,14 @@
+package tv.danmaku.util;
+
+/*
+ * 表示一条评论沿纵轴占据的空间
+ */
+public class IntRange {
+    public int start;
+    public int end;
+    
+    public IntRange(int start, int end) {
+        this.start = start;
+        this.end = end;
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/PatternHelper.java b/vlc-android/src/tv/danmaku/util/PatternHelper.java
new file mode 100644
index 0000000..1888812
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/PatternHelper.java
@@ -0,0 +1,38 @@
+package tv.danmaku.util;
+
+import java.util.regex.MatchResult;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class PatternHelper {
+
+    public Pattern mPattern;
+
+    public PatternHelper(String pattern) {
+        mPattern = Pattern.compile(pattern);
+    }
+
+    public final String getFirstMatchString(String text) {
+        Matcher matcher = mPattern.matcher(text);
+        if (matcher == null)
+            return null;
+
+        if (!matcher.find())
+            return null;
+
+        MatchResult matchResult = matcher.toMatchResult();
+        return matchResult.group(1);
+    }
+
+    public final int getFirstMatchInt(String text, int defaultValue) {
+        String firstMatch = getFirstMatchString(text);
+        if (firstMatch == null)
+            return defaultValue;
+
+        try {
+            return Integer.valueOf(firstMatch);
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/StreamHelper.java b/vlc-android/src/tv/danmaku/util/StreamHelper.java
new file mode 100644
index 0000000..890b410
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/StreamHelper.java
@@ -0,0 +1,58 @@
+package tv.danmaku.util;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+public class StreamHelper {
+    public static String readStreamLineByLine(InputStream inputStream) {
+        InputStreamReader reader = new InputStreamReader(inputStream);
+        BufferedReader buffReader = new BufferedReader(reader);
+
+        StringBuilder text = new StringBuilder();
+        String resultText = null;
+
+        try {
+            String line;
+            while ((line = buffReader.readLine()) != null) {
+                text.append(line);
+                text.append('\n');
+            }
+            resultText = text.toString();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                buffReader.close();
+                reader.close();
+            } catch (Exception e) {
+
+            }
+        }
+
+        return resultText;
+    }
+    
+    public static void closeStream(InputStream inputStream) {
+        if (inputStream == null)
+            return;
+
+        try {
+            inputStream.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static void closeReader(BufferedReader reader) {
+        if (reader == null)
+            return;
+
+        try {
+            reader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } 
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/UriHelper.java b/vlc-android/src/tv/danmaku/util/UriHelper.java
new file mode 100644
index 0000000..6936855
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/UriHelper.java
@@ -0,0 +1,16 @@
+package tv.danmaku.util;
+
+import android.net.Uri;
+
+public class UriHelper {
+    // 包括点号
+    public static String getUriFileExtension(String url) {
+        Uri uri = Uri.parse(url);
+        String path = uri.getPath(); 
+        int extPos = path.lastIndexOf(".");
+        if (extPos == -1)
+            return null;
+        
+        return path.substring(extPos);
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/ViewHelper.java b/vlc-android/src/tv/danmaku/util/ViewHelper.java
new file mode 100644
index 0000000..67b70d6
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/ViewHelper.java
@@ -0,0 +1,123 @@
+package tv.danmaku.util;
+
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+
+public class ViewHelper {
+
+    // View BackgroundColor
+    public static void setViewBackgroundColor(View container, int id, int color) {
+        if (container == null)
+            return;
+
+        container.findViewById(id).setBackgroundColor(color);
+    }
+
+    public static void setViewBackgroundDrawable(View container, int id,
+            Drawable drawable) {
+        if (container == null)
+            return;
+
+        container.findViewById(id).setBackgroundDrawable(drawable);
+    }
+
+    public static void setViewBackgroundResource(View container, int id,
+            int resource) {
+        if (container == null)
+            return;
+
+        container.findViewById(id).setBackgroundResource(resource);
+    }
+
+    // View Visibility
+    public static void setViewVisibility(View container, int id, int visibility) {
+        if (container == null)
+            return;
+
+        container.findViewById(id).setVisibility(visibility);
+    }
+
+    // View OnClickListener
+    public static void setViewOnClickListener(View container, int id,
+            OnClickListener listener) {
+        if (container == null)
+            return;
+
+        container.findViewById(id).setOnClickListener(listener);
+    }
+
+    // ImageView Drawable
+    public static void setViewDrawable(View container, int id, int drawableId) {
+        if (container == null)
+            return;
+
+        setViewDrawable(container.findViewById(id), AppResources.getDrawable(container.getContext(), drawableId));
+    }
+    
+    public static void setViewDrawable(View container, int id, Drawable drawable) {
+        if (container == null)
+            return;
+
+        setViewDrawable(container.findViewById(id), drawable);
+    }
+
+    public static void setViewDrawable(View imageView, Drawable drawable) {
+        ((ImageView) imageView).setImageDrawable(drawable);
+    }
+
+    public static void setViewDrawable(ImageView imageView, Drawable drawable) {
+        imageView.setImageDrawable(drawable);
+    }
+
+    // TextView Text
+    public static void setViewText(View container, int id, int resource) {
+        if (container == null)
+            return;
+
+        setViewText(container, id, container.getContext().getString(resource));
+    }
+
+    public static void setViewText(View container, int id, String text) {
+        if (container == null)
+            return;
+
+        setViewText(container.findViewById(id), text);
+    }
+
+    public static void setViewText(View textView, String text) {
+        ((TextView) textView).setText(text);
+    }
+
+    public static void setViewText(TextView textView, String text) {
+        textView.setText(text);
+    }
+
+    // TextView Text
+    public static void setViewTypeface(View container, int id, Typeface face) {
+        if (container == null)
+            return;
+
+        setViewTypeface(container.findViewById(id), face);
+    }
+
+    public static void setViewTypeface(View textView, Typeface face) {
+        ((TextView) textView).setTypeface(face);
+    }
+
+    // ListView
+    public static View getChildAtPosition(ListView listView, int position) {
+        int firstPostion = listView.getFirstVisiblePosition();
+        int lastPostion = listView.getLastVisiblePosition();
+
+        if ((position < firstPostion) || (position > lastPostion)) {
+            return null;
+        }
+        
+        return listView.getChildAt(position - firstPostion + listView.getHeaderViewsCount());
+    }
+}
diff --git a/vlc-android/src/tv/danmaku/util/WeakActivity.java b/vlc-android/src/tv/danmaku/util/WeakActivity.java
new file mode 100644
index 0000000..0d9f01c
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/WeakActivity.java
@@ -0,0 +1,49 @@
+package tv.danmaku.util;
+
+import java.lang.ref.WeakReference;
+
+import android.app.Activity;
+import android.content.Intent;
+
+public class WeakActivity<T_Activity extends Activity> {
+    private WeakReference<T_Activity> mWeakReference;
+    
+    public WeakActivity(T_Activity activity) {
+        if (activity != null) {
+            mWeakReference = new WeakReference<T_Activity>(activity);
+        }
+    }
+    
+    final public void setActivity(T_Activity activity) {
+        if (activity == null) {
+            mWeakReference = null;
+        } else {
+            mWeakReference = new WeakReference<T_Activity>(activity);
+        }
+    }
+    
+    final public T_Activity getActivity() {
+        if (mWeakReference == null)
+            return null;
+        
+        return mWeakReference.get();
+    }
+    
+    // methods for Activity
+    final public void startActivity(Intent intent) {
+        T_Activity activity = getActivity();
+        if (activity == null)
+            return;
+        
+        activity.startActivity(intent);
+    }
+    
+    final public void finish() {
+        T_Activity activity = getActivity();
+        if (activity == null)
+            return;
+        
+        activity.finish();
+    }
+    
+}
diff --git a/vlc-android/src/tv/danmaku/util/WeakListeners.java b/vlc-android/src/tv/danmaku/util/WeakListeners.java
new file mode 100644
index 0000000..2e8a3a1
--- /dev/null
+++ b/vlc-android/src/tv/danmaku/util/WeakListeners.java
@@ -0,0 +1,31 @@
+package tv.danmaku.util;
+
+import java.lang.ref.WeakReference;
+
+import android.app.Activity;
+import android.view.View;
+
+public class WeakListeners {
+    
+    public static class CallFinishOnClicked implements View.OnClickListener {
+        private WeakReference<Activity> mWeakActivity;
+        
+        public CallFinishOnClicked(Activity activity) {
+            mWeakActivity = new WeakReference<Activity>(activity);
+        }
+
+        @Override
+        public void onClick(View v) {
+            if (mWeakActivity == null) {
+                return;
+            }
+            
+            Activity activity = mWeakActivity.get();
+            if (activity == null) {
+                return;
+            }
+            
+            activity.finish();
+        }
+    }
+}
-- 
1.7.9.4

